<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSL: csl::AbstractParent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image.png" href="../../../logo-marty.png"/>
<link href="style_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
      <a href="https://marty.in2p3.fr"><img alt="Logo" src="Logo1.svg" height=100px/></a></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">
       Documentation of <i><b>CSL</b></i>
   </div>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecsl.html">csl</a></li><li class="navelem"><a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">csl::AbstractParent Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for all parents (indicial, fields etc). All parents derive from this class.  
 <a href="classcsl_1_1AbstractParent.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="parent_8h_source.html">parent.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for csl::AbstractParent:</div>
<div class="dyncontent">
<div class="center"><img src="classcsl_1_1AbstractParent__inherit__graph.png" border="0" usemap="#csl_1_1AbstractParent_inherit__map" alt="Inheritance graph"/></div>
<map name="csl_1_1AbstractParent_inherit__map" id="csl_1_1AbstractParent_inherit__map">
<area shape="rect" id="node3" href="classcsl_1_1FieldParent.html" title="csl::FieldParent" alt="" coords="437,19,550,45"/>
<area shape="rect" id="node5" href="classcsl_1_1LiteralParent.html" title="csl::LiteralParent" alt="" coords="433,81,553,108"/>
<area shape="rect" id="node8" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). " alt="" coords="431,208,556,235"/>
<area shape="rect" id="node4" href="classcsl_1_1ScalarFieldParent.html" title="csl::ScalarFieldParent" alt="" coords="605,5,756,32"/>
<area shape="rect" id="node6" href="classcsl_1_1ConstantParent.html" title="csl::ConstantParent" alt="" coords="611,56,750,83"/>
<area shape="rect" id="node7" href="classcsl_1_1VariableParent.html" title="csl::VariableParent" alt="" coords="615,107,747,133"/>
<area shape="rect" id="node9" href="classcsl_1_1DeltaParent.html" title="Specialization of TensorParent for a kronecker delta. " alt="" coords="623,157,739,184"/>
<area shape="rect" id="node10" href="classcsl_1_1EpsilonParent.html" title="Specialization of TensorParent for a kronecker delta. " alt="" coords="617,208,745,235"/>
<area shape="rect" id="node11" href="classcsl_1_1MetricParent.html" title="Specialization of TensorParent for a matric object (two indices symmetric etc). An object of type Spa..." alt="" coords="620,259,741,285"/>
<area shape="rect" id="node12" href="classcsl_1_1TensorFieldParent.html" title="csl::TensorFieldParent" alt="" coords="604,309,757,336"/>
<area shape="rect" id="node13" href="classcsl_1_1TDerivativeParent.html" title="csl::TDerivativeParent" alt="" coords="805,309,957,336"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a8495f4cc8281410f8aa512c64116cb"><td class="memItemLeft" align="right" valign="top"><a id="a3a8495f4cc8281410f8aa512c64116cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a3a8495f4cc8281410f8aa512c64116cb">AbstractParent</a> ()</td></tr>
<tr class="memdesc:a3a8495f4cc8281410f8aa512c64116cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, parent with no name. <br /></td></tr>
<tr class="separator:a3a8495f4cc8281410f8aa512c64116cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961d277c9a277163931cb5b45906c83f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a961d277c9a277163931cb5b45906c83f">AbstractParent</a> (const std::string &amp;t_name)</td></tr>
<tr class="memdesc:a961d277c9a277163931cb5b45906c83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intializes the name of the parent.  <a href="#a961d277c9a277163931cb5b45906c83f">More...</a><br /></td></tr>
<tr class="separator:a961d277c9a277163931cb5b45906c83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88d1dd79f22b67744640124252dc093"><td class="memItemLeft" align="right" valign="top"><a id="ad88d1dd79f22b67744640124252dc093"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#ad88d1dd79f22b67744640124252dc093">AbstractParent</a> (const <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> &amp;abstract)=default</td></tr>
<tr class="memdesc:ad88d1dd79f22b67744640124252dc093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, c++ default. <br /></td></tr>
<tr class="separator:ad88d1dd79f22b67744640124252dc093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d13d559a8d68562b5827073b31b3c1a"><td class="memItemLeft" align="right" valign="top"><a id="a6d13d559a8d68562b5827073b31b3c1a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a6d13d559a8d68562b5827073b31b3c1a">~AbstractParent</a> ()</td></tr>
<tr class="memdesc:a6d13d559a8d68562b5827073b31b3c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a6d13d559a8d68562b5827073b31b3c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ac782bdbba8d40838c6aeffaa53f6"><td class="memItemLeft" align="right" valign="top"><a id="a831ac782bdbba8d40838c6aeffaa53f6"></a>
<a class="el" href="classcsl_1_1Parent.html">Parent</a>&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> ()</td></tr>
<tr class="separator:a831ac782bdbba8d40838c6aeffaa53f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e78f62f3624e0e6070f1da4ddd32943"><td class="memItemLeft" align="right" valign="top"><a id="a4e78f62f3624e0e6070f1da4ddd32943"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAnAbbreviation</b> () const</td></tr>
<tr class="separator:a4e78f62f3624e0e6070f1da4ddd32943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f321502a8aa481865be3e58bb241d"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#ab22f321502a8aa481865be3e58bb241d">getName</a> () const</td></tr>
<tr class="separator:ab22f321502a8aa481865be3e58bb241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacd759bca7fa6e750080a68ea970caa"><td class="memItemLeft" align="right" valign="top"><a id="acacd759bca7fa6e750080a68ea970caa"></a>
std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getLatexName</b> () const</td></tr>
<tr class="separator:acacd759bca7fa6e750080a68ea970caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9f642ad348b33efb70b9f4cf839c1b"><td class="memItemLeft" align="right" valign="top"><a id="a9d9f642ad348b33efb70b9f4cf839c1b"></a>
virtual std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getBaseName</b> () const</td></tr>
<tr class="separator:a9d9f642ad348b33efb70b9f4cf839c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ae5696856c551204addb95271333bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#af8ae5696856c551204addb95271333bf">getCommutable</a> () const</td></tr>
<tr class="separator:af8ae5696856c551204addb95271333bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0029cab35d92a9542c5fb21b6672212"><td class="memItemLeft" align="right" valign="top"><a id="ad0029cab35d92a9542c5fb21b6672212"></a>
<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getComplexProp</b> () const</td></tr>
<tr class="separator:ad0029cab35d92a9542c5fb21b6672212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e6f74e590cbf05dcafb4d9c3df8b9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a13e6f74e590cbf05dcafb4d9c3df8b9c">setName</a> (std::string t_name)</td></tr>
<tr class="separator:a13e6f74e590cbf05dcafb4d9c3df8b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a8cfc57a0bdf8178489c198755565b"><td class="memItemLeft" align="right" valign="top"><a id="af9a8cfc57a0bdf8178489c198755565b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setLatexName</b> (const std::string &amp;t_name)</td></tr>
<tr class="separator:af9a8cfc57a0bdf8178489c198755565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1bc83d1df8237e6bf50b6b8f732716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#aae1bc83d1df8237e6bf50b6b8f732716">setCommutable</a> (bool t_commutable)</td></tr>
<tr class="separator:aae1bc83d1df8237e6bf50b6b8f732716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd5de9db43c39e3ec0f1b9e391bcf4a"><td class="memItemLeft" align="right" valign="top"><a id="affd5de9db43c39e3ec0f1b9e391bcf4a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setComplexProperty</b> (<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> t_prop)</td></tr>
<tr class="separator:affd5de9db43c39e3ec0f1b9e391bcf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5ad2473de4d26c6c74a4cd6b0862fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a1d5ad2473de4d26c6c74a4cd6b0862fe">addProperty</a> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *prop)</td></tr>
<tr class="memdesc:a1d5ad2473de4d26c6c74a4cd6b0862fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a property for the parent.  <a href="#a1d5ad2473de4d26c6c74a4cd6b0862fe">More...</a><br /></td></tr>
<tr class="separator:a1d5ad2473de4d26c6c74a4cd6b0862fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05b94537305d4938b2e20364fa40b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#ab05b94537305d4938b2e20364fa40b43">removeProperty</a> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *prop)</td></tr>
<tr class="memdesc:ab05b94537305d4938b2e20364fa40b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a property.  <a href="#ab05b94537305d4938b2e20364fa40b43">More...</a><br /></td></tr>
<tr class="separator:ab05b94537305d4938b2e20364fa40b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02948077d67665cbe33ba0f8febda859"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecslParent.html#a83f078a60370b86ccd6b113eedff51c2">cslParent::PrimaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a02948077d67665cbe33ba0f8febda859">getPrimaryType</a> () const =0</td></tr>
<tr class="separator:a02948077d67665cbe33ba0f8febda859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9115038be74e35dbcd8ecdbba7e5a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecslParent.html#a880f05263e57bd6cac32e48fd45b7339">cslParent::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a6a9115038be74e35dbcd8ecdbba7e5a1">getType</a> () const =0</td></tr>
<tr class="separator:a6a9115038be74e35dbcd8ecdbba7e5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45297ef35dab1807a158056ec8dfac3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#ac45297ef35dab1807a158056ec8dfac3">getDim</a> () const</td></tr>
<tr class="separator:ac45297ef35dab1807a158056ec8dfac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c633dfff2c6a58ffbf2dae9ca9e07ae"><td class="memItemLeft" align="right" valign="top"><a id="a6c633dfff2c6a58ffbf2dae9ca9e07ae"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>printDefinition</b> (std::ostream &amp;out=std::cout, int indentSize=4, bool header=false) const =0</td></tr>
<tr class="separator:a6c633dfff2c6a58ffbf2dae9ca9e07ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789915324d1e21a6be70bbd495ada1cc"><td class="memItemLeft" align="right" valign="top"><a id="a789915324d1e21a6be70bbd495ada1cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printPropDefinition</b> (std::ostream &amp;out, int indentSize, bool header) const</td></tr>
<tr class="separator:a789915324d1e21a6be70bbd495ada1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbecc9ebf1ba07087c4e275cf81a767"><td class="memItemLeft" align="right" valign="top"><a id="a0cbecc9ebf1ba07087c4e275cf81a767"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>enableEvaluation</b> ()</td></tr>
<tr class="separator:a0cbecc9ebf1ba07087c4e275cf81a767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34cb190892a7b0d29cecf844d836e10"><td class="memItemLeft" align="right" valign="top"><a id="ad34cb190892a7b0d29cecf844d836e10"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>disableEvaluation</b> ()</td></tr>
<tr class="separator:ad34cb190892a7b0d29cecf844d836e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bbbbc2b43939c166feb7d8e7cc8537"><td class="memItemLeft" align="right" valign="top"><a id="a74bbbbc2b43939c166feb7d8e7cc8537"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>toggleEvaluation</b> ()</td></tr>
<tr class="separator:a74bbbbc2b43939c166feb7d8e7cc8537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ad22590439c20af630fd8046ea5dc8"><td class="memItemLeft" align="right" valign="top"><a id="a33ad22590439c20af630fd8046ea5dc8"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>evaluate</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> self, csl::eval::mode user_mode=csl::eval::base) const</td></tr>
<tr class="separator:a33ad22590439c20af630fd8046ea5dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cf14c2576a5b337f2e75059a5e002c"><td class="memItemLeft" align="right" valign="top"><a id="af7cf14c2576a5b337f2e75059a5e002c"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getEncapsulated</b> () const</td></tr>
<tr class="separator:af7cf14c2576a5b337f2e75059a5e002c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fb1b0329110a3caed8e68397c08c51"><td class="memItemLeft" align="right" valign="top"><a id="a38fb1b0329110a3caed8e68397c08c51"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getExactEncapsulated</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> self) const</td></tr>
<tr class="separator:a38fb1b0329110a3caed8e68397c08c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3085594e68b3845f352898e79237ba24"><td class="memItemLeft" align="right" valign="top"><a id="a3085594e68b3845f352898e79237ba24"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setEncapsulated</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)</td></tr>
<tr class="separator:a3085594e68b3845f352898e79237ba24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c81260a7b64e93b88dea1935b524505"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a6c81260a7b64e93b88dea1935b524505">getDim</a> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *t_space) const</td></tr>
<tr class="memdesc:a6c81260a7b64e93b88dea1935b524505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the parent relatively to a certain vector space, i.e. the number of indices in this vector space.  <a href="#a6c81260a7b64e93b88dea1935b524505">More...</a><br /></td></tr>
<tr class="separator:a6c81260a7b64e93b88dea1935b524505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236d774b05f017f117174469ba848142"><td class="memItemLeft" align="right" valign="top"><a id="a236d774b05f017f117174469ba848142"></a>
virtual std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSpace</b> () const</td></tr>
<tr class="separator:a236d774b05f017f117174469ba848142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bb772ebe5adafe83a9f504a56e05d0"><td class="memItemLeft" align="right" valign="top"><a id="a77bb772ebe5adafe83a9f504a56e05d0"></a>
virtual const <a class="el" href="classcsl_1_1Space.html">Space</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getFieldSpace</b> () const</td></tr>
<tr class="separator:a77bb772ebe5adafe83a9f504a56e05d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b28bb5fd2bd261e76a3980341ead1d"><td class="memItemLeft" align="right" valign="top"><a id="a11b28bb5fd2bd261e76a3980341ead1d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setFieldSpace</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *t_space)</td></tr>
<tr class="separator:a11b28bb5fd2bd261e76a3980341ead1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56df7eb3d90348eda50e3d6cc5cd8b0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#af56df7eb3d90348eda50e3d6cc5cd8b0">getFullySymmetric</a> () const</td></tr>
<tr class="separator:af56df7eb3d90348eda50e3d6cc5cd8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04c96ff80ee2f0786e59a7eafd71175"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#ab04c96ff80ee2f0786e59a7eafd71175">getFullyAntiSymmetric</a> () const</td></tr>
<tr class="separator:ab04c96ff80ee2f0786e59a7eafd71175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42c4b140d48c9319e0ae47436d040e1"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#ad42c4b140d48c9319e0ae47436d040e1">getPermutation</a> () const</td></tr>
<tr class="memdesc:ad42c4b140d48c9319e0ae47436d040e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> returns all the possible permutations of the tensor with respect to the symmetries or antisymmetries in a vector of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a>.  <a href="#ad42c4b140d48c9319e0ae47436d040e1">More...</a><br /></td></tr>
<tr class="separator:ad42c4b140d48c9319e0ae47436d040e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8028cba1cf0ca3e754111e52d629d24"><td class="memItemLeft" align="right" valign="top"><a id="aa8028cba1cf0ca3e754111e52d629d24"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValued</b> () const</td></tr>
<tr class="separator:aa8028cba1cf0ca3e754111e52d629d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc94486a83de9c73de39f78b1eafea4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#adcc94486a83de9c73de39f78b1eafea4">getTensor</a> () const</td></tr>
<tr class="memdesc:adcc94486a83de9c73de39f78b1eafea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a valued <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> returns the corresponding tensor. Valued means that the tensor has been defined by the user.  <a href="#adcc94486a83de9c73de39f78b1eafea4">More...</a><br /></td></tr>
<tr class="separator:adcc94486a83de9c73de39f78b1eafea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa574a83a5f60cc6fc9bd00f5dca747"><td class="memItemLeft" align="right" valign="top"><a id="affa574a83a5f60cc6fc9bd00f5dca747"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTensor</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:affa574a83a5f60cc6fc9bd00f5dca747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f86be4ff457fb18becedcca645b33f4"><td class="memItemLeft" align="right" valign="top"><a id="a4f86be4ff457fb18becedcca645b33f4"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a4f86be4ff457fb18becedcca645b33f4">getTrace</a> () const</td></tr>
<tr class="memdesc:a4f86be4ff457fb18becedcca645b33f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> of dimension 2 (in a given unique space) returns the trace of it, i.e. the sum of its diagonal elements. <br /></td></tr>
<tr class="separator:a4f86be4ff457fb18becedcca645b33f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf55413672b9d58875485edd1db4e563"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#adf55413672b9d58875485edd1db4e563">dependsOn</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:adf55413672b9d58875485edd1db4e563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the parent depends on another expression or not.  <a href="#adf55413672b9d58875485edd1db4e563">More...</a><br /></td></tr>
<tr class="separator:adf55413672b9d58875485edd1db4e563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74258391e7eae5a8cd0d629eabfe9ca9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a74258391e7eae5a8cd0d629eabfe9ca9">dependsExplicitlyOn</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a74258391e7eae5a8cd0d629eabfe9ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the parent depends explicitely on another expression or not.  <a href="#a74258391e7eae5a8cd0d629eabfe9ca9">More...</a><br /></td></tr>
<tr class="separator:a74258391e7eae5a8cd0d629eabfe9ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f226bf0ae04cbeba39bdd7e4265c6b1"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classcsl_1_1Equation.html">Equation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a9f226bf0ae04cbeba39bdd7e4265c6b1">getProperties</a> () const</td></tr>
<tr class="separator:a9f226bf0ae04cbeba39bdd7e4265c6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac691c3943a7bd3eb9c671927e2f91dc7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#ac691c3943a7bd3eb9c671927e2f91dc7">addSpace</a> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *t_space)</td></tr>
<tr class="memdesc:ac691c3943a7bd3eb9c671927e2f91dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dimension to an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> in a specific vector space.  <a href="#ac691c3943a7bd3eb9c671927e2f91dc7">More...</a><br /></td></tr>
<tr class="separator:ac691c3943a7bd3eb9c671927e2f91dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e866d96e2600f1f6f723bf62dee42b0"><td class="memItemLeft" align="right" valign="top"><a id="a3e866d96e2600f1f6f723bf62dee42b0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a3e866d96e2600f1f6f723bf62dee42b0">setFullySymmetric</a> ()</td></tr>
<tr class="memdesc:a3e866d96e2600f1f6f723bf62dee42b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> fully symmetric. <br /></td></tr>
<tr class="separator:a3e866d96e2600f1f6f723bf62dee42b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecc485d2526a3975b79b0c4a3da21d9"><td class="memItemLeft" align="right" valign="top"><a id="a8ecc485d2526a3975b79b0c4a3da21d9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a8ecc485d2526a3975b79b0c4a3da21d9">setFullyAntiSymmetric</a> ()</td></tr>
<tr class="memdesc:a8ecc485d2526a3975b79b0c4a3da21d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> fully antisymmetric. <br /></td></tr>
<tr class="separator:a8ecc485d2526a3975b79b0c4a3da21d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22286f40e94e30a5adffa36314961c3"><td class="memItemLeft" align="right" valign="top"><a id="ad22286f40e94e30a5adffa36314961c3"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isTraceLessIn</b> (<a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space) const</td></tr>
<tr class="separator:ad22286f40e94e30a5adffa36314961c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f3ca1657d6b2d3809adf39981e6204"><td class="memItemLeft" align="right" valign="top"><a id="ab6f3ca1657d6b2d3809adf39981e6204"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addTraceLessNess</b> (<a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space)</td></tr>
<tr class="separator:ab6f3ca1657d6b2d3809adf39981e6204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b06d1389b3f3ea597e91548810a3c70"><td class="memItemLeft" align="right" valign="top"><a id="a0b06d1389b3f3ea597e91548810a3c70"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeTraceLessNess</b> (<a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space)</td></tr>
<tr class="separator:a0b06d1389b3f3ea597e91548810a3c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4a585286e48ff062c33e96ec09531b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a0a4a585286e48ff062c33e96ec09531b">addSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a0a4a585286e48ff062c33e96ec09531b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a symmetry between indices in position <b>i1</b> and <b>i2</b>.  <a href="#a0a4a585286e48ff062c33e96ec09531b">More...</a><br /></td></tr>
<tr class="separator:a0a4a585286e48ff062c33e96ec09531b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5548d7f976f21a25d657fc723f7f7132"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a5548d7f976f21a25d657fc723f7f7132">addAntiSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a5548d7f976f21a25d657fc723f7f7132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an antisymmetry between indices in position <b>i1</b> and <b>i2</b>.  <a href="#a5548d7f976f21a25d657fc723f7f7132">More...</a><br /></td></tr>
<tr class="separator:a5548d7f976f21a25d657fc723f7f7132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ad3927cad378f4e83055533ea20d46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a79ad3927cad378f4e83055533ea20d46">setSymmetry</a> (const <a class="el" href="classcsl_1_1Symmetry.html">Symmetry</a> &amp;t_symmetry)</td></tr>
<tr class="memdesc:a79ad3927cad378f4e83055533ea20d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the symmetry properties of an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> from an object of type <a class="el" href="classcsl_1_1Symmetry.html" title="Handles the full symmetry properties of an TensorElement, i.e. a vector of Permutation objects...">Symmetry</a>. This erase all possible properties of (anti)symmetry the parent had before that.  <a href="#a79ad3927cad378f4e83055533ea20d46">More...</a><br /></td></tr>
<tr class="separator:a79ad3927cad378f4e83055533ea20d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd9dd3730422db222a395139786ea4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a5dd9dd3730422db222a395139786ea4b">setTensor</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;t_tensor)</td></tr>
<tr class="separator:a5dd9dd3730422db222a395139786ea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec47d729864161605c7cbcc6f726f59"><td class="memItemLeft" align="right" valign="top"><a id="a3ec47d729864161605c7cbcc6f726f59"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setTrace</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;t_trace)</td></tr>
<tr class="separator:a3ec47d729864161605c7cbcc6f726f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f680e00248dd59a1545488ec4b43c07"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a7f680e00248dd59a1545488ec4b43c07">hasContractionProperty</a> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *self, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B) const</td></tr>
<tr class="memdesc:a7f680e00248dd59a1545488ec4b43c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> has contraction properties with another expression.  <a href="#a7f680e00248dd59a1545488ec4b43c07">More...</a><br /></td></tr>
<tr class="separator:a7f680e00248dd59a1545488ec4b43c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df179280a63c410c84f7ea4edbcbee2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a4df179280a63c410c84f7ea4edbcbee2">contraction</a> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *self, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B) const</td></tr>
<tr class="memdesc:a4df179280a63c410c84f7ea4edbcbee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a contractoin property if there is one between <b>self</b> and <b>B</b>.  <a href="#a4df179280a63c410c84f7ea4edbcbee2">More...</a><br /></td></tr>
<tr class="separator:a4df179280a63c410c84f7ea4edbcbee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f41ce934d0e7260c1f8e8fddf70e14"><td class="memItemLeft" align="right" valign="top"><a id="a29f41ce934d0e7260c1f8e8fddf70e14"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasChainContractionProperty</b> () const</td></tr>
<tr class="separator:a29f41ce934d0e7260c1f8e8fddf70e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4491a6a8adcf9042aa26a8498a9478b"><td class="memItemLeft" align="right" valign="top"><a id="aa4491a6a8adcf9042aa26a8498a9478b"></a>
virtual std::vector&lt; <a class="el" href="classcsl_1_1ContractionChain.html">ContractionChain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getContractionProperties</b> () const</td></tr>
<tr class="separator:aa4491a6a8adcf9042aa26a8498a9478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce8745989273246a318d207e4c24ee9"><td class="memItemLeft" align="right" valign="top"><a id="acce8745989273246a318d207e4c24ee9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addContractionProperty</b> (csl::vector_expr const &amp;leftHandSide, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightHandSide)</td></tr>
<tr class="separator:acce8745989273246a318d207e4c24ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03f15bcc4f9dd93cf09739c9ecf4d03"><td class="memItemLeft" align="right" valign="top"><a id="af03f15bcc4f9dd93cf09739c9ecf4d03"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeContractionProperty</b> (csl::vector_expr const &amp;leftHandSide, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightHandSide)</td></tr>
<tr class="separator:af03f15bcc4f9dd93cf09739c9ecf4d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132e0cbebcf7e578da01c188ee75e45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a3132e0cbebcf7e578da01c188ee75e45">addSelfContraction</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;A, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;B, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;res, std::optional&lt; std::function&lt; bool(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt;&gt; condition=std::nullopt)</td></tr>
<tr class="memdesc:a3132e0cbebcf7e578da01c188ee75e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a contraction property between an Element and another that share the parent (*this).  <a href="#a3132e0cbebcf7e578da01c188ee75e45">More...</a><br /></td></tr>
<tr class="separator:a3132e0cbebcf7e578da01c188ee75e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0889b22a387aa58334e6c84aa9e7faf0"><td class="memItemLeft" align="right" valign="top"><a id="a0889b22a387aa58334e6c84aa9e7faf0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeSelfContraction</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;A, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;B)</td></tr>
<tr class="separator:a0889b22a387aa58334e6c84aa9e7faf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab893f8cc881da62b696c9a66abb1bbde"><td class="memItemLeft" align="right" valign="top"><a id="ab893f8cc881da62b696c9a66abb1bbde"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getComplexProperty</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> self) const</td></tr>
<tr class="separator:ab893f8cc881da62b696c9a66abb1bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd68c39bc8ac85924ba25e4a7cac7ff0"><td class="memItemLeft" align="right" valign="top"><a id="afd68c39bc8ac85924ba25e4a7cac7ff0"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHermitianProperty</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> self, const <a class="el" href="classcsl_1_1Space.html">Space</a> *space) const</td></tr>
<tr class="separator:afd68c39bc8ac85924ba25e4a7cac7ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4077314469ddf178e3ec02e524b940c3"><td class="memItemLeft" align="right" valign="top"><a id="a4077314469ddf178e3ec02e524b940c3"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTransposedProperty</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> self, const <a class="el" href="classcsl_1_1Space.html">Space</a> *space) const</td></tr>
<tr class="separator:a4077314469ddf178e3ec02e524b940c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4d924a14d8427a9618cec74f118a3c"><td class="memItemLeft" align="right" valign="top"><a id="a3b4d924a14d8427a9618cec74f118a3c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addComplexProperty</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;res)</td></tr>
<tr class="separator:a3b4d924a14d8427a9618cec74f118a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0660c6be6cd4215181fd1c423ee1219b"><td class="memItemLeft" align="right" valign="top"><a id="a0660c6be6cd4215181fd1c423ee1219b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addHermitianProperty</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *space, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;res)</td></tr>
<tr class="separator:a0660c6be6cd4215181fd1c423ee1219b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ce2c185af4de67ea998efcb48754d5"><td class="memItemLeft" align="right" valign="top"><a id="ad6ce2c185af4de67ea998efcb48754d5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addTransposedProperty</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *space, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;res)</td></tr>
<tr class="separator:ad6ce2c185af4de67ea998efcb48754d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aba499d752eefc81a70cf75938782ca"><td class="memItemLeft" align="right" valign="top"><a id="a4aba499d752eefc81a70cf75938782ca"></a>
virtual std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">Parent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBrokenParts</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *broken) const</td></tr>
<tr class="separator:a4aba499d752eefc81a70cf75938782ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac365d420a3bb44222a969163f0680870"><td class="memItemLeft" align="right" valign="top"><a id="ac365d420a3bb44222a969163f0680870"></a>
virtual std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">Parent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>breakSpace</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *broken, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;newSpace, const std::vector&lt; size_t &gt; &amp;pieces) const</td></tr>
<tr class="separator:ac365d420a3bb44222a969163f0680870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7f7e45ca51c0720c2234d22191d196"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a8a7f7e45ca51c0720c2234d22191d196">operator()</a> (<a class="el" href="classcsl_1_1Index.html">Index</a> index)</td></tr>
<tr class="memdesc:a8a7f7e45ca51c0720c2234d22191d196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the Element for an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> of dimension 1 (a single index).  <a href="#a8a7f7e45ca51c0720c2234d22191d196">More...</a><br /></td></tr>
<tr class="separator:a8a7f7e45ca51c0720c2234d22191d196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67817d2d364178d734343aa2aaa8c621"><td class="memItemLeft" align="right" valign="top"><a id="a67817d2d364178d734343aa2aaa8c621"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;point)</td></tr>
<tr class="separator:a67817d2d364178d734343aa2aaa8c621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9298445ca3a71e7af13ff61382c8c0f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#aa9298445ca3a71e7af13ff61382c8c0f">operator()</a> (std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; indices)</td></tr>
<tr class="memdesc:aa9298445ca3a71e7af13ff61382c8c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the Element for an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> of arbitrary dimension <a href="#aa9298445ca3a71e7af13ff61382c8c0f">More...</a><br /></td></tr>
<tr class="separator:aa9298445ca3a71e7af13ff61382c8c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef89e977355f65dd919fcb78647df89"><td class="memItemLeft" align="right" valign="top"><a id="a2ef89e977355f65dd919fcb78647df89"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:a2ef89e977355f65dd919fcb78647df89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64079f8317747669f1c8b4c1498d8dc"><td class="memItemLeft" align="right" valign="top"><a id="ad64079f8317747669f1c8b4c1498d8dc"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (<a class="el" href="classcsl_1_1Index.html">Index</a> index, const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;point)</td></tr>
<tr class="separator:ad64079f8317747669f1c8b4c1498d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4281c853db4878e925bc81440213dae0"><td class="memItemLeft" align="right" valign="top"><a id="a4281c853db4878e925bc81440213dae0"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; indices, const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;point)</td></tr>
<tr class="separator:a4281c853db4878e925bc81440213dae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba91946c679a4e6e116f0fc75fc52e1e"><td class="memItemLeft" align="right" valign="top"><a id="aba91946c679a4e6e116f0fc75fc52e1e"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const std::vector&lt; int &gt; &amp;indices, const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;point)</td></tr>
<tr class="separator:aba91946c679a4e6e116f0fc75fc52e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2ad6b4cd58d9b051a4d62f343bf48c2e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a2ad6b4cd58d9b051a4d62f343bf48c2e">name</a></td></tr>
<tr class="separator:a2ad6b4cd58d9b051a4d62f343bf48c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c857ebf734c15e7afd0d8a13988ac9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a98c857ebf734c15e7afd0d8a13988ac9">latexName</a></td></tr>
<tr class="separator:a98c857ebf734c15e7afd0d8a13988ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177e5244cc4d4b6c1e0600a4f77b523f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a177e5244cc4d4b6c1e0600a4f77b523f">commutable</a></td></tr>
<tr class="separator:a177e5244cc4d4b6c1e0600a4f77b523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab058ceee466fd0997c060e83fc0a4e96"><td class="memItemLeft" align="right" valign="top"><a id="ab058ceee466fd0997c060e83fc0a4e96"></a>
<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a>&#160;</td><td class="memItemRight" valign="bottom"><b>complexProp</b> = <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1">csl::ComplexProperty::Real</a></td></tr>
<tr class="separator:ab058ceee466fd0997c060e83fc0a4e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a97a1c1362de00ded312df2d10ff70"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcsl_1_1Equation.html">Equation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a77a97a1c1362de00ded312df2d10ff70">props</a></td></tr>
<tr class="separator:a77a97a1c1362de00ded312df2d10ff70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a276319c2a0786772350b93c84f9bcbd8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html#a276319c2a0786772350b93c84f9bcbd8">operator&lt;&lt;</a> (std::ostream &amp;fout, const <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> &amp;)</td></tr>
<tr class="memdesc:a276319c2a0786772350b93c84f9bcbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display name and commutability of the parent in standard output.  <a href="#a276319c2a0786772350b93c84f9bcbd8">More...</a><br /></td></tr>
<tr class="separator:a276319c2a0786772350b93c84f9bcbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all parents (indicial, fields etc). All parents derive from this class. </p>
<p>The principle of a parent is to contain properties of a variety of objects that share the same abstract concept, like indicial objects. Every specialization (Element) of a tensor for example, is an object with indices like <img class="formulaInl" alt="$ g_{\mu\nu} $" src="form_35.png"/>. But the Element can appear many times in different forms in an expression, we want its properties to appear only at one place in the program, and we want an object that can generate the Element. This is the <a class="el" href="classcsl_1_1Parent.html">Parent</a>. The parent then has three important features: <br />
 1. It is the only one to contain the properties of the object, if an element wants to access its own properties it has to ask its parent. <br />
 2. It is the only object able to generate properly an Element of its type. <br />
 2. It cannot appear in an expression (since it is not derived from <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>). And it is normal because in a expression we want a <img class="formulaInl" alt="$ g_{\mu\nu} $" src="form_35.png"/> with given <img class="formulaInl" alt="$ \mu $" src="form_36.png"/> and <img class="formulaInl" alt="$ \nu $" src="form_37.png"/>, not a simple <img class="formulaInl" alt="$ g $" src="form_38.png"/>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a961d277c9a277163931cb5b45906c83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961d277c9a277163931cb5b45906c83f">&#9670;&nbsp;</a></span>AbstractParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::AbstractParent::AbstractParent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>t_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intializes the name of the parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_name</td><td>Name of the parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5548d7f976f21a25d657fc723f7f7132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5548d7f976f21a25d657fc723f7f7132">&#9670;&nbsp;</a></span>addAntiSymmetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::addAntiSymmetry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an antisymmetry between indices in position <b>i1</b> and <b>i2</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> of the first index in the symmetry. </td></tr>
    <tr><td class="paramname">i2</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> of the second index in the symmetry. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#abdfaf46f9699cea8ac9cea9b7dcec388">csl::TensorParent</a>.</p>

</div>
</div>
<a id="a1d5ad2473de4d26c6c74a4cd6b0862fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5ad2473de4d26c6c74a4cd6b0862fe">&#9670;&nbsp;</a></span>addProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::addProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a property for the parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prop</td><td><a class="el" href="classcsl_1_1Equation.html">Equation</a> defining the new property. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3132e0cbebcf7e578da01c188ee75e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3132e0cbebcf7e578da01c188ee75e45">&#9670;&nbsp;</a></span>addSelfContraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::addSelfContraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::function&lt; bool(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt;&gt;&#160;</td>
          <td class="paramname"><em>condition</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a contraction property between an Element and another that share the parent (*this). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First Element in the contraction. </td></tr>
    <tr><td class="paramname">B</td><td>Second Element in the contraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>res The result of the contraction. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a258388f5044e36fa76825710e67ebada">csl::TensorParent</a>.</p>

</div>
</div>
<a id="ac691c3943a7bd3eb9c671927e2f91dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac691c3943a7bd3eb9c671927e2f91dc7">&#9670;&nbsp;</a></span>addSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::addSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Space.html">Space</a> *&#160;</td>
          <td class="paramname"><em>t_space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a dimension to an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> in a specific vector space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_space</td><td><a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> in which we add an index. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a17fb05141415ac442cb8f5b6e88bc329">csl::TensorParent</a>.</p>

</div>
</div>
<a id="a0a4a585286e48ff062c33e96ec09531b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4a585286e48ff062c33e96ec09531b">&#9670;&nbsp;</a></span>addSymmetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::addSymmetry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a symmetry between indices in position <b>i1</b> and <b>i2</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> of the first index in the symmetry. </td></tr>
    <tr><td class="paramname">i2</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> of the second index in the symmetry. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#ac9a495db8af3074a6c329d84a1b7cb91">csl::TensorParent</a>.</p>

</div>
</div>
<a id="a4df179280a63c410c84f7ea4edbcbee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df179280a63c410c84f7ea4edbcbee2">&#9670;&nbsp;</a></span>contraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::AbstractParent::contraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a contractoin property if there is one between <b>self</b> and <b>B</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A pointer to the element corresponding to the parent. </td></tr>
    <tr><td class="paramname">B</td><td>The other expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contracted object. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1MetricParent.html#a42674b8cb437b52c60adb3338718661d">csl::MetricParent</a>, <a class="el" href="classcsl_1_1DeltaParent.html#a4736cb2c3631a1a43bd3229fc246d79d">csl::DeltaParent</a>, <a class="el" href="classcsl_1_1EpsilonParent.html#af19206790efe47aa7529fef3e8b34a7f">csl::EpsilonParent</a>, and <a class="el" href="classcsl_1_1TensorParent.html#afdb6b8332cd4a18e3835099e0fab9f32">csl::TensorParent</a>.</p>

</div>
</div>
<a id="a74258391e7eae5a8cd0d629eabfe9ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74258391e7eae5a8cd0d629eabfe9ca9">&#9670;&nbsp;</a></span>dependsExplicitlyOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AbstractParent::dependsExplicitlyOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the parent depends explicitely on another expression or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>from which we test the dependency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the parent depends on<b>expr</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a14f4bcb3c19fb4e8cb8ccf3a61719f27">csl::TensorParent</a>.</p>

</div>
</div>
<a id="adf55413672b9d58875485edd1db4e563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf55413672b9d58875485edd1db4e563">&#9670;&nbsp;</a></span>dependsOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AbstractParent::dependsOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the parent depends on another expression or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>from which we test the dependency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the parent depends on<b>expr</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a7a0dbe923e3491cc35fa48c175baee43">csl::TensorParent</a>, and <a class="el" href="classcsl_1_1VariableParent.html#aa752d83ccf00b8277329367836af6488">csl::VariableParent</a>.</p>

</div>
</div>
<a id="af8ae5696856c551204addb95271333bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ae5696856c551204addb95271333bf">&#9670;&nbsp;</a></span>getCommutable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AbstractParent::getCommutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>commutable </dd></dl>

</div>
</div>
<a id="ac45297ef35dab1807a158056ec8dfac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45297ef35dab1807a158056ec8dfac3">&#9670;&nbsp;</a></span>getDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::AbstractParent::getDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The dimension of a parent, i.e. the number of indices. </dd></dl>

</div>
</div>
<a id="a6c81260a7b64e93b88dea1935b524505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c81260a7b64e93b88dea1935b524505">&#9670;&nbsp;</a></span>getDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::AbstractParent::getDim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Space.html">Space</a> *&#160;</td>
          <td class="paramname"><em>t_space</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimension of the parent relatively to a certain vector space, i.e. the number of indices in this vector space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_space</td><td><a class="el" href="classcsl_1_1Vector.html">Vector</a> space to investigate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dimansion in <b>t_space</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a5bff2bf79a3985d9020bee392f440990">csl::TensorParent</a>.</p>

</div>
</div>
<a id="ab04c96ff80ee2f0786e59a7eafd71175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04c96ff80ee2f0786e59a7eafd71175">&#9670;&nbsp;</a></span>getFullyAntiSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AbstractParent::getFullyAntiSymmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the parent is indicial and fully antisymmetric in its indices. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a4b974963fac5f42fe6f3ea5ca7ed93b6">csl::TensorParent</a>.</p>

</div>
</div>
<a id="af56df7eb3d90348eda50e3d6cc5cd8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56df7eb3d90348eda50e3d6cc5cd8b0">&#9670;&nbsp;</a></span>getFullySymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AbstractParent::getFullySymmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the parent is indicial and fully symmetric in its indices. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#aa4af33bfd789ef86dd5775b7a4558a01">csl::TensorParent</a>.</p>

</div>
</div>
<a id="ab22f321502a8aa481865be3e58bb241d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22f321502a8aa481865be3e58bb241d">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string const  &amp; csl::AbstractParent::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>name </dd></dl>

</div>
</div>
<a id="ad42c4b140d48c9319e0ae47436d040e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42c4b140d48c9319e0ae47436d040e1">&#9670;&nbsp;</a></span>getPermutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; csl::AbstractParent::getPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> returns all the possible permutations of the tensor with respect to the symmetries or antisymmetries in a vector of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;Permutation&gt; with all possible permutations of the tensor. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a57d5160b0d1a94e376bbbec3d5ab5735">csl::TensorParent</a>.</p>

</div>
</div>
<a id="a02948077d67665cbe33ba0f8febda859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02948077d67665cbe33ba0f8febda859">&#9670;&nbsp;</a></span>getPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecslParent.html#a83f078a60370b86ccd6b113eedff51c2">cslParent::PrimaryType</a> csl::AbstractParent::getPrimaryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The primary type of the parent. </dd></dl>

<p>Implemented in <a class="el" href="classcsl_1_1TensorParent.html#a9526dde46fc8cbe38a6cc9910441986f">csl::TensorParent</a>, <a class="el" href="classcsl_1_1TensorFieldParent.html#adf100615e12fa1f81d826f0f810e776b">csl::TensorFieldParent</a>, <a class="el" href="classcsl_1_1LiteralParent.html#aa4f13d4a38f4e1eb268b4a391d5e0d73">csl::LiteralParent</a>, and <a class="el" href="classcsl_1_1FieldParent.html#a27fbc1c0782e924f04c414fbfde5bd59">csl::FieldParent</a>.</p>

</div>
</div>
<a id="a9f226bf0ae04cbeba39bdd7e4265c6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f226bf0ae04cbeba39bdd7e4265c6b1">&#9670;&nbsp;</a></span>getProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classcsl_1_1Equation.html">Equation</a> * &gt; &amp; csl::AbstractParent::getProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>props. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a5d1bf2aa72f17e7566d72a3a9e425746">csl::TensorParent</a>.</p>

</div>
</div>
<a id="adcc94486a83de9c73de39f78b1eafea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc94486a83de9c73de39f78b1eafea4">&#9670;&nbsp;</a></span>getTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::AbstractParent::getTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a valued <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> returns the corresponding tensor. Valued means that the tensor has been defined by the user. </p>
<dl class="section return"><dt>Returns</dt><dd>tensor. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a889012a413646fa644b39c24366673f1">csl::TensorParent</a>.</p>

</div>
</div>
<a id="a6a9115038be74e35dbcd8ecdbba7e5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9115038be74e35dbcd8ecdbba7e5a1">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecslParent.html#a880f05263e57bd6cac32e48fd45b7339">cslParent::Type</a> csl::AbstractParent::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type of the parent. </dd></dl>

<p>Implemented in <a class="el" href="classcsl_1_1MetricParent.html#a2194d37ed574daf54deba112e482637d">csl::MetricParent</a>, <a class="el" href="classcsl_1_1DeltaParent.html#a5f0c9c1d6c0fd4a25cc2e21a0681efa7">csl::DeltaParent</a>, <a class="el" href="classcsl_1_1EpsilonParent.html#a24dcb0f019f939c6e7a04c7dd1285b06">csl::EpsilonParent</a>, <a class="el" href="classcsl_1_1TensorParent.html#aa5d0d77665f81cd08e1a053f434daef1">csl::TensorParent</a>, <a class="el" href="classcsl_1_1VariableParent.html#aba33fb8ddc1cc378ac6178c6aaee6e7a">csl::VariableParent</a>, <a class="el" href="classcsl_1_1ConstantParent.html#a763c63b7aba66dc122600c0649a75c9a">csl::ConstantParent</a>, <a class="el" href="classcsl_1_1ScalarFieldParent.html#a816cef0bafb81818fe55069db3b1c887">csl::ScalarFieldParent</a>, and <a class="el" href="classcsl_1_1TensorFieldParent.html#aa21a699e14c7790719ad4ef846f3f584">csl::TensorFieldParent</a>.</p>

</div>
</div>
<a id="a7f680e00248dd59a1545488ec4b43c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f680e00248dd59a1545488ec4b43c07">&#9670;&nbsp;</a></span>hasContractionProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AbstractParent::hasContractionProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> has contraction properties with another expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A pointer to the element corresponding to the parent. </td></tr>
    <tr><td class="paramname">B</td><td>The other expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if there is one particular contraction property. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1MetricParent.html#af91920eba4f5346a39a13e393f806526">csl::MetricParent</a>, <a class="el" href="classcsl_1_1DeltaParent.html#a8e820c17bda11df8e98eed50e013401a">csl::DeltaParent</a>, <a class="el" href="classcsl_1_1EpsilonParent.html#a6137c073fe9806ab8d0dc8606aec98ad">csl::EpsilonParent</a>, and <a class="el" href="classcsl_1_1TensorParent.html#aee4452e0bd10be255d394ed3463780a3">csl::TensorParent</a>.</p>

</div>
</div>
<a id="a8a7f7e45ca51c0720c2234d22191d196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7f7e45ca51c0720c2234d22191d196">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::AbstractParent::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Index.html">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the Element for an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> of dimension 1 (a single index). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> of the Element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a335867b85b438d48eaf0457cb5c83469">csl::TensorParent</a>.</p>

</div>
</div>
<a id="aa9298445ca3a71e7af13ff61382c8c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9298445ca3a71e7af13ff61382c8c0f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::AbstractParent::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the Element for an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> of arbitrary dimension</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>List of indices to generate the <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1MetricParent.html#a1c137eb96960fbff8eb9aa9792149bd2">csl::MetricParent</a>, <a class="el" href="classcsl_1_1DeltaParent.html#aa0b6e8538707f3621caaadc29d2145c7">csl::DeltaParent</a>, <a class="el" href="classcsl_1_1EpsilonParent.html#a69dcb179ab67784a6520b95d196747b8">csl::EpsilonParent</a>, and <a class="el" href="classcsl_1_1TensorParent.html#a3cbe8233fd122bd6f4f3b778baa47df4">csl::TensorParent</a>.</p>

</div>
</div>
<a id="ab05b94537305d4938b2e20364fa40b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05b94537305d4938b2e20364fa40b43">&#9670;&nbsp;</a></span>removeProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::removeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prop</td><td>Property to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae1bc83d1df8237e6bf50b6b8f732716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1bc83d1df8237e6bf50b6b8f732716">&#9670;&nbsp;</a></span>setCommutable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::setCommutable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t_commutable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_commutable</td><td>New commutability property of the parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13e6f74e590cbf05dcafb4d9c3df8b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e6f74e590cbf05dcafb4d9c3df8b9c">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::setName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>t_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_name</td><td>New name of the parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79ad3927cad378f4e83055533ea20d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ad3927cad378f4e83055533ea20d46">&#9670;&nbsp;</a></span>setSymmetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::setSymmetry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Symmetry.html">Symmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>t_symmetry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the symmetry properties of an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> from an object of type <a class="el" href="classcsl_1_1Symmetry.html" title="Handles the full symmetry properties of an TensorElement, i.e. a vector of Permutation objects...">Symmetry</a>. This erase all possible properties of (anti)symmetry the parent had before that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_symmetry</td><td>New symmetry of the parent. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#aa61f52e3ea9ae4beb190442ac0e7aacc">csl::TensorParent</a>.</p>

</div>
</div>
<a id="a5dd9dd3730422db222a395139786ea4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd9dd3730422db222a395139786ea4b">&#9670;&nbsp;</a></span>setTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::AbstractParent::setTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>t_tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">New</td><td>tensor corresponding to the <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a>. Must match the index structure of course. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorParent.html#a4eacd947decb14e003f81a8053d94e11">csl::TensorParent</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a276319c2a0786772350b93c84f9bcbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276319c2a0786772350b93c84f9bcbd8">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Display name and commutability of the parent in standard output. </p>
<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; fout , const <a class="el" href="classcsl_1_1AbstractParent.html" title="Base class for all parents (indicial, fields etc). All parents derive from this class. ">AbstractParent</a>&amp; p) </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a177e5244cc4d4b6c1e0600a4f77b523f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177e5244cc4d4b6c1e0600a4f77b523f">&#9670;&nbsp;</a></span>commutable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AbstractParent::commutable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Commutability property of the parent (will be given to the elements when created). </p>

</div>
</div>
<a id="a98c857ebf734c15e7afd0d8a13988ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c857ebf734c15e7afd0d8a13988ac9">&#9670;&nbsp;</a></span>latexName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string csl::AbstractParent::latexName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Latex name of the parent. </p>

</div>
</div>
<a id="a2ad6b4cd58d9b051a4d62f343bf48c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad6b4cd58d9b051a4d62f343bf48c2e">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string csl::AbstractParent::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Name of the parent (will be given to the elements when created). </p>

</div>
</div>
<a id="a77a97a1c1362de00ded312df2d10ff70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a97a1c1362de00ded312df2d10ff70">&#9670;&nbsp;</a></span>props</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcsl_1_1Equation.html">Equation</a>*&gt; csl::AbstractParent::props</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Properties of the parent in a form of a list (std::vector) of equations. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="parent_8h_source.html">parent.h</a></li>
<li>src/parent.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
