<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSL: csl::Sum Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image.png" href="../../../logo-marty.png"/>
<link href="style_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
      <a href="https://marty.in2p3.fr"><img alt="Logo" src="Logo1.svg" height=100px/></a></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">
       Documentation of <i><b>CSL</b></i>
   </div>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecsl.html">csl</a></li><li class="navelem"><a class="el" href="classcsl_1_1Sum.html">Sum</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">csl::Sum Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handles a sum, function of multiple arguments.  
 <a href="classcsl_1_1Sum.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="operations_8h_source.html">operations.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for csl::Sum:</div>
<div class="dyncontent">
<div class="center"><img src="classcsl_1_1Sum__inherit__graph.png" border="0" usemap="#csl_1_1Sum_inherit__map" alt="Inheritance graph"/></div>
<map name="csl_1_1Sum_inherit__map" id="csl_1_1Sum_inherit__map">
<area shape="rect" id="node4" href="classcsl_1_1ISum.html" title="Specialization of a Prod object to handle TensorElement objects in the product (apply contraction of ..." alt="" coords="43,229,121,256"/>
<area shape="rect" id="node2" href="classcsl_1_1AbstractMultiFunc.html" title="Handle functions of multiple arguments. In the case of the call of a simplification function..." alt="" coords="5,80,159,107"/>
<area shape="rect" id="node3" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. " alt="" coords="34,5,130,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a171ac02d7a8afe0d1242c6307a03acff"><td class="memItemLeft" align="right" valign="top"><a id="a171ac02d7a8afe0d1242c6307a03acff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a171ac02d7a8afe0d1242c6307a03acff">Sum</a> ()</td></tr>
<tr class="memdesc:a171ac02d7a8afe0d1242c6307a03acff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Initializes <b>argument</b> to an empty std::vector. <br /></td></tr>
<tr class="separator:a171ac02d7a8afe0d1242c6307a03acff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b45ce85f4650c5ca71675fe5231efae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a8b45ce85f4650c5ca71675fe5231efae">Sum</a> (const csl::vector_expr &amp;operands, bool explicitSum=false)</td></tr>
<tr class="memdesc:a8b45ce85f4650c5ca71675fe5231efae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <b>argument</b> to <em>operands</em> (copy each element)  <a href="#a8b45ce85f4650c5ca71675fe5231efae">More...</a><br /></td></tr>
<tr class="separator:a8b45ce85f4650c5ca71675fe5231efae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954e6e01884fce66529f78ee92a21c9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a954e6e01884fce66529f78ee92a21c9c">Sum</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand, bool explicitSum=false)</td></tr>
<tr class="memdesc:a954e6e01884fce66529f78ee92a21c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the sum of &amp; leftOperand and <em>rightOperand</em>.  <a href="#a954e6e01884fce66529f78ee92a21c9c">More...</a><br /></td></tr>
<tr class="separator:a954e6e01884fce66529f78ee92a21c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde4c81bf81217accd1b02b8e2b4dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#afdde4c81bf81217accd1b02b8e2b4dbf">getType</a> () const override</td></tr>
<tr class="memdesc:afdde4c81bf81217accd1b02b8e2b4dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>type</b> of a <a class="el" href="classcsl_1_1Sum.html" title="Handles a sum, function of multiple arguments. ">Sum</a> object.  <a href="#afdde4c81bf81217accd1b02b8e2b4dbf">More...</a><br /></td></tr>
<tr class="separator:afdde4c81bf81217accd1b02b8e2b4dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ce7a5183d105402cdafab290b93c91"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#ad9ce7a5183d105402cdafab290b93c91">isIndexed</a> () const override</td></tr>
<tr class="separator:ad9ce7a5183d105402cdafab290b93c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a42358fbbca3043d216049222455d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#ae5a42358fbbca3043d216049222455d6">getNumericalFactor</a> () const override</td></tr>
<tr class="separator:ae5a42358fbbca3043d216049222455d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f4bd8e0a54da800a0a1a67608fb080"><td class="memItemLeft" align="right" valign="top"><a id="a90f4bd8e0a54da800a0a1a67608fb080"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getOrderOf</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="separator:a90f4bd8e0a54da800a0a1a67608fb080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa265b9928bffd0aefe456d9dbe3637b8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#aa265b9928bffd0aefe456d9dbe3637b8">getTerm</a> () const override</td></tr>
<tr class="separator:aa265b9928bffd0aefe456d9dbe3637b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e21f4faf128cc9d9e471370def40e7"><td class="memItemLeft" align="right" valign="top">csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#ab2e21f4faf128cc9d9e471370def40e7">getFactors</a> () const override</td></tr>
<tr class="memdesc:ab2e21f4faf128cc9d9e471370def40e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the possible factors.  <a href="#ab2e21f4faf128cc9d9e471370def40e7">More...</a><br /></td></tr>
<tr class="separator:ab2e21f4faf128cc9d9e471370def40e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340d0daf8560d7d9ec73a30a0e5b4fce"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a340d0daf8560d7d9ec73a30a0e5b4fce">getRealPart</a> () const override</td></tr>
<tr class="memdesc:a340d0daf8560d7d9ec73a30a0e5b4fce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a340d0daf8560d7d9ec73a30a0e5b4fce">More...</a><br /></td></tr>
<tr class="separator:a340d0daf8560d7d9ec73a30a0e5b4fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c2be7f869326606fba475ea557b409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a91c2be7f869326606fba475ea557b409">getImaginaryPart</a> () const override</td></tr>
<tr class="memdesc:a91c2be7f869326606fba475ea557b409"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a91c2be7f869326606fba475ea557b409">More...</a><br /></td></tr>
<tr class="separator:a91c2be7f869326606fba475ea557b409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a358933e479aa4dcb68c9fff7a4dcc3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a6a358933e479aa4dcb68c9fff7a4dcc3">getComplexModulus</a> () const override</td></tr>
<tr class="memdesc:a6a358933e479aa4dcb68c9fff7a4dcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a6a358933e479aa4dcb68c9fff7a4dcc3">More...</a><br /></td></tr>
<tr class="separator:a6a358933e479aa4dcb68c9fff7a4dcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1cd9a04f2299205aa8d896ba03482b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#adc1cd9a04f2299205aa8d896ba03482b">getComplexArgument</a> () const override</td></tr>
<tr class="memdesc:adc1cd9a04f2299205aa8d896ba03482b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#adc1cd9a04f2299205aa8d896ba03482b">More...</a><br /></td></tr>
<tr class="separator:adc1cd9a04f2299205aa8d896ba03482b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8967f1bfbae1e49e21bd5f79939b2a63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a8967f1bfbae1e49e21bd5f79939b2a63">insert</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, bool explicitSum=false) override</td></tr>
<tr class="memdesc:a8967f1bfbae1e49e21bd5f79939b2a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an expression in a sum or a product.  <a href="#a8967f1bfbae1e49e21bd5f79939b2a63">More...</a><br /></td></tr>
<tr class="separator:a8967f1bfbae1e49e21bd5f79939b2a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed27fa96664bb2d126e41b866e04a5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a1ed27fa96664bb2d126e41b866e04a5b">print</a> (int mode=0, std::ostream &amp;out=std::cout, bool lib=false) const override</td></tr>
<tr class="memdesc:a1ed27fa96664bb2d126e41b866e04a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the abstract in standard output.  <a href="#a1ed27fa96664bb2d126e41b866e04a5b">More...</a><br /></td></tr>
<tr class="separator:a1ed27fa96664bb2d126e41b866e04a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c53e2ba4c315375c4836b1794fbec3"><td class="memItemLeft" align="right" valign="top"><a id="aa6c53e2ba4c315375c4836b1794fbec3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printCode</b> (int mode=0, std::ostream &amp;out=std::cout) const override</td></tr>
<tr class="separator:aa6c53e2ba4c315375c4836b1794fbec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d6f1d250495606344f29e78ba47ee0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a98d6f1d250495606344f29e78ba47ee0">printLaTeX</a> (int mode=0) const override</td></tr>
<tr class="memdesc:a98d6f1d250495606344f29e78ba47ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a LaTeX output for the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a98d6f1d250495606344f29e78ba47ee0">More...</a><br /></td></tr>
<tr class="separator:a98d6f1d250495606344f29e78ba47ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f5632f8b3be2615f29085195c7abe2"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#aa8f5632f8b3be2615f29085195c7abe2">evaluateScalar</a> () const override</td></tr>
<tr class="memdesc:aa8f5632f8b3be2615f29085195c7abe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <b>sum</b> of all the arguments.  <a href="#aa8f5632f8b3be2615f29085195c7abe2">More...</a><br /></td></tr>
<tr class="separator:aa8f5632f8b3be2615f29085195c7abe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c54e000687a23ad678c77760ffaaf1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#af3c54e000687a23ad678c77760ffaaf1">evaluate</a> (csl::eval::mode user_mode=csl::eval::base) const override</td></tr>
<tr class="memdesc:af3c54e000687a23ad678c77760ffaaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#af3c54e000687a23ad678c77760ffaaf1">More...</a><br /></td></tr>
<tr class="separator:af3c54e000687a23ad678c77760ffaaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58bfbee5ab0c201025df4c519220fa7"><td class="memItemLeft" align="right" valign="top"><a id="ab58bfbee5ab0c201025df4c519220fa7"></a>
unique_Expr&#160;</td><td class="memItemRight" valign="bottom"><b>copy_unique</b> () const override</td></tr>
<tr class="separator:ab58bfbee5ab0c201025df4c519220fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af845c0183f86a68d848358e8e0cedf9a"><td class="memItemLeft" align="right" valign="top"><a id="af845c0183f86a68d848358e8e0cedf9a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deepCopy</b> () const override</td></tr>
<tr class="separator:af845c0183f86a68d848358e8e0cedf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51d6c285b472a82f58891277d55b7a0"><td class="memItemLeft" align="right" valign="top"><a id="ac51d6c285b472a82f58891277d55b7a0"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>refresh</b> () const override</td></tr>
<tr class="separator:ac51d6c285b472a82f58891277d55b7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad293e6cc7616876a4f66f11ec8d7cee4"><td class="memItemLeft" align="right" valign="top"><a id="ad293e6cc7616876a4f66f11ec8d7cee4"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deepRefresh</b> () const override</td></tr>
<tr class="separator:ad293e6cc7616876a4f66f11ec8d7cee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab057bcec5aad014c3ac4d1ab847c9ada"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#ab057bcec5aad014c3ac4d1ab847c9ada">mergeTerms</a> ()</td></tr>
<tr class="memdesc:ab057bcec5aad014c3ac4d1ab847c9ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge identical terms.  <a href="#ab057bcec5aad014c3ac4d1ab847c9ada">More...</a><br /></td></tr>
<tr class="separator:ab057bcec5aad014c3ac4d1ab847c9ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd65455cce7f09a916f5d3b0725c22b"><td class="memItemLeft" align="right" valign="top"><a id="aebd65455cce7f09a916f5d3b0725c22b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>orderTerms</b> ()</td></tr>
<tr class="separator:aebd65455cce7f09a916f5d3b0725c22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd23134290bcfeffb529e2c03ca17ff"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a7dd23134290bcfeffb529e2c03ca17ff">derive</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:a7dd23134290bcfeffb529e2c03ca17ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derives the sum.  <a href="#a7dd23134290bcfeffb529e2c03ca17ff">More...</a><br /></td></tr>
<tr class="separator:a7dd23134290bcfeffb529e2c03ca17ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56a4a850dcb91db747ff8ca36f458a2"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#af56a4a850dcb91db747ff8ca36f458a2">factor</a> (bool full=false) const override</td></tr>
<tr class="memdesc:af56a4a850dcb91db747ff8ca36f458a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factors the expr if common factors are found.  <a href="#af56a4a850dcb91db747ff8ca36f458a2">More...</a><br /></td></tr>
<tr class="separator:af56a4a850dcb91db747ff8ca36f458a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb31f0009bdb90913b98c693578b54a3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#aeb31f0009bdb90913b98c693578b54a3">factor</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool full=false) const override</td></tr>
<tr class="memdesc:aeb31f0009bdb90913b98c693578b54a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factors the expr by expr if it is a common factor.  <a href="#aeb31f0009bdb90913b98c693578b54a3">More...</a><br /></td></tr>
<tr class="separator:aeb31f0009bdb90913b98c693578b54a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f3a6d6201fef00ca9d4ad334cd01bd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#af1f3a6d6201fef00ca9d4ad334cd01bd">collect</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors, bool full) const override</td></tr>
<tr class="memdesc:af1f3a6d6201fef00ca9d4ad334cd01bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects terms in sum according to some factors given by the user.  <a href="#af1f3a6d6201fef00ca9d4ad334cd01bd">More...</a><br /></td></tr>
<tr class="separator:af1f3a6d6201fef00ca9d4ad334cd01bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1620a408e74aa2b452a176f006fb3e5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a1620a408e74aa2b452a176f006fb3e5c">askTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> term, bool exact=false) const override</td></tr>
<tr class="memdesc:a1620a408e74aa2b452a176f006fb3e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <b>expr</b> can factor <b>*this</b>.  <a href="#a1620a408e74aa2b452a176f006fb3e5c">More...</a><br /></td></tr>
<tr class="separator:a1620a408e74aa2b452a176f006fb3e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d045772a3fbedf76bf72588ee2e212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#a37d045772a3fbedf76bf72588ee2e212">suppressTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> term) const override</td></tr>
<tr class="memdesc:a37d045772a3fbedf76bf72588ee2e212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a factor from an expr, that must have been determined before.  <a href="#a37d045772a3fbedf76bf72588ee2e212">More...</a><br /></td></tr>
<tr class="separator:a37d045772a3fbedf76bf72588ee2e212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3105d37243fd781e0b2da2de60c295"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#abd3105d37243fd781e0b2da2de60c295">getParity</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> t_variable) const override</td></tr>
<tr class="memdesc:abd3105d37243fd781e0b2da2de60c295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parity property of the expression with respect to <b>t_variable</b>.  <a href="#abd3105d37243fd781e0b2da2de60c295">More...</a><br /></td></tr>
<tr class="separator:abd3105d37243fd781e0b2da2de60c295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8309f4d05302f47272a5e2ba0e6507c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#ae8309f4d05302f47272a5e2ba0e6507c">operator==</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:ae8309f4d05302f47272a5e2ba0e6507c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="#ae8309f4d05302f47272a5e2ba0e6507c">More...</a><br /></td></tr>
<tr class="separator:ae8309f4d05302f47272a5e2ba0e6507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc92cb4e44f443feb122841ff960f5e"><td class="memItemLeft" align="right" valign="top">csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html#adcc92cb4e44f443feb122841ff960f5e">getAlternateForms</a> () const override</td></tr>
<tr class="memdesc:adcc92cb4e44f443feb122841ff960f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x).  <a href="#adcc92cb4e44f443feb122841ff960f5e">More...</a><br /></td></tr>
<tr class="separator:adcc92cb4e44f443feb122841ff960f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59eb94a3f20c4e20528f5e275d54b228"><td class="memItemLeft" align="right" valign="top"><a id="a59eb94a3f20c4e20528f5e275d54b228"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *expr) const override</td></tr>
<tr class="separator:a59eb94a3f20c4e20528f5e275d54b228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcsl_1_1AbstractMultiFunc"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcsl_1_1AbstractMultiFunc')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcsl_1_1AbstractMultiFunc.html">csl::AbstractMultiFunc</a></td></tr>
<tr class="memitem:ad7c6d28772b2684c20a42bbfcb8cf257 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="ad7c6d28772b2684c20a42bbfcb8cf257"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#ad7c6d28772b2684c20a42bbfcb8cf257">AbstractMultiFunc</a> ()</td></tr>
<tr class="memdesc:ad7c6d28772b2684c20a42bbfcb8cf257 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor, initializes the std::vector argument empty. <br /></td></tr>
<tr class="separator:ad7c6d28772b2684c20a42bbfcb8cf257 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d642a8a42845ad66da5faa78cb3c27 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a77d642a8a42845ad66da5faa78cb3c27">getType</a> () const override</td></tr>
<tr class="memdesc:a77d642a8a42845ad66da5faa78cb3c27 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classcsl_1_1AbstractMultiFunc.html#a77d642a8a42845ad66da5faa78cb3c27">More...</a><br /></td></tr>
<tr class="separator:a77d642a8a42845ad66da5faa78cb3c27 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6044133a95c411324d20afe460c55b inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a1b6044133a95c411324d20afe460c55b">getPrimaryType</a> () const override</td></tr>
<tr class="memdesc:a1b6044133a95c411324d20afe460c55b inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>primary type</b> of an <a class="el" href="classcsl_1_1AbstractMultiFunc.html" title="Handle functions of multiple arguments. In the case of the call of a simplification function...">AbstractMultiFunc</a>.  <a href="classcsl_1_1AbstractMultiFunc.html#a1b6044133a95c411324d20afe460c55b">More...</a><br /></td></tr>
<tr class="separator:a1b6044133a95c411324d20afe460c55b inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc449bd37728479b8c6b0a9eea3bccf inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a2bc449bd37728479b8c6b0a9eea3bccf">getCommutable</a> () const override</td></tr>
<tr class="memdesc:a2bc449bd37728479b8c6b0a9eea3bccf inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the <a class="el" href="classcsl_1_1AbstractMultiFunc.html" title="Handle functions of multiple arguments. In the case of the call of a simplification function...">AbstractMultiFunc</a> is commutable.  <a href="classcsl_1_1AbstractMultiFunc.html#a2bc449bd37728479b8c6b0a9eea3bccf">More...</a><br /></td></tr>
<tr class="separator:a2bc449bd37728479b8c6b0a9eea3bccf inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fc70d8f2b9e7df0dfff973a754432a inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="af5fc70d8f2b9e7df0dfff973a754432a"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSubSymbols</b> () const override</td></tr>
<tr class="separator:af5fc70d8f2b9e7df0dfff973a754432a inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12bbdfb8a1b45d722d37f2444443457 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#af12bbdfb8a1b45d722d37f2444443457">getNArgs</a> (int axis=0) const override</td></tr>
<tr class="memdesc:af12bbdfb8a1b45d722d37f2444443457 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <b>number of arguments</b> of the <a class="el" href="classcsl_1_1AbstractMultiFunc.html" title="Handle functions of multiple arguments. In the case of the call of a simplification function...">AbstractMultiFunc</a>.  <a href="classcsl_1_1AbstractMultiFunc.html#af12bbdfb8a1b45d722d37f2444443457">More...</a><br /></td></tr>
<tr class="separator:af12bbdfb8a1b45d722d37f2444443457 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e910beb3bdf8459306fe0cda78c1c76 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">const csl::vector_expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a5e910beb3bdf8459306fe0cda78c1c76">getVectorArgument</a> () const override</td></tr>
<tr class="memdesc:a5e910beb3bdf8459306fe0cda78c1c76 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the std::vector <b>argument</b> directly.  <a href="classcsl_1_1AbstractMultiFunc.html#a5e910beb3bdf8459306fe0cda78c1c76">More...</a><br /></td></tr>
<tr class="separator:a5e910beb3bdf8459306fe0cda78c1c76 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ae783c1bd8e55ccc005af538599def inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a75ae783c1bd8e55ccc005af538599def">getArgument</a> (int iArg=0) const override</td></tr>
<tr class="memdesc:a75ae783c1bd8e55ccc005af538599def inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one particular <b>argument</b>.  <a href="classcsl_1_1AbstractMultiFunc.html#a75ae783c1bd8e55ccc005af538599def">More...</a><br /></td></tr>
<tr class="separator:a75ae783c1bd8e55ccc005af538599def inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af168c84e071262cc48108cf991526651 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="af168c84e071262cc48108cf991526651"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getArgument</b> (int iArg=0) override</td></tr>
<tr class="separator:af168c84e071262cc48108cf991526651 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb17ac601dd6fb6c98a6de6983d41009 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#acb17ac601dd6fb6c98a6de6983d41009">findSubExpression</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> subExpression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;newExpression) const override</td></tr>
<tr class="memdesc:acb17ac601dd6fb6c98a6de6983d41009 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sub-expression and replaces it.  <a href="classcsl_1_1AbstractMultiFunc.html#acb17ac601dd6fb6c98a6de6983d41009">More...</a><br /></td></tr>
<tr class="separator:acb17ac601dd6fb6c98a6de6983d41009 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773f619ff0c678e3d1e8e34559a00d50 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="a773f619ff0c678e3d1e8e34559a00d50"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const override</td></tr>
<tr class="separator:a773f619ff0c678e3d1e8e34559a00d50 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1ce81d61672e15a142fe8d3bee98bd inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="ada1ce81d61672e15a142fe8d3bee98bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const override</td></tr>
<tr class="separator:ada1ce81d61672e15a142fe8d3bee98bd inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6236c27a797993973fb45dc9f4906962 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">csl::vector_expr::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a6236c27a797993973fb45dc9f4906962">begin</a> () override</td></tr>
<tr class="separator:a6236c27a797993973fb45dc9f4906962 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178ccaec7d4546873084591d93398153 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">csl::vector_expr::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a178ccaec7d4546873084591d93398153">end</a> () override</td></tr>
<tr class="separator:a178ccaec7d4546873084591d93398153 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa405a3e5cd03bb390ce3e804fe8af806 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">csl::vector_expr::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#aa405a3e5cd03bb390ce3e804fe8af806">begin</a> () const override</td></tr>
<tr class="separator:aa405a3e5cd03bb390ce3e804fe8af806 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f8f99108068dca2bd7a259577a0bcf inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">csl::vector_expr::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a42f8f99108068dca2bd7a259577a0bcf">end</a> () const override</td></tr>
<tr class="separator:a42f8f99108068dca2bd7a259577a0bcf inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf9bbbcd0b0b3f75121f1c0a5cf4d57 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a6cf9bbbcd0b0b3f75121f1c0a5cf4d57">setArgument</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;t_argument, int iArg=0) override</td></tr>
<tr class="memdesc:a6cf9bbbcd0b0b3f75121f1c0a5cf4d57 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces one particular <b>argument</b>.  <a href="classcsl_1_1AbstractMultiFunc.html#a6cf9bbbcd0b0b3f75121f1c0a5cf4d57">More...</a><br /></td></tr>
<tr class="separator:a6cf9bbbcd0b0b3f75121f1c0a5cf4d57 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6df749f2e0afdbe8ae0993235dda54 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a8e6df749f2e0afdbe8ae0993235dda54">setVectorArgument</a> (const csl::vector_expr &amp;t_argument) override</td></tr>
<tr class="memdesc:a8e6df749f2e0afdbe8ae0993235dda54 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaced the entire std::vector of argument.  <a href="classcsl_1_1AbstractMultiFunc.html#a8e6df749f2e0afdbe8ae0993235dda54">More...</a><br /></td></tr>
<tr class="separator:a8e6df749f2e0afdbe8ae0993235dda54 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae240dfbf5dec5abdcd3006e69b40563c inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="ae240dfbf5dec5abdcd3006e69b40563c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReal</b> () const override</td></tr>
<tr class="separator:ae240dfbf5dec5abdcd3006e69b40563c inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba1daf07d310140f4c417e23d37e6eb inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="a7ba1daf07d310140f4c417e23d37e6eb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPurelyImaginary</b> () const override</td></tr>
<tr class="separator:a7ba1daf07d310140f4c417e23d37e6eb inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740c75c01e1d8aeb7db075fc5377789 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a4740c75c01e1d8aeb7db075fc5377789">getRealPart</a> () const override</td></tr>
<tr class="memdesc:a4740c75c01e1d8aeb7db075fc5377789 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classcsl_1_1AbstractMultiFunc.html#a4740c75c01e1d8aeb7db075fc5377789">More...</a><br /></td></tr>
<tr class="separator:a4740c75c01e1d8aeb7db075fc5377789 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232e9782e303c525a18f436e5e5f97b9 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a232e9782e303c525a18f436e5e5f97b9">getImaginaryPart</a> () const override</td></tr>
<tr class="memdesc:a232e9782e303c525a18f436e5e5f97b9 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classcsl_1_1AbstractMultiFunc.html#a232e9782e303c525a18f436e5e5f97b9">More...</a><br /></td></tr>
<tr class="separator:a232e9782e303c525a18f436e5e5f97b9 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bea898b7169caabc409badff44c710 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#ac1bea898b7169caabc409badff44c710">getComplexModulus</a> () const override</td></tr>
<tr class="memdesc:ac1bea898b7169caabc409badff44c710 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classcsl_1_1AbstractMultiFunc.html#ac1bea898b7169caabc409badff44c710">More...</a><br /></td></tr>
<tr class="separator:ac1bea898b7169caabc409badff44c710 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c3300eb0f87234002c476d3c7c9a14 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a46c3300eb0f87234002c476d3c7c9a14">getComplexArgument</a> () const override</td></tr>
<tr class="memdesc:a46c3300eb0f87234002c476d3c7c9a14 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classcsl_1_1AbstractMultiFunc.html#a46c3300eb0f87234002c476d3c7c9a14">More...</a><br /></td></tr>
<tr class="separator:a46c3300eb0f87234002c476d3c7c9a14 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd84cb1aa54ef9875bae6f806ed1d753 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#abd84cb1aa54ef9875bae6f806ed1d753">getComplexConjugate</a> () const override</td></tr>
<tr class="memdesc:abd84cb1aa54ef9875bae6f806ed1d753 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the complex conjugate of the expression.  <a href="classcsl_1_1AbstractMultiFunc.html#abd84cb1aa54ef9875bae6f806ed1d753">More...</a><br /></td></tr>
<tr class="separator:abd84cb1aa54ef9875bae6f806ed1d753 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636313fd58465a56d3b41cb74f9ffaff inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a636313fd58465a56d3b41cb74f9ffaff">replaceIndex</a> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;indexToReplace, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;newIndex, bool refresh=true) const override</td></tr>
<tr class="memdesc:a636313fd58465a56d3b41cb74f9ffaff inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For indicial expressions, this function searches <b>indexToContract</b> and replaces it with newIndex.  <a href="classcsl_1_1AbstractMultiFunc.html#a636313fd58465a56d3b41cb74f9ffaff">More...</a><br /></td></tr>
<tr class="separator:a636313fd58465a56d3b41cb74f9ffaff inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db6d93888f6b8bb5719549e522a4afa inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="a3db6d93888f6b8bb5719549e522a4afa"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>replaceIndices</b> (std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; const &amp;oldIndices, std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; const &amp;newIndices, bool refresh=true, bool flipped=false) const override</td></tr>
<tr class="separator:a3db6d93888f6b8bb5719549e522a4afa inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82b52395acc9570f21ecca507dde7e2 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="aa82b52395acc9570f21ecca507dde7e2"></a>
<a class="el" href="classcsl_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPoint</b> () const override</td></tr>
<tr class="separator:aa82b52395acc9570f21ecca507dde7e2 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b240760c1c7d930053fbd38c812196 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#aa7b240760c1c7d930053fbd38c812196">expand</a> (bool full=false, bool inPlace=false) const override</td></tr>
<tr class="memdesc:aa7b240760c1c7d930053fbd38c812196 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Develops</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classcsl_1_1AbstractMultiFunc.html#aa7b240760c1c7d930053fbd38c812196">More...</a><br /></td></tr>
<tr class="separator:aa7b240760c1c7d930053fbd38c812196 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09641d4d997d869626ff660ca4d3f8b inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#af09641d4d997d869626ff660ca4d3f8b">expand_if</a> (std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, bool full=false, bool inPlace=false) const override</td></tr>
<tr class="memdesc:af09641d4d997d869626ff660ca4d3f8b inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Develops</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classcsl_1_1AbstractMultiFunc.html#af09641d4d997d869626ff660ca4d3f8b">More...</a><br /></td></tr>
<tr class="separator:af09641d4d997d869626ff660ca4d3f8b inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d64fefa1c3718d1fe431edfa4934e71 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a9d64fefa1c3718d1fe431edfa4934e71">dependsOn</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:a9d64fefa1c3718d1fe431edfa4934e71 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if the expression depends on <b>expr</b>.  <a href="classcsl_1_1AbstractMultiFunc.html#a9d64fefa1c3718d1fe431edfa4934e71">More...</a><br /></td></tr>
<tr class="separator:a9d64fefa1c3718d1fe431edfa4934e71 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bbf7b44a59c1efe7e73961da575af4 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="a32bbf7b44a59c1efe7e73961da575af4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dependsOn</b> (const <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> *parent) const override</td></tr>
<tr class="separator:a32bbf7b44a59c1efe7e73961da575af4 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad072ccb3f8007430a6d6dce53f32b441 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#ad072ccb3f8007430a6d6dce53f32b441">dependsExplicitlyOn</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:ad072ccb3f8007430a6d6dce53f32b441 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if <b>expr</b> is present in the expression.  <a href="classcsl_1_1AbstractMultiFunc.html#ad072ccb3f8007430a6d6dce53f32b441">More...</a><br /></td></tr>
<tr class="separator:ad072ccb3f8007430a6d6dce53f32b441 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3599e88ef45e1abc9c878432c67ade inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="a7c3599e88ef45e1abc9c878432c67ade"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dependsExplicitlyOn</b> (<a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> expr) const override</td></tr>
<tr class="separator:a7c3599e88ef45e1abc9c878432c67ade inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54eff0c503e2c2947b232622261c998 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#ac54eff0c503e2c2947b232622261c998">commutesWith</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, int sign=-1) const override</td></tr>
<tr class="memdesc:ac54eff0c503e2c2947b232622261c998 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the object commutes with expr.  <a href="classcsl_1_1AbstractMultiFunc.html#ac54eff0c503e2c2947b232622261c998">More...</a><br /></td></tr>
<tr class="separator:ac54eff0c503e2c2947b232622261c998 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8014e107c584b6450d3cc1ce78e154ca inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a8014e107c584b6450d3cc1ce78e154ca">isPolynomial</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:a8014e107c584b6450d3cc1ce78e154ca inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the expression is a mononomial term in <b>expr</b>, i.e. a term of the form C*expr^n with C independent of expr, n integer.  <a href="classcsl_1_1AbstractMultiFunc.html#a8014e107c584b6450d3cc1ce78e154ca">More...</a><br /></td></tr>
<tr class="separator:a8014e107c584b6450d3cc1ce78e154ca inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4be44fbde5ebd97065a575992d498c2 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#ad4be44fbde5ebd97065a575992d498c2">operator&lt;</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> other) const override</td></tr>
<tr class="memdesc:ad4be44fbde5ebd97065a575992d498c2 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1AbstractMultiFunc.html#ad4be44fbde5ebd97065a575992d498c2">More...</a><br /></td></tr>
<tr class="separator:ad4be44fbde5ebd97065a575992d498c2 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26979a899fab4621102645d0f8366457 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a26979a899fab4621102645d0f8366457">operator[]</a> (int i) const override</td></tr>
<tr class="memdesc:a26979a899fab4621102645d0f8366457 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, equivalent to the function <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a75ae783c1bd8e55ccc005af538599def" title="Returns one particular argument. ">getArgument()</a>.  <a href="classcsl_1_1AbstractMultiFunc.html#a26979a899fab4621102645d0f8366457">More...</a><br /></td></tr>
<tr class="separator:a26979a899fab4621102645d0f8366457 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4922013ae4c2b23e6fab8bc9056ab42 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#ae4922013ae4c2b23e6fab8bc9056ab42">operator[]</a> (int i) override</td></tr>
<tr class="memdesc:ae4922013ae4c2b23e6fab8bc9056ab42 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, returns a reference so this function is not const.  <a href="classcsl_1_1AbstractMultiFunc.html#ae4922013ae4c2b23e6fab8bc9056ab42">More...</a><br /></td></tr>
<tr class="separator:ae4922013ae4c2b23e6fab8bc9056ab42 inherit pub_methods_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcsl_1_1Abstract"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcsl_1_1Abstract')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a></td></tr>
<tr class="memitem:ad5fee68c1f3dcbda0e936926fed17616 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad5fee68c1f3dcbda0e936926fed17616">Abstract</a> ()</td></tr>
<tr class="memdesc:ad5fee68c1f3dcbda0e936926fed17616 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classcsl_1_1Abstract.html#ad5fee68c1f3dcbda0e936926fed17616">More...</a><br /></td></tr>
<tr class="separator:ad5fee68c1f3dcbda0e936926fed17616 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bdc4c76fdbbf3cbac3af4dce8286ed inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a40bdc4c76fdbbf3cbac3af4dce8286ed"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a40bdc4c76fdbbf3cbac3af4dce8286ed">~Abstract</a> ()</td></tr>
<tr class="memdesc:a40bdc4c76fdbbf3cbac3af4dce8286ed inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a40bdc4c76fdbbf3cbac3af4dce8286ed inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c796713828ebfb74a7d8787d7802a76 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a5c796713828ebfb74a7d8787d7802a76"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> ()</td></tr>
<tr class="separator:a5c796713828ebfb74a7d8787d7802a76 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0645745feacf93470963b55f93cae1c0 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0645745feacf93470963b55f93cae1c0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>printProp</b> (std::ostream &amp;fout=std::cout) const</td></tr>
<tr class="separator:a0645745feacf93470963b55f93cae1c0 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e45ffc7b65f92e77e592f76f70934c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a89e45ffc7b65f92e77e592f76f70934c">printExplicit</a> (int mode=0) const</td></tr>
<tr class="memdesc:a89e45ffc7b65f92e77e592f76f70934c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays explicitely the expression, with types of each component. This function is only used for debug.  <a href="classcsl_1_1Abstract.html#a89e45ffc7b65f92e77e592f76f70934c">More...</a><br /></td></tr>
<tr class="separator:a89e45ffc7b65f92e77e592f76f70934c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652101e34b2efa43114150e9af3c79d5 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a652101e34b2efa43114150e9af3c79d5"></a>
virtual <a class="el" href="classcsl_1_1LibDependency.html">LibDependency</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getLibDependency</b> () const</td></tr>
<tr class="separator:a652101e34b2efa43114150e9af3c79d5 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3978c71035bf1cda50f5b9031d631af inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ac3978c71035bf1cda50f5b9031d631af"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>memoryOverhead</b> () const</td></tr>
<tr class="separator:ac3978c71035bf1cda50f5b9031d631af inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5e7466e754984a2c4394a112464f7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af7f5e7466e754984a2c4394a112464f7">getName</a> () const</td></tr>
<tr class="memdesc:af7f5e7466e754984a2c4394a112464f7 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>'s name.  <a href="classcsl_1_1Abstract.html#af7f5e7466e754984a2c4394a112464f7">More...</a><br /></td></tr>
<tr class="separator:af7f5e7466e754984a2c4394a112464f7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4a302d1a3cbf4dd9394f5e5880d343 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a9c4a302d1a3cbf4dd9394f5e5880d343"></a>
virtual std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getLatexName</b> () const</td></tr>
<tr class="separator:a9c4a302d1a3cbf4dd9394f5e5880d343 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e067fc57c0c2e70d141079455fdbd7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a77e067fc57c0c2e70d141079455fdbd7"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>getElementary</b> () const</td></tr>
<tr class="separator:a77e067fc57c0c2e70d141079455fdbd7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021946e84d8c1a019908cac578b16fe8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a021946e84d8c1a019908cac578b16fe8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>getAllDependencies</b> () const</td></tr>
<tr class="separator:a021946e84d8c1a019908cac578b16fe8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856c3d55a6d1406970f3656e61efe8e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5856c3d55a6d1406970f3656e61efe8e">getDim</a> () const</td></tr>
<tr class="memdesc:a5856c3d55a6d1406970f3656e61efe8e inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>dimension</b> of the object.  <a href="classcsl_1_1Abstract.html#a5856c3d55a6d1406970f3656e61efe8e">More...</a><br /></td></tr>
<tr class="separator:a5856c3d55a6d1406970f3656e61efe8e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c068f1da78856321932b6b6ae17dc inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad74c068f1da78856321932b6b6ae17dc">isBuildingBlock</a> () const</td></tr>
<tr class="memdesc:ad74c068f1da78856321932b6b6ae17dc inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is a Building Block or not.  <a href="classcsl_1_1Abstract.html#ad74c068f1da78856321932b6b6ae17dc">More...</a><br /></td></tr>
<tr class="separator:ad74c068f1da78856321932b6b6ae17dc inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09992d147b39388c8936b3bff648930 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ac09992d147b39388c8936b3bff648930"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isArbitrary</b> () const</td></tr>
<tr class="separator:ac09992d147b39388c8936b3bff648930 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca85809fef9dddefa5f9e06c3b25215d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classcsl_1_1Equation.html">Equation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aca85809fef9dddefa5f9e06c3b25215d">getProperties</a> () const</td></tr>
<tr class="separator:aca85809fef9dddefa5f9e06c3b25215d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a594845a29429c9b4f19c92bd18cad inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a22a594845a29429c9b4f19c92bd18cad"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isComplexConjugate</b> () const</td></tr>
<tr class="separator:a22a594845a29429c9b4f19c92bd18cad inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ce38838e35c5785f92373a1d830668 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="af2ce38838e35c5785f92373a1d830668"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isHermitianConjugate</b> () const</td></tr>
<tr class="separator:af2ce38838e35c5785f92373a1d830668 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470d9f1267fba4a82e13af4a39470f81 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a470d9f1267fba4a82e13af4a39470f81"></a>
virtual <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getComplexProperty</b> () const</td></tr>
<tr class="separator:a470d9f1267fba4a82e13af4a39470f81 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35385480a1be08f5e7433535b58ac0b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ae35385480a1be08f5e7433535b58ac0b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setComplexProperty</b> (<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop)</td></tr>
<tr class="separator:ae35385480a1be08f5e7433535b58ac0b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ebc247831d6629d44117a490fca120 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a37ebc247831d6629d44117a490fca120"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setConjugated</b> (bool t_conjugated)</td></tr>
<tr class="separator:a37ebc247831d6629d44117a490fca120 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a014bfd266b5f8471f23580e271979b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9a014bfd266b5f8471f23580e271979b">isInteger</a> () const</td></tr>
<tr class="memdesc:a9a014bfd266b5f8471f23580e271979b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is an integer. Either an <a class="el" href="classcsl_1_1Integer.html" title="Handle numbers in expr. ">Integer</a> object directly, or a <a class="el" href="classcsl_1_1Float.html" title="Handle numbers in expr. ">Float</a> that has an integer value.  <a href="classcsl_1_1Abstract.html#a9a014bfd266b5f8471f23580e271979b">More...</a><br /></td></tr>
<tr class="separator:a9a014bfd266b5f8471f23580e271979b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628563238145f3a9acc331f1a89ce32f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a628563238145f3a9acc331f1a89ce32f">getValued</a> () const</td></tr>
<tr class="memdesc:a628563238145f3a9acc331f1a89ce32f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is valued, i.e. is a function of numbers and valued literals (a <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a> or <a class="el" href="classcsl_1_1Constant.html" title="Handle an object with a name and a value. ">Constant</a> is not valued by default).  <a href="classcsl_1_1Abstract.html#a628563238145f3a9acc331f1a89ce32f">More...</a><br /></td></tr>
<tr class="separator:a628563238145f3a9acc331f1a89ce32f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f98ba06476e464e3fd2fce0d1f8243 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a78f98ba06476e464e3fd2fce0d1f8243">getValue</a> () const</td></tr>
<tr class="memdesc:a78f98ba06476e464e3fd2fce0d1f8243 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the expression, if it has one <b>explicitely</b>. In particular, it will work only on Numbers and valued Literals, not on functions.  <a href="classcsl_1_1Abstract.html#a78f98ba06476e464e3fd2fce0d1f8243">More...</a><br /></td></tr>
<tr class="separator:a78f98ba06476e464e3fd2fce0d1f8243 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a657baf1c35ed581e9db2c47a71c99 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a69a657baf1c35ed581e9db2c47a71c99"></a>
virtual long double&#160;</td><td class="memItemRight" valign="bottom"><b>getDeltaPlus</b> () const</td></tr>
<tr class="separator:a69a657baf1c35ed581e9db2c47a71c99 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f0e4c9c91f43b5cd61cbb873869eb inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa22f0e4c9c91f43b5cd61cbb873869eb"></a>
virtual long double&#160;</td><td class="memItemRight" valign="bottom"><b>getDeltaMinus</b> () const</td></tr>
<tr class="separator:aa22f0e4c9c91f43b5cd61cbb873869eb inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed">getNum</a> () const</td></tr>
<tr class="separator:a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9531d78d67c82e288c0130da5b1ba80b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9531d78d67c82e288c0130da5b1ba80b">getDenom</a> () const</td></tr>
<tr class="separator:a9531d78d67c82e288c0130da5b1ba80b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94b3892af147ac0b05c1d8c960e4eba inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad94b3892af147ac0b05c1d8c960e4eba">getArgument</a> (const std::vector&lt; int &gt; &amp;indices) const</td></tr>
<tr class="memdesc:ad94b3892af147ac0b05c1d8c960e4eba inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension.  <a href="classcsl_1_1Abstract.html#ad94b3892af147ac0b05c1d8c960e4eba">More...</a><br /></td></tr>
<tr class="separator:ad94b3892af147ac0b05c1d8c960e4eba inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050aa1cdc4549cbf29181f73a5731cfc inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a050aa1cdc4549cbf29181f73a5731cfc"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getArgument</b> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:a050aa1cdc4549cbf29181f73a5731cfc inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85f810bbadbc792210c958e8f1b2ffb inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae85f810bbadbc792210c958e8f1b2ffb">getVariable</a> () const</td></tr>
<tr class="memdesc:ae85f810bbadbc792210c958e8f1b2ffb inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the variable that defines certain types of expressions.  <a href="classcsl_1_1Abstract.html#ae85f810bbadbc792210c958e8f1b2ffb">More...</a><br /></td></tr>
<tr class="separator:ae85f810bbadbc792210c958e8f1b2ffb inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9500a21d75d03c695ec0c76493600b38 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9500a21d75d03c695ec0c76493600b38">getOrder</a> () const</td></tr>
<tr class="memdesc:a9500a21d75d03c695ec0c76493600b38 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the order (integer) that defines certain types of expressions.  <a href="classcsl_1_1Abstract.html#a9500a21d75d03c695ec0c76493600b38">More...</a><br /></td></tr>
<tr class="separator:a9500a21d75d03c695ec0c76493600b38 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83df1d9dc202457113e5b38bd694fae inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa83df1d9dc202457113e5b38bd694fae">getSign</a> () const</td></tr>
<tr class="separator:aa83df1d9dc202457113e5b38bd694fae inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9347e75b0cd0b75e0f0a38db93b29d83 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9347e75b0cd0b75e0f0a38db93b29d83">isAnOperator</a> () const</td></tr>
<tr class="memdesc:a9347e75b0cd0b75e0f0a38db93b29d83 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is an operator (like a derivetive operator).  <a href="classcsl_1_1Abstract.html#a9347e75b0cd0b75e0f0a38db93b29d83">More...</a><br /></td></tr>
<tr class="separator:a9347e75b0cd0b75e0f0a38db93b29d83 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464f4f0613db9b4b0a4efe26a3a03d60 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a464f4f0613db9b4b0a4efe26a3a03d60">isEmpty</a> () const</td></tr>
<tr class="memdesc:a464f4f0613db9b4b0a4efe26a3a03d60 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells for a <a class="el" href="classcsl_1_1Derivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or an <a class="el" href="classcsl_1_1Integral.html">Integral</a> if the argument is empty i.e. if the object must apply on the next argument encountered on the right.  <a href="classcsl_1_1Abstract.html#a464f4f0613db9b4b0a4efe26a3a03d60">More...</a><br /></td></tr>
<tr class="separator:a464f4f0613db9b4b0a4efe26a3a03d60 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d9abfa88d9d09a89d3a4becd9e6429 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a75d9abfa88d9d09a89d3a4becd9e6429"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>operatorAppliesOn</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a75d9abfa88d9d09a89d3a4becd9e6429 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3ec3dfe1fbd8ead5c8d9aca421a863 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9c3ec3dfe1fbd8ead5c8d9aca421a863">getOperand</a> () const</td></tr>
<tr class="memdesc:a9c3ec3dfe1fbd8ead5c8d9aca421a863 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand of an <a class="el" href="classcsl_1_1Operator.html" title="Linear operator O(a*X+b*Y) = a*O(X) + b*O(Y) ">Operator</a>.  <a href="classcsl_1_1Abstract.html#a9c3ec3dfe1fbd8ead5c8d9aca421a863">More...</a><br /></td></tr>
<tr class="separator:a9c3ec3dfe1fbd8ead5c8d9aca421a863 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625efe55a17b97a1c0f085bdbf3a962a inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a625efe55a17b97a1c0f085bdbf3a962a">getShape</a> () const</td></tr>
<tr class="memdesc:a625efe55a17b97a1c0f085bdbf3a962a inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the shape of the tensor in the form of a std::vector of integers.  <a href="classcsl_1_1Abstract.html#a625efe55a17b97a1c0f085bdbf3a962a">More...</a><br /></td></tr>
<tr class="separator:a625efe55a17b97a1c0f085bdbf3a962a inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b1e294cf24dea17c3c4361226138b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a3d6b1e294cf24dea17c3c4361226138b"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInfBoundary</b> () const</td></tr>
<tr class="separator:a3d6b1e294cf24dea17c3c4361226138b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcc223dbf5d880e923c07df142df5c8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a2fcc223dbf5d880e923c07df142df5c8"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSupBoundary</b> () const</td></tr>
<tr class="separator:a2fcc223dbf5d880e923c07df142df5c8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7104a5b8855272a92a47c58f29e958 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aad7104a5b8855272a92a47c58f29e958"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setSupBoundary</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_inf)</td></tr>
<tr class="separator:aad7104a5b8855272a92a47c58f29e958 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecdb6ce7a2d9643da2f6161a06dfbbf inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a5ecdb6ce7a2d9643da2f6161a06dfbbf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setInfBoundary</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_inf)</td></tr>
<tr class="separator:a5ecdb6ce7a2d9643da2f6161a06dfbbf inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add364193f7a78ac28f7001c7f4036453 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#add364193f7a78ac28f7001c7f4036453">getNIndices</a> () const</td></tr>
<tr class="separator:add364193f7a78ac28f7001c7f4036453 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3234ce243f6a2e11950be42f10100943 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a3234ce243f6a2e11950be42f10100943">getIndex</a> (int i=0) const</td></tr>
<tr class="separator:a3234ce243f6a2e11950be42f10100943 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d95f3edc0562b1d75d60b670119842 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="af0d95f3edc0562b1d75d60b670119842"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>resetIndexStructure</b> ()</td></tr>
<tr class="separator:af0d95f3edc0562b1d75d60b670119842 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae125a32b6f3d0368b6055d4e58c1ff3f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae125a32b6f3d0368b6055d4e58c1ff3f">getIndexStructure</a> () const</td></tr>
<tr class="separator:ae125a32b6f3d0368b6055d4e58c1ff3f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a9a9ef3efd6bb83b62c0a353742d25 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ae6a9a9ef3efd6bb83b62c0a353742d25"></a>
<a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructure</b> (<a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space) const</td></tr>
<tr class="separator:ae6a9a9ef3efd6bb83b62c0a353742d25 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb848bf4cdea207484a71e9b1006ead inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="addb848bf4cdea207484a71e9b1006ead"></a>
virtual const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructureView</b> () const</td></tr>
<tr class="separator:addb848bf4cdea207484a71e9b1006ead inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632e28530a68539fadacd7ab7ffc8be1 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a632e28530a68539fadacd7ab7ffc8be1"></a>
virtual <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructureView</b> ()</td></tr>
<tr class="separator:a632e28530a68539fadacd7ab7ffc8be1 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4136dc23f1fba4bf897b54c8592ccfc inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa4136dc23f1fba4bf897b54c8592ccfc">getFreeIndexStructure</a> () const</td></tr>
<tr class="separator:aa4136dc23f1fba4bf897b54c8592ccfc inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab150130c9f67daaf6aba52b9f6b90941 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Parent.html">Parent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ab150130c9f67daaf6aba52b9f6b90941">getParent</a> () const</td></tr>
<tr class="memdesc:ab150130c9f67daaf6aba52b9f6b90941 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">For indicial expressions this function returns a pointer to the parent object of type <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> (not an expression).  <a href="classcsl_1_1Abstract.html#ab150130c9f67daaf6aba52b9f6b90941">More...</a><br /></td></tr>
<tr class="separator:ab150130c9f67daaf6aba52b9f6b90941 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f775b5add9af8727ead2cfaab78ba2 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a15f775b5add9af8727ead2cfaab78ba2"></a>
virtual <a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getParent_info</b> () const</td></tr>
<tr class="separator:a15f775b5add9af8727ead2cfaab78ba2 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42125e9765a771c47819548d342b0b28 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a42125e9765a771c47819548d342b0b28">getNContractedPairs</a> () const</td></tr>
<tr class="memdesc:a42125e9765a771c47819548d342b0b28 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of contracted pairs of indices <b>in an Indicial expression</b>.  <a href="classcsl_1_1Abstract.html#a42125e9765a771c47819548d342b0b28">More...</a><br /></td></tr>
<tr class="separator:a42125e9765a771c47819548d342b0b28 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946d175d946da102c5f4cc91840703cb inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a946d175d946da102c5f4cc91840703cb">getPermutations</a> (bool optimize=true) const</td></tr>
<tr class="memdesc:a946d175d946da102c5f4cc91840703cb inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::vector of all possible permutations of an <b>Indicial</b> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object.  <a href="classcsl_1_1Abstract.html#a946d175d946da102c5f4cc91840703cb">More...</a><br /></td></tr>
<tr class="separator:a946d175d946da102c5f4cc91840703cb inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04c0e4426f0bf9df365afe0148d59df inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af04c0e4426f0bf9df365afe0148d59df">getContractedPair</a> () const</td></tr>
<tr class="separator:af04c0e4426f0bf9df365afe0148d59df inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c2898c5d3ba96de8018a0838c402c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="af29c2898c5d3ba96de8018a0838c402c"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> () const</td></tr>
<tr class="separator:af29c2898c5d3ba96de8018a0838c402c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867135c96776248add60018f4aa7a578 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a867135c96776248add60018f4aa7a578">setName</a> (const std::string &amp;t_name)</td></tr>
<tr class="memdesc:a867135c96776248add60018f4aa7a578 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the name of the abstract.  <a href="classcsl_1_1Abstract.html#a867135c96776248add60018f4aa7a578">More...</a><br /></td></tr>
<tr class="separator:a867135c96776248add60018f4aa7a578 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb29d316b8f64652cef472a6c23f001 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7bb29d316b8f64652cef472a6c23f001">setCommutable</a> (bool t_commutable)</td></tr>
<tr class="memdesc:a7bb29d316b8f64652cef472a6c23f001 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the abstract to commute or not.  <a href="classcsl_1_1Abstract.html#a7bb29d316b8f64652cef472a6c23f001">More...</a><br /></td></tr>
<tr class="separator:a7bb29d316b8f64652cef472a6c23f001 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf5ecfe10b79ecbe840ded8c3d8ced inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9cbf5ecfe10b79ecbe840ded8c3d8ced">addProperty</a> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *property)</td></tr>
<tr class="memdesc:a9cbf5ecfe10b79ecbe840ded8c3d8ced inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a property to the object.  <a href="classcsl_1_1Abstract.html#a9cbf5ecfe10b79ecbe840ded8c3d8ced">More...</a><br /></td></tr>
<tr class="separator:a9cbf5ecfe10b79ecbe840ded8c3d8ced inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d31d945e2012d108dfc3ce3eb48161 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a70d31d945e2012d108dfc3ce3eb48161">removeProperty</a> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *property)</td></tr>
<tr class="memdesc:a70d31d945e2012d108dfc3ce3eb48161 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a property to the object.  <a href="classcsl_1_1Abstract.html#a70d31d945e2012d108dfc3ce3eb48161">More...</a><br /></td></tr>
<tr class="separator:a70d31d945e2012d108dfc3ce3eb48161 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7f0692cb84ca861a5b3b641bea518b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aaf7f0692cb84ca861a5b3b641bea518b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aaf7f0692cb84ca861a5b3b641bea518b">setValue</a> (long double t_value)</td></tr>
<tr class="memdesc:aaf7f0692cb84ca861a5b3b641bea518b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value if there is one (for Numerical and Literal valued). <br /></td></tr>
<tr class="separator:aaf7f0692cb84ca861a5b3b641bea518b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49c51bd285830e724f103e9fb61c464 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa49c51bd285830e724f103e9fb61c464"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setValue</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_value)</td></tr>
<tr class="separator:aa49c51bd285830e724f103e9fb61c464 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a04bb56578e7da143b3cd8d8fb7b26 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa6a04bb56578e7da143b3cd8d8fb7b26"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setElementary</b> (bool t_elementary)</td></tr>
<tr class="separator:aa6a04bb56578e7da143b3cd8d8fb7b26 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a40ceb6eb1aa79711ca126d5bdda02 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa6a40ceb6eb1aa79711ca126d5bdda02"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setAllDependencies</b> (bool t_allDependencies)</td></tr>
<tr class="separator:aa6a40ceb6eb1aa79711ca126d5bdda02 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbab11282e5c6ac46b018642ff129f47 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="abbab11282e5c6ac46b018642ff129f47"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addDependency</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:abbab11282e5c6ac46b018642ff129f47 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e778c682b6cb02642b90e8ec8765441 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0e778c682b6cb02642b90e8ec8765441"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeDependency</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a0e778c682b6cb02642b90e8ec8765441 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7907d6983f47d261748870b497f6aa8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae7907d6983f47d261748870b497f6aa8">setArgument</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:ae7907d6983f47d261748870b497f6aa8 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions.  <a href="classcsl_1_1Abstract.html#ae7907d6983f47d261748870b497f6aa8">More...</a><br /></td></tr>
<tr class="separator:ae7907d6983f47d261748870b497f6aa8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa50c743b8e7e76e637e98f165ad4e5d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="afa50c743b8e7e76e637e98f165ad4e5d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setEmpty</b> (bool t_empty)</td></tr>
<tr class="separator:afa50c743b8e7e76e637e98f165ad4e5d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70df7be4486affa8dc891e3f25bf499f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a70df7be4486affa8dc891e3f25bf499f">setOperand</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand)</td></tr>
<tr class="memdesc:a70df7be4486affa8dc891e3f25bf499f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operand of an operator.  <a href="classcsl_1_1Abstract.html#a70df7be4486affa8dc891e3f25bf499f">More...</a><br /></td></tr>
<tr class="separator:a70df7be4486affa8dc891e3f25bf499f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b8a14fc746ed72e4d5abd63373c5ba inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae7b8a14fc746ed72e4d5abd63373c5ba">setOperandPrivate</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand, bool leaveEmpty)</td></tr>
<tr class="memdesc:ae7b8a14fc746ed72e4d5abd63373c5ba inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operand of an operator.  <a href="classcsl_1_1Abstract.html#ae7b8a14fc746ed72e4d5abd63373c5ba">More...</a><br /></td></tr>
<tr class="separator:ae7b8a14fc746ed72e4d5abd63373c5ba inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47ddab3aa047e86be34c70358d53548 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa47ddab3aa047e86be34c70358d53548"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setVariable</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_variable)</td></tr>
<tr class="separator:aa47ddab3aa047e86be34c70358d53548 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3003698af4978e774eeb2e62038f7432 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a3003698af4978e774eeb2e62038f7432"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setParent</b> (const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;t_parent)</td></tr>
<tr class="separator:a3003698af4978e774eeb2e62038f7432 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e54a236015d14af42b0bcde41953f3 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ac9e54a236015d14af42b0bcde41953f3"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>replaceIndices</b> (std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; const &amp;indexToReplace, std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; const &amp;newIndex, bool refresh=true, bool flipped=false) const</td></tr>
<tr class="separator:ac9e54a236015d14af42b0bcde41953f3 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9372ddd521fa661c5d3371e0d8d4dfc3 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a9372ddd521fa661c5d3371e0d8d4dfc3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceIndexInPlace</b> (<a class="el" href="classcsl_1_1Index.html">Index</a> const &amp;oldIndex, <a class="el" href="classcsl_1_1Index.html">Index</a> const &amp;newIndex)</td></tr>
<tr class="separator:a9372ddd521fa661c5d3371e0d8d4dfc3 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed79d20a0821205e6430c80a474117d3 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aed79d20a0821205e6430c80a474117d3"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>contractIndex</b> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index) const</td></tr>
<tr class="separator:aed79d20a0821205e6430c80a474117d3 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3627f1b91e9a81f27a8b8733ec615e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0e3627f1b91e9a81f27a8b8733ec615e"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>breakSpace</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *brokenSpace, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;newSpace) const</td></tr>
<tr class="separator:a0e3627f1b91e9a81f27a8b8733ec615e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbadc809396b1a2515a4b7ca33ffb98 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="acdbadc809396b1a2515a4b7ca33ffb98"></a>
virtual csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>breakSpace</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *brokenSpace, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;newSpace, const std::vector&lt; std::string &gt; &amp;indexNames) const</td></tr>
<tr class="separator:acdbadc809396b1a2515a4b7ca33ffb98 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f946f9c59df045ef7416320ade89c7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a70f946f9c59df045ef7416320ade89c7">setIndexStructure</a> (const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;t_index)</td></tr>
<tr class="memdesc:a70f946f9c59df045ef7416320ade89c7 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the index structure of the object, that must be an <b>Indicial</b> expression.  <a href="classcsl_1_1Abstract.html#a70f946f9c59df045ef7416320ade89c7">More...</a><br /></td></tr>
<tr class="separator:a70f946f9c59df045ef7416320ade89c7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c175411df619e7504feb6d888fc82f1 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a3c175411df619e7504feb6d888fc82f1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setPoint</b> (const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;t_point)</td></tr>
<tr class="separator:a3c175411df619e7504feb6d888fc82f1 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f90ebb7cf7c26782bd36bc2a67fc5d4 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a4f90ebb7cf7c26782bd36bc2a67fc5d4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4f90ebb7cf7c26782bd36bc2a67fc5d4">setFullySymmetric</a> ()</td></tr>
<tr class="memdesc:a4f90ebb7cf7c26782bd36bc2a67fc5d4 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties of symmetry / antisymmetry and sets <b>fullySymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:a4f90ebb7cf7c26782bd36bc2a67fc5d4 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac318016372d14b795893fe7e59199084 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ac318016372d14b795893fe7e59199084"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac318016372d14b795893fe7e59199084">setFullyAntiSymmetric</a> ()</td></tr>
<tr class="memdesc:ac318016372d14b795893fe7e59199084 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully anti-symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties * of symmetry / antisymmetry and sets <b>fullyAntiSymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:ac318016372d14b795893fe7e59199084 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad431770faa4291116a50175193a11a88 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad431770faa4291116a50175193a11a88">addSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:ad431770faa4291116a50175193a11a88 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a symmetry between the i1^{th} and the i2^{th} indices. If those indices are anti-symmetric, an error is thrown.  <a href="classcsl_1_1Abstract.html#ad431770faa4291116a50175193a11a88">More...</a><br /></td></tr>
<tr class="separator:ad431770faa4291116a50175193a11a88 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5549ac0c186b3c6febf332245a25a82c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5549ac0c186b3c6febf332245a25a82c">addAntiSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a5549ac0c186b3c6febf332245a25a82c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an anti-symmetry between the i1^{th} and the i2^{th} indices. If those indices are symmetric, an error is thrown.  <a href="classcsl_1_1Abstract.html#a5549ac0c186b3c6febf332245a25a82c">More...</a><br /></td></tr>
<tr class="separator:a5549ac0c186b3c6febf332245a25a82c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9aceabbc0a99642e84c9025dbdc767 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#abe9aceabbc0a99642e84c9025dbdc767">permut</a> (int i1, int i2)</td></tr>
<tr class="memdesc:abe9aceabbc0a99642e84c9025dbdc767 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to permut indices at place <b>i1</b> and <b>i2</b>. If those two indices have a symmetry property, indices are swaped and the symmetry is returned. Else the fnuction does nothing and returns 0.  <a href="classcsl_1_1Abstract.html#abe9aceabbc0a99642e84c9025dbdc767">More...</a><br /></td></tr>
<tr class="separator:abe9aceabbc0a99642e84c9025dbdc767 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204dbd37b63432cb08932b995f49d3f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a204dbd37b63432cb08932b995f49d3f4">getNFactor</a> () const</td></tr>
<tr class="separator:a204dbd37b63432cb08932b995f49d3f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac513c930caa9939c2b9557f36a34ee69 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac513c930caa9939c2b9557f36a34ee69">getExponents</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;exponents) const</td></tr>
<tr class="memdesc:ac513c930caa9939c2b9557f36a34ee69 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills in a vector the exponents corresponding to some factors for the expression.  <a href="classcsl_1_1Abstract.html#ac513c930caa9939c2b9557f36a34ee69">More...</a><br /></td></tr>
<tr class="separator:ac513c930caa9939c2b9557f36a34ee69 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c316b059cb2a1e3020310b148f921b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa0c316b059cb2a1e3020310b148f921b">checkIndexStructure</a> (const std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;t_index) const</td></tr>
<tr class="memdesc:aa0c316b059cb2a1e3020310b148f921b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="classcsl_1_1Abstract.html#aa0c316b059cb2a1e3020310b148f921b">More...</a><br /></td></tr>
<tr class="separator:aa0c316b059cb2a1e3020310b148f921b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebd84082bb93418408cc0babe2dffe2 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1ebd84082bb93418408cc0babe2dffe2">checkIndexStructure</a> (const std::initializer_list&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;index) const</td></tr>
<tr class="memdesc:a1ebd84082bb93418408cc0babe2dffe2 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="classcsl_1_1Abstract.html#a1ebd84082bb93418408cc0babe2dffe2">More...</a><br /></td></tr>
<tr class="separator:a1ebd84082bb93418408cc0babe2dffe2 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caee12abb451168149779a668dfc59e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7caee12abb451168149779a668dfc59e">compareWithDummy</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, std::map&lt; <a class="el" href="classcsl_1_1Index.html">Index</a>, <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;constraints, bool keepAllCosntraints=false) const</td></tr>
<tr class="memdesc:a7caee12abb451168149779a668dfc59e inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr.  <a href="classcsl_1_1Abstract.html#a7caee12abb451168149779a668dfc59e">More...</a><br /></td></tr>
<tr class="separator:a7caee12abb451168149779a668dfc59e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f16fda9fe72a89c61ece36101a11d95 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0f16fda9fe72a89c61ece36101a11d95"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compareWithDummy</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool keepAllCosntraints=false) const</td></tr>
<tr class="separator:a0f16fda9fe72a89c61ece36101a11d95 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7d8586a0df66ba8da33528d6400e66 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a9d7d8586a0df66ba8da33528d6400e66"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>dependsOn</b> (<a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> parent) const</td></tr>
<tr class="separator:a9d7d8586a0df66ba8da33528d6400e66 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c1d8df9e6b1a3eca66958f7dc489d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ab79c1d8df9e6b1a3eca66958f7dc489d">matchShape</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool exact=false) const</td></tr>
<tr class="memdesc:ab79c1d8df9e6b1a3eca66958f7dc489d inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of a vectorial-type expression, this function checks if the shape of expr matches itself.  <a href="classcsl_1_1Abstract.html#ab79c1d8df9e6b1a3eca66958f7dc489d">More...</a><br /></td></tr>
<tr class="separator:ab79c1d8df9e6b1a3eca66958f7dc489d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31e08c251d96b8ea8ec8d385895c1ff inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa31e08c251d96b8ea8ec8d385895c1ff">hasContractionProperty</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B) const</td></tr>
<tr class="memdesc:aa31e08c251d96b8ea8ec8d385895c1ff inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells (for an Indicial type) if there is a special contraction property with <b>B</b>.  <a href="classcsl_1_1Abstract.html#aa31e08c251d96b8ea8ec8d385895c1ff">More...</a><br /></td></tr>
<tr class="separator:aa31e08c251d96b8ea8ec8d385895c1ff inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bf1455397fdd2df8dbbc3b41c2f3f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a94bf1455397fdd2df8dbbc3b41c2f3f4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasChainContractionProperty</b> () const</td></tr>
<tr class="separator:a94bf1455397fdd2df8dbbc3b41c2f3f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec707d949f0f98e08ab4642c93dd9eb5 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aec707d949f0f98e08ab4642c93dd9eb5"></a>
virtual std::vector&lt; <a class="el" href="classcsl_1_1ContractionChain.html">ContractionChain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getContractionProperties</b> () const</td></tr>
<tr class="separator:aec707d949f0f98e08ab4642c93dd9eb5 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad874fc858295a737e6ce884530f1109b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad874fc858295a737e6ce884530f1109b">contraction</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B) const</td></tr>
<tr class="memdesc:ad874fc858295a737e6ce884530f1109b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a special contraction of indices. Before calling this function we must check that there is indeed a contraction by calling the function <a class="el" href="classcsl_1_1Abstract.html#aa31e08c251d96b8ea8ec8d385895c1ff" title="Tells (for an Indicial type) if there is a special contraction property with B. ">hasContractionProperty()</a>.  <a href="classcsl_1_1Abstract.html#ad874fc858295a737e6ce884530f1109b">More...</a><br /></td></tr>
<tr class="separator:ad874fc858295a737e6ce884530f1109b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd35096982e92b669ea55d960c5f44be inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="abd35096982e92b669ea55d960c5f44be"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>contraction</b> (const csl::vector_expr &amp;chain) const</td></tr>
<tr class="separator:abd35096982e92b669ea55d960c5f44be inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eeedaeaa39e75facf1060dce7c57a8f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4eeedaeaa39e75facf1060dce7c57a8f">suppressExponent</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;<a class="el" href="classcsl_1_1Abstract.html#a0bc0de9c4ce5f77fc716af0f502d13d3">factor</a>, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;exponent) const</td></tr>
<tr class="memdesc:a4eeedaeaa39e75facf1060dce7c57a8f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression where the factor <b>factor^exponent</b> has been suppressed.  <a href="classcsl_1_1Abstract.html#a4eeedaeaa39e75facf1060dce7c57a8f">More...</a><br /></td></tr>
<tr class="separator:a4eeedaeaa39e75facf1060dce7c57a8f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6305ce90c795bfb416d8e958c62f905c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a6305ce90c795bfb416d8e958c62f905c"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>applySelfStructureOn</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:a6305ce90c795bfb416d8e958c62f905c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404c5e89a3aad8a8dabcb56d4120c0fe inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a404c5e89a3aad8a8dabcb56d4120c0fe"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTransposed</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *space, bool applyProp=true) const</td></tr>
<tr class="separator:a404c5e89a3aad8a8dabcb56d4120c0fe inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1e82fc94c0d0734f382edf865d8428 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a9d1e82fc94c0d0734f382edf865d8428"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTransposed</b> (const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces, bool applyProp=true) const</td></tr>
<tr class="separator:a9d1e82fc94c0d0734f382edf865d8428 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b707a5efdaef7c7945cbd921c3f526 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa5b707a5efdaef7c7945cbd921c3f526"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHermitianConjugate</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *space) const</td></tr>
<tr class="separator:aa5b707a5efdaef7c7945cbd921c3f526 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c74100bc93fd703bc15f0d426697154 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a8c74100bc93fd703bc15f0d426697154"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHermitianConjugate</b> (const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces) const</td></tr>
<tr class="separator:a8c74100bc93fd703bc15f0d426697154 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade540a127da7304f2b7282f4dcaffc7f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ade540a127da7304f2b7282f4dcaffc7f">getPolynomialTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> t_variable, int order) const</td></tr>
<tr class="memdesc:ade540a127da7304f2b7282f4dcaffc7f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the polynomial term corresponding to <b>*this</b> with the variable <b>t_variable</b> at order <b>order</b>. In particular, this function assumes that the checks have already been made with the function <a class="el" href="classcsl_1_1Abstract.html#acae10d5685ccec295fbd9be7996073cb" title="Determines if the expression is a mononomial term in expr, i.e. a term of the form C*expr^n with C in...">isPolynomial()</a>.  <a href="classcsl_1_1Abstract.html#ade540a127da7304f2b7282f4dcaffc7f">More...</a><br /></td></tr>
<tr class="separator:ade540a127da7304f2b7282f4dcaffc7f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316956fea77627a716500a2bbfc1f3b7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a316956fea77627a716500a2bbfc1f3b7">applyOperator</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand, bool leaveEmpty=false) const</td></tr>
<tr class="memdesc:a316956fea77627a716500a2bbfc1f3b7 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the operator on an <b>operand</b>, iif the expression is an operator.  <a href="classcsl_1_1Abstract.html#a316956fea77627a716500a2bbfc1f3b7">More...</a><br /></td></tr>
<tr class="separator:a316956fea77627a716500a2bbfc1f3b7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101219973341a39cf15f07e5e1aa388f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a101219973341a39cf15f07e5e1aa388f">addition_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a101219973341a39cf15f07e5e1aa388f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special addition for Numerical- and Vectorial-types.  <a href="classcsl_1_1Abstract.html#a101219973341a39cf15f07e5e1aa388f">More...</a><br /></td></tr>
<tr class="separator:a101219973341a39cf15f07e5e1aa388f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5ed458ba62f5b4cf61a9e1f8568af1 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4f5ed458ba62f5b4cf61a9e1f8568af1">multiplication_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, bool side=1) const</td></tr>
<tr class="memdesc:a4f5ed458ba62f5b4cf61a9e1f8568af1 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special multiplication for Numerical- and Vectorial-types.  <a href="classcsl_1_1Abstract.html#a4f5ed458ba62f5b4cf61a9e1f8568af1">More...</a><br /></td></tr>
<tr class="separator:a4f5ed458ba62f5b4cf61a9e1f8568af1 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1578c74aee1050b806a67e7a81a67f5c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1578c74aee1050b806a67e7a81a67f5c">division_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a1578c74aee1050b806a67e7a81a67f5c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special division for Numerical- and Polynomial-types. For polynomial, the euclidean division of two polynomials is implemented.  <a href="classcsl_1_1Abstract.html#a1578c74aee1050b806a67e7a81a67f5c">More...</a><br /></td></tr>
<tr class="separator:a1578c74aee1050b806a67e7a81a67f5c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2696a0feb43766ef54e1e3dd3d6d134 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa2696a0feb43766ef54e1e3dd3d6d134">exponentiation_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:aa2696a0feb43766ef54e1e3dd3d6d134 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special exponentiation for Numerical- and Vectorial-types.  <a href="classcsl_1_1Abstract.html#aa2696a0feb43766ef54e1e3dd3d6d134">More...</a><br /></td></tr>
<tr class="separator:aa2696a0feb43766ef54e1e3dd3d6d134 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b77f008f4b95030641224877004f06c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5b77f008f4b95030641224877004f06c">getRegularExpression</a> () const</td></tr>
<tr class="memdesc:a5b77f008f4b95030641224877004f06c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a regular expression from the polynomial, that is a sum where the different powers of the variable appear explicitely.  <a href="classcsl_1_1Abstract.html#a5b77f008f4b95030641224877004f06c">More...</a><br /></td></tr>
<tr class="separator:a5b77f008f4b95030641224877004f06c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83c6a13716688f45b02e6291d39aba inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7b83c6a13716688f45b02e6291d39aba">tensordot</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a7b83c6a13716688f45b02e6291d39aba inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensordot of two <b>Vectorial</b> expressions.  <a href="classcsl_1_1Abstract.html#a7b83c6a13716688f45b02e6291d39aba">More...</a><br /></td></tr>
<tr class="separator:a7b83c6a13716688f45b02e6291d39aba inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc7a46deaa3eaa7593909d74e76d4af inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4cc7a46deaa3eaa7593909d74e76d4af">dot</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a4cc7a46deaa3eaa7593909d74e76d4af inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of two <b>Vectorial</b> expressions.  <a href="classcsl_1_1Abstract.html#a4cc7a46deaa3eaa7593909d74e76d4af">More...</a><br /></td></tr>
<tr class="separator:a4cc7a46deaa3eaa7593909d74e76d4af inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf8154e39ff211b12e6382e675ccaad inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aeaf8154e39ff211b12e6382e675ccaad">getSum</a> () const</td></tr>
<tr class="memdesc:aeaf8154e39ff211b12e6382e675ccaad inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the sum of all elements in the <b>Vectorial</b> object.  <a href="classcsl_1_1Abstract.html#aeaf8154e39ff211b12e6382e675ccaad">More...</a><br /></td></tr>
<tr class="separator:aeaf8154e39ff211b12e6382e675ccaad inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07489d0569bc983718796d21c73f34b3 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a07489d0569bc983718796d21c73f34b3">getProduct</a> () const</td></tr>
<tr class="memdesc:a07489d0569bc983718796d21c73f34b3 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the product of all elements in the <b>Vectorial</b> object.  <a href="classcsl_1_1Abstract.html#a07489d0569bc983718796d21c73f34b3">More...</a><br /></td></tr>
<tr class="separator:a07489d0569bc983718796d21c73f34b3 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0188b049736016c970a2513ed9f6931f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a0188b049736016c970a2513ed9f6931f">getVectorialModulus</a> () const</td></tr>
<tr class="memdesc:a0188b049736016c970a2513ed9f6931f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vectorial modulus of the <b>Vectorial</b> object, that is defined here as the squared root of the sum of element squared. Example: {A_{11}^2+A_{12}^2+}.  <a href="classcsl_1_1Abstract.html#a0188b049736016c970a2513ed9f6931f">More...</a><br /></td></tr>
<tr class="separator:a0188b049736016c970a2513ed9f6931f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcdc11b64c8c515933882168d0792ef inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7dcdc11b64c8c515933882168d0792ef">getSubVectorial</a> (int iExcept) const</td></tr>
<tr class="memdesc:a7dcdc11b64c8c515933882168d0792ef inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="classcsl_1_1Abstract.html#a7dcdc11b64c8c515933882168d0792ef">More...</a><br /></td></tr>
<tr class="separator:a7dcdc11b64c8c515933882168d0792ef inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c50b2663f57d38c1d3ec3cfeaa3ce inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a413c50b2663f57d38c1d3ec3cfeaa3ce">getSubVectorial</a> (int iExcept, int jExcept) const</td></tr>
<tr class="memdesc:a413c50b2663f57d38c1d3ec3cfeaa3ce inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the [iExcept^{th},jExcept^{th}] element (useful for matrices).  <a href="classcsl_1_1Abstract.html#a413c50b2663f57d38c1d3ec3cfeaa3ce">More...</a><br /></td></tr>
<tr class="separator:a413c50b2663f57d38c1d3ec3cfeaa3ce inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f88bae88e30b37cc3a4d4c7a476a992 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a0f88bae88e30b37cc3a4d4c7a476a992">getSubVectorial</a> (const std::vector&lt; int &gt; &amp;exceptions) const</td></tr>
<tr class="memdesc:a0f88bae88e30b37cc3a4d4c7a476a992 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="classcsl_1_1Abstract.html#a0f88bae88e30b37cc3a4d4c7a476a992">More...</a><br /></td></tr>
<tr class="separator:a0f88bae88e30b37cc3a4d4c7a476a992 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7aad9c82bc7fd4a19e495fac3673a9 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ada7aad9c82bc7fd4a19e495fac3673a9"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSubVectorial</b> (const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;keepIndices) const</td></tr>
<tr class="separator:ada7aad9c82bc7fd4a19e495fac3673a9 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d86e688cb7b1e7d7846e14ae5a3e1c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa1d86e688cb7b1e7d7846e14ae5a3e1c"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSubVectorial</b> (std::vector&lt; std::vector&lt; int &gt;&gt;::const_iterator <a class="el" href="classcsl_1_1Abstract.html#aad54ed41b2ce9bad3364fe30ad1a0d71">begin</a>, std::vector&lt; std::vector&lt; int &gt;&gt;::const_iterator <a class="el" href="classcsl_1_1Abstract.html#a61e4e80d998a888a1a74d9ea3e10c0f1">end</a>) const</td></tr>
<tr class="separator:aa1d86e688cb7b1e7d7846e14ae5a3e1c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb08811cf370616477a92075e4a218ee inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aeb08811cf370616477a92075e4a218ee">determinant</a> () const</td></tr>
<tr class="memdesc:aeb08811cf370616477a92075e4a218ee inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the object if it corresponds to a square matrix (or a scalar), 0 else.  <a href="classcsl_1_1Abstract.html#aeb08811cf370616477a92075e4a218ee">More...</a><br /></td></tr>
<tr class="separator:aeb08811cf370616477a92075e4a218ee inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a86d21f5c5f65eb7e524a8f8002c0e7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9a86d21f5c5f65eb7e524a8f8002c0e7">trace</a> () const</td></tr>
<tr class="separator:a9a86d21f5c5f65eb7e524a8f8002c0e7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacab43e551e9259a39a79378373ce49c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aacab43e551e9259a39a79378373ce49c">trace</a> (int axis1, int axis2) const</td></tr>
<tr class="memdesc:aacab43e551e9259a39a79378373ce49c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the trace over the axis <b>axis1</b> and <b>axis2</b> of a tensor. <b>axis1</b> and <b>axis2</b> can be the same, in which case the trace just corresponds to the sum over this particular axis.  <a href="classcsl_1_1Abstract.html#aacab43e551e9259a39a79378373ce49c">More...</a><br /></td></tr>
<tr class="separator:aacab43e551e9259a39a79378373ce49c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e97712696e5c40b28bc1e35987fea94 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1e97712696e5c40b28bc1e35987fea94">transpose</a> () const</td></tr>
<tr class="memdesc:a1e97712696e5c40b28bc1e35987fea94 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the transpose of a 2D matrix.  <a href="classcsl_1_1Abstract.html#a1e97712696e5c40b28bc1e35987fea94">More...</a><br /></td></tr>
<tr class="separator:a1e97712696e5c40b28bc1e35987fea94 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c42723e8bc6334c99f00898cc1d59d7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a8c42723e8bc6334c99f00898cc1d59d7"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hermitian</b> () const</td></tr>
<tr class="separator:a8c42723e8bc6334c99f00898cc1d59d7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faf1ffd8cb3b6c721e128980c0303d8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4faf1ffd8cb3b6c721e128980c0303d8">symmetrise</a> () const</td></tr>
<tr class="memdesc:a4faf1ffd8cb3b6c721e128980c0303d8 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the symmetrization of a 2D matrix.  <a href="classcsl_1_1Abstract.html#a4faf1ffd8cb3b6c721e128980c0303d8">More...</a><br /></td></tr>
<tr class="separator:a4faf1ffd8cb3b6c721e128980c0303d8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd972aed8326d4c13534594e061ee6da inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#acd972aed8326d4c13534594e061ee6da">antisymmetrise</a> () const</td></tr>
<tr class="memdesc:acd972aed8326d4c13534594e061ee6da inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the anti-symmetrization of a 2D matrix.  <a href="classcsl_1_1Abstract.html#acd972aed8326d4c13534594e061ee6da">More...</a><br /></td></tr>
<tr class="separator:acd972aed8326d4c13534594e061ee6da inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b68943aa7ecf60a63af0f2f368eef8f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1b68943aa7ecf60a63af0f2f368eef8f">inverseMatrix</a> () const</td></tr>
<tr class="memdesc:a1b68943aa7ecf60a63af0f2f368eef8f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the inverse of a 2D square matrix. The applied method is: A^{-1} = 1/det(A)*Com(A)^T.  <a href="classcsl_1_1Abstract.html#a1b68943aa7ecf60a63af0f2f368eef8f">More...</a><br /></td></tr>
<tr class="separator:a1b68943aa7ecf60a63af0f2f368eef8f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb26e1382411448ce3c65d50fefd8bb inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="afeb26e1382411448ce3c65d50fefd8bb"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCanonicalPermutation</b> () const</td></tr>
<tr class="separator:afeb26e1382411448ce3c65d50fefd8bb inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d3ab932182226f4670a62bbb22af4e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a61d3ab932182226f4670a62bbb22af4e"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyDiracDelta</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;) const</td></tr>
<tr class="separator:a61d3ab932182226f4670a62bbb22af4e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff2950fc8ca319f87a730450f14545 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a59ff2950fc8ca319f87a730450f14545">operator=</a> (double t_value)</td></tr>
<tr class="memdesc:a59ff2950fc8ca319f87a730450f14545 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the <a class="el" href="classcsl_1_1Abstract.html#aaf7f0692cb84ca861a5b3b641bea518b" title="Sets the value if there is one (for Numerical and Literal valued). ">setValue()</a> function.  <a href="classcsl_1_1Abstract.html#a59ff2950fc8ca319f87a730450f14545">More...</a><br /></td></tr>
<tr class="separator:a59ff2950fc8ca319f87a730450f14545 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8334e14cd5789168b037d3888ed60edd inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a8334e14cd5789168b037d3888ed60edd">operator==</a> (int t_value) const</td></tr>
<tr class="separator:a8334e14cd5789168b037d3888ed60edd inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d929e34039e817e464abc560bd4a9d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a12d929e34039e817e464abc560bd4a9d">operator==</a> (double t_value) const</td></tr>
<tr class="separator:a12d929e34039e817e464abc560bd4a9d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b62a6308638064c42da80e9cc2cb7e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af5b62a6308638064c42da80e9cc2cb7e">operator!=</a> (int t_value) const</td></tr>
<tr class="separator:af5b62a6308638064c42da80e9cc2cb7e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fd1b57df371dac7ccfd5a909620e49 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af4fd1b57df371dac7ccfd5a909620e49">operator!=</a> (double t_value) const</td></tr>
<tr class="separator:af4fd1b57df371dac7ccfd5a909620e49 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fa41a5e014f067395467542ee8831 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aee4fa41a5e014f067395467542ee8831"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>testDummy</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:aee4fa41a5e014f067395467542ee8831 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78f0cce24c93def3050743bc5f2845 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a1f78f0cce24c93def3050743bc5f2845"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:a1f78f0cce24c93def3050743bc5f2845 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed43debcac4a19e0da44986774c522bc inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aed43debcac4a19e0da44986774c522bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:aed43debcac4a19e0da44986774c522bc inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376f08c0aa5ffe783090381d102d3ae inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a2376f08c0aa5ffe783090381d102d3ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> &amp;other) const</td></tr>
<tr class="separator:a2376f08c0aa5ffe783090381d102d3ae inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96de5935a58a96d4c5b1e47966488923 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a96de5935a58a96d4c5b1e47966488923"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a96de5935a58a96d4c5b1e47966488923 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99a619abde7e4c58f39e14d4d20fcf5 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac99a619abde7e4c58f39e14d4d20fcf5">operator!=</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:ac99a619abde7e4c58f39e14d4d20fcf5 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="classcsl_1_1Abstract.html#ac99a619abde7e4c58f39e14d4d20fcf5">More...</a><br /></td></tr>
<tr class="separator:ac99a619abde7e4c58f39e14d4d20fcf5 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45206de7c7773b3cb150451ee3eb379e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a45206de7c7773b3cb150451ee3eb379e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:a45206de7c7773b3cb150451ee3eb379e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3495220202bd417c1b58249c923f39 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0d3495220202bd417c1b58249c923f39"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> &amp;other) const</td></tr>
<tr class="separator:a0d3495220202bd417c1b58249c923f39 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e19587260a07dba65cf2a985e05516b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a6e19587260a07dba65cf2a985e05516b">operator&lt;</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:a6e19587260a07dba65cf2a985e05516b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#a6e19587260a07dba65cf2a985e05516b">More...</a><br /></td></tr>
<tr class="separator:a6e19587260a07dba65cf2a985e05516b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485c6f3e10db539a70416cd0766b117d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a485c6f3e10db539a70416cd0766b117d">operator&gt;</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a485c6f3e10db539a70416cd0766b117d inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#a485c6f3e10db539a70416cd0766b117d">More...</a><br /></td></tr>
<tr class="separator:a485c6f3e10db539a70416cd0766b117d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab305bdf49212f03781e7f98024faeb66 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ab305bdf49212f03781e7f98024faeb66"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:ab305bdf49212f03781e7f98024faeb66 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1660498f2638f5e490d6e512eb32f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a2a1660498f2638f5e490d6e512eb32f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a2a1660498f2638f5e490d6e512eb32f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8883df19d7538b68fa96aadac9dfa9 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4c8883df19d7538b68fa96aadac9dfa9">operator&gt;=</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a4c8883df19d7538b68fa96aadac9dfa9 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#a4c8883df19d7538b68fa96aadac9dfa9">More...</a><br /></td></tr>
<tr class="separator:a4c8883df19d7538b68fa96aadac9dfa9 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcac6df2fd7ac11f336189cf215124b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#afbcac6df2fd7ac11f336189cf215124b">operator&lt;=</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:afbcac6df2fd7ac11f336189cf215124b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#afbcac6df2fd7ac11f336189cf215124b">More...</a><br /></td></tr>
<tr class="separator:afbcac6df2fd7ac11f336189cf215124b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b931f7b159d57bad26ca9c9ea729aa1 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a6b931f7b159d57bad26ca9c9ea729aa1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:a6b931f7b159d57bad26ca9c9ea729aa1 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8e3c4ead67d90e3db5b5fc0c1c1625ba"><td class="memItemLeft" align="right" valign="top"><a id="a8e3c4ead67d90e3db5b5fc0c1c1625ba"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>gatherFactors</b> (csl::vector_expr &amp;factors, csl::vector_expr &amp;arg, bool full) const</td></tr>
<tr class="separator:a8e3c4ead67d90e3db5b5fc0c1c1625ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10df15f107fc56e16061a3e33ae5e6b6"><td class="memItemLeft" align="right" valign="top"><a id="a10df15f107fc56e16061a3e33ae5e6b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearRedundantFactors</b> (csl::vector_expr &amp;factors) const</td></tr>
<tr class="separator:a10df15f107fc56e16061a3e33ae5e6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classcsl_1_1Abstract"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcsl_1_1Abstract')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a></td></tr>
<tr class="memitem:aba5ef083016b2f3d9e6271f864b9b063 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aba5ef083016b2f3d9e6271f864b9b063"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularName</b> (std::string const &amp;name)</td></tr>
<tr class="separator:aba5ef083016b2f3d9e6271f864b9b063 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8421d402d5ba82257188b545e8d668 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a1a8421d402d5ba82257188b545e8d668"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularName</b> (std::string_view name)</td></tr>
<tr class="separator:a1a8421d402d5ba82257188b545e8d668 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aab87c41acafaf1b1837b922495560d inherit pub_static_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a8aab87c41acafaf1b1837b922495560d"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularLiteral</b> (std::string const &amp;name)</td></tr>
<tr class="separator:a8aab87c41acafaf1b1837b922495560d inherit pub_static_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe749450d2e610199801b189dc3d0f8 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a2fe749450d2e610199801b189dc3d0f8"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularLiteral</b> (std::string_view name)</td></tr>
<tr class="separator:a2fe749450d2e610199801b189dc3d0f8 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcsl_1_1AbstractMultiFunc"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcsl_1_1AbstractMultiFunc')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcsl_1_1AbstractMultiFunc.html">csl::AbstractMultiFunc</a></td></tr>
<tr class="memitem:a8e44404eb3e6c23f7c7ddf10cdd3a152 inherit pro_attribs_classcsl_1_1AbstractMultiFunc"><td class="memItemLeft" align="right" valign="top"><a id="a8e44404eb3e6c23f7c7ddf10cdd3a152"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html#a8e44404eb3e6c23f7c7ddf10cdd3a152">argument</a></td></tr>
<tr class="memdesc:a8e44404eb3e6c23f7c7ddf10cdd3a152 inherit pro_attribs_classcsl_1_1AbstractMultiFunc"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::vector containing the arguments. <br /></td></tr>
<tr class="separator:a8e44404eb3e6c23f7c7ddf10cdd3a152 inherit pro_attribs_classcsl_1_1AbstractMultiFunc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Handles a sum, function of multiple arguments. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8b45ce85f4650c5ca71675fe5231efae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b45ce85f4650c5ca71675fe5231efae">&#9670;&nbsp;</a></span>Sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">csl::Sum::Sum </td>
          <td>(</td>
          <td class="paramtype">const csl::vector_expr &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>explicitSum</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes <b>argument</b> to <em>operands</em> (copy each element) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operands</td><td>Operands of the sum, copied in the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a954e6e01884fce66529f78ee92a21c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954e6e01884fce66529f78ee92a21c9c">&#9670;&nbsp;</a></span>Sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">csl::Sum::Sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>leftOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rightOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>explicitSum</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the sum of &amp; leftOperand and <em>rightOperand</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftOperand</td><td>Left operand. </td></tr>
    <tr><td class="paramname">rightOperand</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1620a408e74aa2b452a176f006fb3e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1620a408e74aa2b452a176f006fb3e5c">&#9670;&nbsp;</a></span>askTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Sum::askTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <b>expr</b> can factor <b>*this</b>. </p>
<p>In almost every case this corresponds just to the comparison ** *this == expr**. For <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a>, <a class="el" href="classcsl_1_1Pow.html" title="Handles the exponentiation of one Abstract wrt another. ">Pow</a>, Fraction types (all that are multiplicative) we must check if the factor hides in a product. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Factor to search in the expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is a possible factor. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a27ad666bf7d533607da9675b0c645ee9">csl::Abstract</a>.</p>

</div>
</div>
<a id="af1f3a6d6201fef00ca9d4ad334cd01bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f3a6d6201fef00ca9d4ad334cd01bd">&#9670;&nbsp;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::collect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects terms in sum according to some factors given by the user. </p>
<p>This function allows the factor with some specific scalar variables. For example, <img class="formulaInl" alt="$ ax + ay + by $" src="form_6.png"/> can be factored in two ways. Either with <img class="formulaInl" alt="$ (a, b) $" src="form_7.png"/> which gives <img class="formulaInl" alt="$ a(x+y) + by $" src="form_8.png"/> ; or with <img class="formulaInl" alt="$ (x, y) $" src="form_9.png"/> which gives <img class="formulaInl" alt="$ ax + (a+b)y $" src="form_10.png"/>. With the collect function it is possible to choose precisely the set of variables that will be factored to express results in a standard way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factors</td><td>Factors to search in the expression. </td></tr>
    <tr><td class="paramname">full</td><td>Boolean (default = false) that tells if the collection must be recursive (full expression depth).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The collected expression if modifications have been done. </dd>
<dd>
std::nullopt else.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will probably replace the <a class="el" href="classcsl_1_1Sum.html#af56a4a850dcb91db747ff8ca36f458a2" title="Factors the expr if common factors are found. ">factor()</a> function in the future.</dd>
<dd>
For now, the collect function does not support factorization by indicial tensors, whereas <a class="el" href="classcsl_1_1Sum.html#af56a4a850dcb91db747ff8ca36f458a2" title="Factors the expr if common factors are found. ">factor()</a> does. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1AbstractMultiFunc.html#accd66bc16179cf88684a6db68e277921">csl::AbstractMultiFunc</a>.</p>

</div>
</div>
<a id="a7dd23134290bcfeffb529e2c03ca17ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd23134290bcfeffb529e2c03ca17ff">&#9670;&nbsp;</a></span>derive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::derive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derives the sum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argument of the derivation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the derivatives of the arguments </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aecab8c872023a2d0771e7e4f83bb05f8">csl::Abstract</a>.</p>

</div>
</div>
<a id="af3c54e000687a23ad678c77760ffaaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c54e000687a23ad678c77760ffaaf1">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::evaluate </td>
          <td>(</td>
          <td class="paramtype">csl::eval::mode&#160;</td>
          <td class="paramname"><em>user_mode</em> = <code>csl::eval::base</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>Replaces all variables by their value and evaluating. This function must be used instead of <a class="el" href="classcsl_1_1Sum.html#aa8f5632f8b3be2615f29085195c7abe2" title="Return the sum of all the arguments. ">evaluateScalar()</a> when treating not only real scalars.* In particular (x=2, y=3) x+iy evaluates to 3+ 3i whereas <a class="el" href="classcsl_1_1Sum.html#aa8f5632f8b3be2615f29085195c7abe2" title="Return the sum of all the arguments. ">evaluateScalar()</a> would return 3. </p><dl class="section return"><dt>Returns</dt><dd>The abstract result of the evaluation. </dd></dl>

<p>Implements <a class="el" href="classcsl_1_1Abstract.html#aa2d5a98ec433dad08613083c12f587cd">csl::Abstract</a>.</p>

</div>
</div>
<a id="aa8f5632f8b3be2615f29085195c7abe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f5632f8b3be2615f29085195c7abe2">&#9670;&nbsp;</a></span>evaluateScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double csl::Sum::evaluateScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <b>sum</b> of all the arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of the scalar evaluation of all the arguments. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to be justified, all the arguments must be <b>scalar</b> and <b>real</b>. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a543d5a4f0432e166b492ad28a860a65f">csl::Abstract</a>.</p>

</div>
</div>
<a id="af56a4a850dcb91db747ff8ca36f458a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56a4a850dcb91db747ff8ca36f458a2">&#9670;&nbsp;</a></span>factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::factor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factors the expr if common factors are found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full</td><td>If <b>true</b> factors recursively all the arguments. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1AbstractMultiFunc.html#ad9eed372c276bc55ce8614a94962fef6">csl::AbstractMultiFunc</a>.</p>

</div>
</div>
<a id="aeb31f0009bdb90913b98c693578b54a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb31f0009bdb90913b98c693578b54a3">&#9670;&nbsp;</a></span>factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factors the expr by expr if it is a common factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Factor. </td></tr>
    <tr><td class="paramname">full</td><td>If <b>true</b> factors recursively all the arguments. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a71ffe88901a200f59bdb88d4adf09a44">csl::AbstractMultiFunc</a>.</p>

</div>
</div>
<a id="adcc92cb4e44f443feb122841ff960f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc92cb4e44f443feb122841ff960f5e">&#9670;&nbsp;</a></span>getAlternateForms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::Sum::getAlternateForms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x). </p>
<p>Those alternate forms are then compared in terms of simplicity, this allows automatic simplification. Alternates are tried to simplify, and the bests are chosed. More details and algorithms in file alternateForms.cpp. </p><dl class="section return"><dt>Returns</dt><dd>A std::vector containing the alternate forms of the expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#afcbcb9dd55c73dbcbfe8c091d3e5c02e">csl::Abstract</a>.</p>

</div>
</div>
<a id="adc1cd9a04f2299205aa8d896ba03482b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1cd9a04f2299205aa8d896ba03482b">&#9670;&nbsp;</a></span>getComplexArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::getComplexArgument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument part of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a9cc64c66894acafc1f069dc40072084b">csl::Abstract</a>.</p>

</div>
</div>
<a id="a6a358933e479aa4dcb68c9fff7a4dcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a358933e479aa4dcb68c9fff7a4dcc3">&#9670;&nbsp;</a></span>getComplexModulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::getComplexModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The modulus part of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a859f792aec52ba1fe1181f81d1cc3451">csl::Abstract</a>.</p>

</div>
</div>
<a id="ab2e21f4faf128cc9d9e471370def40e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e21f4faf128cc9d9e471370def40e7">&#9670;&nbsp;</a></span>getFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::Sum::getFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all the possible factors. </p>
<dl class="section return"><dt>Returns</dt><dd>The concatenation of all possible factors for the arguments. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#ac34c9c6f05e692faeed2f030514787ad">csl::Abstract</a>.</p>

</div>
</div>
<a id="a91c2be7f869326606fba475ea557b409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c2be7f869326606fba475ea557b409">&#9670;&nbsp;</a></span>getImaginaryPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Sum::getImaginaryPart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a43f44bbb3685fc9f4a0402223b2e1004">csl::Abstract</a>.</p>

</div>
</div>
<a id="ae5a42358fbbca3043d216049222455d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a42358fbbca3043d216049222455d6">&#9670;&nbsp;</a></span>getNumericalFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Sum::getNumericalFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The numerical factor of the sum. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aad25c117c8dfc4d9718ba41e8d3f33a6">csl::Abstract</a>.</p>

</div>
</div>
<a id="abd3105d37243fd781e0b2da2de60c295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3105d37243fd781e0b2da2de60c295">&#9670;&nbsp;</a></span>getParity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Sum::getParity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>t_variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parity property of the expression with respect to <b>t_variable</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_variable.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the expression is <b>even</b> in <b>t_variable</b>. </dd>
<dd>
-1 if the expression is <b>odd</b> in <b>t_variable</b>. </dd>
<dd>
0 else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aea8459b3206eb3a2297eeea7688e9520">csl::Abstract</a>.</p>

</div>
</div>
<a id="a340d0daf8560d7d9ec73a30a0e5b4fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340d0daf8560d7d9ec73a30a0e5b4fce">&#9670;&nbsp;</a></span>getRealPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::getRealPart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The real part of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a415f64fdddaae445014d5e052956f889">csl::Abstract</a>.</p>

</div>
</div>
<a id="aa265b9928bffd0aefe456d9dbe3637b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa265b9928bffd0aefe456d9dbe3637b8">&#9670;&nbsp;</a></span>getTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Sum::getTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The sum divided by its factor. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a1d36e7a5acc50766d5cd3f6d59df978d">csl::Abstract</a>.</p>

</div>
</div>
<a id="afdde4c81bf81217accd1b02b8e2b4dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdde4c81bf81217accd1b02b8e2b4dbf">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a> csl::Sum::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>type</b> of a <a class="el" href="classcsl_1_1Sum.html" title="Handles a sum, function of multiple arguments. ">Sum</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>10 </dd></dl>

<p>Implements <a class="el" href="classcsl_1_1Abstract.html#aa781456c3f801b37ce169c83514c51c1">csl::Abstract</a>.</p>

</div>
</div>
<a id="a8967f1bfbae1e49e21bd5f79939b2a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8967f1bfbae1e49e21bd5f79939b2a63">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Sum::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>side</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an expression in a sum or a product. </p>
<p>Allows to insert an element in a sum or product without comparing all existing terms. This saves time when inserting element by element. The <b>side</b> parameter allows to insert to the left (side = 0) or to the right (side = 1) in products (useful when considering non commutating expressions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to insert. </td></tr>
    <tr><td class="paramname">side</td><td>Side of insertion for <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a> expressions. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a5437e7f685edf8549e6d3b34572343f8">csl::Abstract</a>.</p>

</div>
</div>
<a id="ad9ce7a5183d105402cdafab290b93c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ce7a5183d105402cdafab290b93c91">&#9670;&nbsp;</a></span>isIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool csl::Sum::isIndexed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is indexed. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1AbstractMultiFunc.html#aee96fe96e6cf30e1022ee8f489884aa5">csl::AbstractMultiFunc</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1ISum.html#a1b7f9344411c6dbf4e132798833c6a68">csl::ISum</a>.</p>

</div>
</div>
<a id="ab057bcec5aad014c3ac4d1ab847c9ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab057bcec5aad014c3ac4d1ab847c9ada">&#9670;&nbsp;</a></span>mergeTerms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Sum::mergeTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge identical terms. </p>
<p>When identical terms (identical to a numerical factor) appear this function merge them in the same term. Example: x+y+2*x -&gt; 3*x+y. </p><dl class="section return"><dt>Returns</dt><dd><b>True</b> if terms have been merged. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="ae8309f4d05302f47272a5e2ba0e6507c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8309f4d05302f47272a5e2ba0e6507c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Sum::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another. </p>
<p>Here if two Abstracts have the same name, the function will return <b>true</b> even if they are <b>not</b> <b>mathematically</b> <b>equal</b>. So beware not to name different things the same way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two Abstracts are the same (or have the same name). </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Implements <a class="el" href="classcsl_1_1Abstract.html#a3775f3088e784cc924cb7d26e118660e">csl::Abstract</a>.</p>

</div>
</div>
<a id="a1ed27fa96664bb2d126e41b866e04a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed27fa96664bb2d126e41b866e04a5b">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Sum::print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lib</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays the abstract in standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcsl_1_1Abstract.html#a9995ebe97bf73c098ee1dc18b7837660">csl::Abstract</a>.</p>

</div>
</div>
<a id="a98d6f1d250495606344f29e78ba47ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d6f1d250495606344f29e78ba47ee0">&#9670;&nbsp;</a></span>printLaTeX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string csl::Sum::printLaTeX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a LaTeX output for the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string corresponding to the LaTeX output. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aa067d4a97135bfe2052a7e21c28f75be">csl::Abstract</a>.</p>

</div>
</div>
<a id="a37d045772a3fbedf76bf72588ee2e212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d045772a3fbedf76bf72588ee2e212">&#9670;&nbsp;</a></span>suppressTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Sum::suppressTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a factor from an expr, that must have been determined before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Expression to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expr in which <b>factor</b> has been removed </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a43520e1d6d5fdad9b50f77c6e027f928">csl::Abstract</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="operations_8h_source.html">operations.h</a></li>
<li>src/alternateForms.cpp</li>
<li>src/operations.cpp</li>
<li>src/simplification.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
