<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSL: csl::TensorElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image.png" href="../../../logo-marty.png"/>
<link href="style_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
      <a href="https://marty.in2p3.fr"><img alt="Logo" src="Logo1.svg" height=100px/></a></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">
       Documentation of <i><b>CSL</b></i>
   </div>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecsl.html">csl</a></li><li class="navelem"><a class="el" href="classcsl_1_1TensorElement.html">TensorElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">csl::TensorElement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Specialization of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> for Indicial tensor. Building block carrying indices, and respecting Einstein's summation convention.  
 <a href="classcsl_1_1TensorElement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="indicial_8h_source.html">indicial.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for csl::TensorElement:</div>
<div class="dyncontent">
<div class="center"><img src="classcsl_1_1TensorElement__inherit__graph.png" border="0" usemap="#csl_1_1TensorElement_inherit__map" alt="Inheritance graph"/></div>
<map name="csl_1_1TensorElement_inherit__map" id="csl_1_1TensorElement_inherit__map">
<area shape="rect" id="node6" href="classcsl_1_1TensorFieldElement.html" title="csl::TensorFieldElement" alt="" coords="13,379,175,405"/>
<area shape="rect" id="node2" href="classcsl_1_1AbstractElement.html" title="Base class for all elements. Objects that are constructed by a parent (see AbstractParent) when the u..." alt="" coords="22,229,166,256"/>
<area shape="rect" id="node3" href="classcsl_1_1Complexified.html" title="csl::Complexified" alt="" coords="33,155,155,181"/>
<area shape="rect" id="node4" href="classcsl_1_1AbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e..." alt="" coords="7,80,181,107"/>
<area shape="rect" id="node5" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. " alt="" coords="46,5,142,32"/>
<area shape="rect" id="node7" href="classcsl_1_1Operator.html" title="csl::Operator\&lt; TensorField\lElement \&gt;" alt="" coords="5,453,183,495"/>
<area shape="rect" id="node8" href="classcsl_1_1TDerivativeElement.html" title="csl::TDerivativeElement" alt="" coords="13,543,175,569"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b29839ab99dd106e336ce900023d18a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a1b29839ab99dd106e336ce900023d18a">TensorElement</a> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;t_index, const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;t_parent)</td></tr>
<tr class="memdesc:a1b29839ab99dd106e336ce900023d18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor called by an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a>, for a tensor with one index.  <a href="#a1b29839ab99dd106e336ce900023d18a">More...</a><br /></td></tr>
<tr class="separator:a1b29839ab99dd106e336ce900023d18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2169c4eabe165be2f0c455f658a0036"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#ac2169c4eabe165be2f0c455f658a0036">TensorElement</a> (const std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;indices, const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;t_parent)</td></tr>
<tr class="memdesc:ac2169c4eabe165be2f0c455f658a0036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor called by an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a>, for a tensor with several indices.  <a href="#ac2169c4eabe165be2f0c455f658a0036">More...</a><br /></td></tr>
<tr class="separator:ac2169c4eabe165be2f0c455f658a0036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bba3e8ce7e864a2921ad91e4019454c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a3bba3e8ce7e864a2921ad91e4019454c">TensorElement</a> (const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;indices, const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;t_parent)</td></tr>
<tr class="memdesc:a3bba3e8ce7e864a2921ad91e4019454c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor called by an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a>, for a tensor with several indices.  <a href="#a3bba3e8ce7e864a2921ad91e4019454c">More...</a><br /></td></tr>
<tr class="separator:a3bba3e8ce7e864a2921ad91e4019454c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d45c8d308213ea65d46f9aeab883d9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a4d45c8d308213ea65d46f9aeab883d9f">TensorElement</a> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *&amp;expression)</td></tr>
<tr class="memdesc:a4d45c8d308213ea65d46f9aeab883d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from an Abstract*. Works only if the pointer points to another <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>.  <a href="#a4d45c8d308213ea65d46f9aeab883d9f">More...</a><br /></td></tr>
<tr class="separator:a4d45c8d308213ea65d46f9aeab883d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f78788e311f00a646e933b102fe365c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a4f78788e311f00a646e933b102fe365c">TensorElement</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="memdesc:a4f78788e311f00a646e933b102fe365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>. Works only if the pointer points to another <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>.  <a href="#a4f78788e311f00a646e933b102fe365c">More...</a><br /></td></tr>
<tr class="separator:a4f78788e311f00a646e933b102fe365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c246057031fbc18868bac66d13be37c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a1c246057031fbc18868bac66d13be37c">getPrimaryType</a> () const override</td></tr>
<tr class="memdesc:a1c246057031fbc18868bac66d13be37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>primary</b> <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a1c246057031fbc18868bac66d13be37c">More...</a><br /></td></tr>
<tr class="separator:a1c246057031fbc18868bac66d13be37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a6d8fc44218dcade0332e215f4b653"><td class="memItemLeft" align="right" valign="top"><a id="ae7a6d8fc44218dcade0332e215f4b653"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>memoryOverhead</b> () const override</td></tr>
<tr class="separator:ae7a6d8fc44218dcade0332e215f4b653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc36470e69d6edf43f6dd7b6db0365d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#acc36470e69d6edf43f6dd7b6db0365d2">isIndexed</a> () const override</td></tr>
<tr class="separator:acc36470e69d6edf43f6dd7b6db0365d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddd03efb94ea0017def76cd6777f745"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a5ddd03efb94ea0017def76cd6777f745">getNIndices</a> () const override</td></tr>
<tr class="separator:a5ddd03efb94ea0017def76cd6777f745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca07618e533c2ca4b4cc3646195a64d"><td class="memItemLeft" align="right" valign="top"><a id="a1ca07618e533c2ca4b4cc3646195a64d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetIndexStructure</b> () override</td></tr>
<tr class="separator:a1ca07618e533c2ca4b4cc3646195a64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc05ca45a03e8a7f8459812e07b85f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a3dc05ca45a03e8a7f8459812e07b85f6">getIndexStructure</a> () const override</td></tr>
<tr class="separator:a3dc05ca45a03e8a7f8459812e07b85f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddd0189c29204560dbdc6ed86b1e028"><td class="memItemLeft" align="right" valign="top"><a id="a0ddd0189c29204560dbdc6ed86b1e028"></a>
const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructureView</b> () const override</td></tr>
<tr class="separator:a0ddd0189c29204560dbdc6ed86b1e028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e2787ed23c1fc5a461d10124221c47"><td class="memItemLeft" align="right" valign="top"><a id="a34e2787ed23c1fc5a461d10124221c47"></a>
<a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructureView</b> () override</td></tr>
<tr class="separator:a34e2787ed23c1fc5a461d10124221c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1ac409b891dd033c1792f5473d8d10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#acd1ac409b891dd033c1792f5473d8d10">compareWithDummy</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, std::map&lt; <a class="el" href="classcsl_1_1Index.html">Index</a>, <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;constraints, bool keepAllCosntraints=false) const override</td></tr>
<tr class="memdesc:acd1ac409b891dd033c1792f5473d8d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr.  <a href="#acd1ac409b891dd033c1792f5473d8d10">More...</a><br /></td></tr>
<tr class="separator:acd1ac409b891dd033c1792f5473d8d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b99f83fdff13fb508ea8e671d4dc834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a7b99f83fdff13fb508ea8e671d4dc834">getType</a> () const override</td></tr>
<tr class="memdesc:a7b99f83fdff13fb508ea8e671d4dc834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a7b99f83fdff13fb508ea8e671d4dc834">More...</a><br /></td></tr>
<tr class="separator:a7b99f83fdff13fb508ea8e671d4dc834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684ed9584f9bbe4ffc1e842b84a05ed0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a684ed9584f9bbe4ffc1e842b84a05ed0">getComplexConjugate</a> () const override</td></tr>
<tr class="memdesc:a684ed9584f9bbe4ffc1e842b84a05ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the complex conjugate of the expression.  <a href="#a684ed9584f9bbe4ffc1e842b84a05ed0">More...</a><br /></td></tr>
<tr class="separator:a684ed9584f9bbe4ffc1e842b84a05ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38b54f3efd6b9950b6d3334a224caa1"><td class="memItemLeft" align="right" valign="top"><a id="ab38b54f3efd6b9950b6d3334a224caa1"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHermitianConjugate</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *space) const override</td></tr>
<tr class="separator:ab38b54f3efd6b9950b6d3334a224caa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e1379a5287fec9bb607c4bc56c0bfb"><td class="memItemLeft" align="right" valign="top"><a id="a04e1379a5287fec9bb607c4bc56c0bfb"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHermitianConjugate</b> (const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces) const override</td></tr>
<tr class="separator:a04e1379a5287fec9bb607c4bc56c0bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47bc7e79e284964b2a8447bf917f48f"><td class="memItemLeft" align="right" valign="top"><a id="ae47bc7e79e284964b2a8447bf917f48f"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTransposed</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *space, bool applyProp=true) const override</td></tr>
<tr class="separator:ae47bc7e79e284964b2a8447bf917f48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a19925dc38bd178b26f9f3c4920e494"><td class="memItemLeft" align="right" valign="top"><a id="a8a19925dc38bd178b26f9f3c4920e494"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTransposed</b> (const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;t_spaces, bool applyProp=true) const override</td></tr>
<tr class="separator:a8a19925dc38bd178b26f9f3c4920e494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029c4358822daed54f4f775032896790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a029c4358822daed54f4f775032896790">getIndex</a> (int i) const override</td></tr>
<tr class="separator:a029c4358822daed54f4f775032896790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec375934423dbb60f6d00ea13ec7f80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a6ec375934423dbb60f6d00ea13ec7f80">askTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool exact=false) const override</td></tr>
<tr class="memdesc:a6ec375934423dbb60f6d00ea13ec7f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the term <b>expr</b> can be factorized out from the <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>, i.e. if <b>expr</b> is equal to the tensor to (may be) a renaming of index.  <a href="#a6ec375934423dbb60f6d00ea13ec7f80">More...</a><br /></td></tr>
<tr class="separator:a6ec375934423dbb60f6d00ea13ec7f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ad4f8a47af9ea009bcea3385e45bc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a14ad4f8a47af9ea009bcea3385e45bc3">dependsOn</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:a14ad4f8a47af9ea009bcea3385e45bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if the expression depends on <b>expr</b>.  <a href="#a14ad4f8a47af9ea009bcea3385e45bc3">More...</a><br /></td></tr>
<tr class="separator:a14ad4f8a47af9ea009bcea3385e45bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016485a4c1fe60991263a4dea94eed6e"><td class="memItemLeft" align="right" valign="top"><a id="a016485a4c1fe60991263a4dea94eed6e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dependsOn</b> (<a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> t_parent) const override</td></tr>
<tr class="separator:a016485a4c1fe60991263a4dea94eed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a5c9686859930af78f51a85b31160d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a22a5c9686859930af78f51a85b31160d">dependsExplicitlyOn</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:a22a5c9686859930af78f51a85b31160d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if <b>expr</b> is present in the expression.  <a href="#a22a5c9686859930af78f51a85b31160d">More...</a><br /></td></tr>
<tr class="separator:a22a5c9686859930af78f51a85b31160d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab3f38235ce39d3d2f1361eba25fb3e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classcsl_1_1Equation.html">Equation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a8ab3f38235ce39d3d2f1361eba25fb3e">getProperties</a> () const override</td></tr>
<tr class="separator:a8ab3f38235ce39d3d2f1361eba25fb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ced3cf2d59c5ae12d9844a81877ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#ad5ced3cf2d59c5ae12d9844a81877ae9">addProperty</a> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *property) override</td></tr>
<tr class="memdesc:ad5ced3cf2d59c5ae12d9844a81877ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a property to the object.  <a href="#ad5ced3cf2d59c5ae12d9844a81877ae9">More...</a><br /></td></tr>
<tr class="separator:ad5ced3cf2d59c5ae12d9844a81877ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74f724e7aa9bdf2778767aca7eba51b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#aa74f724e7aa9bdf2778767aca7eba51b">removeProperty</a> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *property) override</td></tr>
<tr class="memdesc:aa74f724e7aa9bdf2778767aca7eba51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a property to the object.  <a href="#aa74f724e7aa9bdf2778767aca7eba51b">More...</a><br /></td></tr>
<tr class="separator:aa74f724e7aa9bdf2778767aca7eba51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d1474eb8d1c53835ffb3891e01b020"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#ad9d1474eb8d1c53835ffb3891e01b020">checkIndexStructure</a> (const std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;t_index) const override</td></tr>
<tr class="memdesc:ad9d1474eb8d1c53835ffb3891e01b020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="#ad9d1474eb8d1c53835ffb3891e01b020">More...</a><br /></td></tr>
<tr class="separator:ad9d1474eb8d1c53835ffb3891e01b020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7c1c3fb0105a70a1c73db895e0317"><td class="memItemLeft" align="right" valign="top"><a id="ab0c7c1c3fb0105a70a1c73db895e0317"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>selfCheckIndexStructure</b> ()</td></tr>
<tr class="separator:ab0c7c1c3fb0105a70a1c73db895e0317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fe69a766b8eade9d5de6cbea8054a6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a02fe69a766b8eade9d5de6cbea8054a6">replaceIndex</a> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;indexToReplace, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;newIndex, bool refresh=true) const override</td></tr>
<tr class="memdesc:a02fe69a766b8eade9d5de6cbea8054a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For indicial expressions, this function searches <b>indexToContract</b> and replaces it with newIndex.  <a href="#a02fe69a766b8eade9d5de6cbea8054a6">More...</a><br /></td></tr>
<tr class="separator:a02fe69a766b8eade9d5de6cbea8054a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad3c1eabb60fb445f9054699f9d949d"><td class="memItemLeft" align="right" valign="top"><a id="a9ad3c1eabb60fb445f9054699f9d949d"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>replaceIndices</b> (std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; const &amp;indexToReplace, std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; const &amp;newIndex, bool refresh=true, bool flipped=false) const override</td></tr>
<tr class="separator:a9ad3c1eabb60fb445f9054699f9d949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16558db6dbbfcf52c37b52f8a883b5a6"><td class="memItemLeft" align="right" valign="top"><a id="a16558db6dbbfcf52c37b52f8a883b5a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceIndexInPlace</b> (<a class="el" href="classcsl_1_1Index.html">Index</a> const &amp;oldIndex, <a class="el" href="classcsl_1_1Index.html">Index</a> const &amp;newIndex) override</td></tr>
<tr class="separator:a16558db6dbbfcf52c37b52f8a883b5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb86902ebefde4cc742d9b043186be3"><td class="memItemLeft" align="right" valign="top"><a id="a6cb86902ebefde4cc742d9b043186be3"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>breakSpace</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *brokenSpace, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;newSpaces, const std::vector&lt; std::string &gt; &amp;indexNames) const override</td></tr>
<tr class="separator:a6cb86902ebefde4cc742d9b043186be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387f69126ae40d711755945ef023de92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a387f69126ae40d711755945ef023de92">setIndexStructure</a> (const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;t_index) override</td></tr>
<tr class="memdesc:a387f69126ae40d711755945ef023de92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the index structure of the object, that must be an <b>Indicial</b> expression.  <a href="#a387f69126ae40d711755945ef023de92">More...</a><br /></td></tr>
<tr class="separator:a387f69126ae40d711755945ef023de92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511992d33dc54c1fb8d0c4c17afa5f8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a511992d33dc54c1fb8d0c4c17afa5f8c">hasContractionProperty</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B) const override</td></tr>
<tr class="memdesc:a511992d33dc54c1fb8d0c4c17afa5f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells (for an Indicial type) if there is a special contraction property with <b>B</b>.  <a href="#a511992d33dc54c1fb8d0c4c17afa5f8c">More...</a><br /></td></tr>
<tr class="separator:a511992d33dc54c1fb8d0c4c17afa5f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1b1ae7f3655cccd70bf09a60075b7b"><td class="memItemLeft" align="right" valign="top"><a id="a5f1b1ae7f3655cccd70bf09a60075b7b"></a>
std::vector&lt; <a class="el" href="classcsl_1_1ContractionChain.html">ContractionChain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getContractionProperties</b> () const override</td></tr>
<tr class="separator:a5f1b1ae7f3655cccd70bf09a60075b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a301cd1beb0eecde2b83c1ca6167c59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a2a301cd1beb0eecde2b83c1ca6167c59">contraction</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B) const override</td></tr>
<tr class="memdesc:a2a301cd1beb0eecde2b83c1ca6167c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a special contraction of indices. Before calling this function we must check that there is indeed a contraction by calling the function <a class="el" href="classcsl_1_1TensorElement.html#a511992d33dc54c1fb8d0c4c17afa5f8c" title="Tells (for an Indicial type) if there is a special contraction property with B. ">hasContractionProperty()</a>.  <a href="#a2a301cd1beb0eecde2b83c1ca6167c59">More...</a><br /></td></tr>
<tr class="separator:a2a301cd1beb0eecde2b83c1ca6167c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6f22178e26a8cc694ae2ffc01c2075"><td class="memItemLeft" align="right" valign="top"><a id="acb6f22178e26a8cc694ae2ffc01c2075"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasChainContractionProperty</b> () const override</td></tr>
<tr class="separator:acb6f22178e26a8cc694ae2ffc01c2075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f100f8c15bee5c29d97d40549a6e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#ad6f100f8c15bee5c29d97d40549a6e18">applyPermutation</a> (const <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &amp;<a class="el" href="namespacecsl.html#ad16a083cc7c50de69d67b66c20e030f2">permutations</a>) const</td></tr>
<tr class="memdesc:ad6f100f8c15bee5c29d97d40549a6e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a permutation of the indices on a copy of the <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>, and returns it.  <a href="#ad6f100f8c15bee5c29d97d40549a6e18">More...</a><br /></td></tr>
<tr class="separator:ad6f100f8c15bee5c29d97d40549a6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f1ab4f63aa28f3c759a666fb15636a"><td class="memItemLeft" align="right" valign="top">csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#aa0f1ab4f63aa28f3c759a666fb15636a">getPermutations</a> (bool optimize=true) const override</td></tr>
<tr class="memdesc:aa0f1ab4f63aa28f3c759a666fb15636a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::vector of all possible permutations of an <b>Indicial</b> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object.  <a href="#aa0f1ab4f63aa28f3c759a666fb15636a">More...</a><br /></td></tr>
<tr class="separator:aa0f1ab4f63aa28f3c759a666fb15636a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0916129965c1d6117aa613fa8c2b42ea"><td class="memItemLeft" align="right" valign="top">csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a0916129965c1d6117aa613fa8c2b42ea">getAlternateForms</a> () const override</td></tr>
<tr class="memdesc:a0916129965c1d6117aa613fa8c2b42ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x).  <a href="#a0916129965c1d6117aa613fa8c2b42ea">More...</a><br /></td></tr>
<tr class="separator:a0916129965c1d6117aa613fa8c2b42ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f8f7e5b89936e1fa39661b1975c3ce"><td class="memItemLeft" align="right" valign="top"><a id="ad6f8f7e5b89936e1fa39661b1975c3ce"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCanonicalPermutation</b> () const override</td></tr>
<tr class="separator:ad6f8f7e5b89936e1fa39661b1975c3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e94f9e6ad8f67fafb25268c64512fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a94e94f9e6ad8f67fafb25268c64512fa">print</a> (int mode=0, std::ostream &amp;out=std::cout, bool lib=false) const override</td></tr>
<tr class="memdesc:a94e94f9e6ad8f67fafb25268c64512fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the abstract in standard output.  <a href="#a94e94f9e6ad8f67fafb25268c64512fa">More...</a><br /></td></tr>
<tr class="separator:a94e94f9e6ad8f67fafb25268c64512fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c28c7b5335fef612bce15a2a3e64a0c"><td class="memItemLeft" align="right" valign="top"><a id="a8c28c7b5335fef612bce15a2a3e64a0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printCode</b> (int mode=0, std::ostream &amp;out=std::cout) const override</td></tr>
<tr class="separator:a8c28c7b5335fef612bce15a2a3e64a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4794abc02ba5d8f80f76f64e9cab9c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a5e4794abc02ba5d8f80f76f64e9cab9c">printLaTeX</a> (int mode=0) const override</td></tr>
<tr class="memdesc:a5e4794abc02ba5d8f80f76f64e9cab9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a LaTeX output for the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a5e4794abc02ba5d8f80f76f64e9cab9c">More...</a><br /></td></tr>
<tr class="separator:a5e4794abc02ba5d8f80f76f64e9cab9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af028569513793f435ffbf644c0cd363f"><td class="memItemLeft" align="right" valign="top"><a id="af028569513793f435ffbf644c0cd363f"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">Parent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSubSymbols</b> () const override</td></tr>
<tr class="separator:af028569513793f435ffbf644c0cd363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1fc7737cce9da527d3796d2fd711d8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a7a1fc7737cce9da527d3796d2fd711d8">derive</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:a7a1fc7737cce9da527d3796d2fd711d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another.  <a href="#a7a1fc7737cce9da527d3796d2fd711d8">More...</a><br /></td></tr>
<tr class="separator:a7a1fc7737cce9da527d3796d2fd711d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa0e8d228945bad2ef6a8474a6df0c0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#aaaa0e8d228945bad2ef6a8474a6df0c0">evaluate</a> (csl::eval::mode user_mode=csl::eval::base) const override</td></tr>
<tr class="memdesc:aaaa0e8d228945bad2ef6a8474a6df0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#aaaa0e8d228945bad2ef6a8474a6df0c0">More...</a><br /></td></tr>
<tr class="separator:aaaa0e8d228945bad2ef6a8474a6df0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089c8106691497aa93d1c1f684752110"><td class="memItemLeft" align="right" valign="top"><a id="a089c8106691497aa93d1c1f684752110"></a>
unique_Expr&#160;</td><td class="memItemRight" valign="bottom"><b>copy_unique</b> () const override</td></tr>
<tr class="separator:a089c8106691497aa93d1c1f684752110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddb4d5269b0b77fa8a9361ec0ecd281"><td class="memItemLeft" align="right" valign="top"><a id="aaddb4d5269b0b77fa8a9361ec0ecd281"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>refresh</b> () const override</td></tr>
<tr class="separator:aaddb4d5269b0b77fa8a9361ec0ecd281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dbe5ebe94a2c21e0a8a195730820c4"><td class="memItemLeft" align="right" valign="top"><a id="ad0dbe5ebe94a2c21e0a8a195730820c4"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deepRefresh</b> () const override</td></tr>
<tr class="separator:ad0dbe5ebe94a2c21e0a8a195730820c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ada509cc19d2040553f8f40621914db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a6ada509cc19d2040553f8f40621914db">operator==</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const override</td></tr>
<tr class="memdesc:a6ada509cc19d2040553f8f40621914db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="#a6ada509cc19d2040553f8f40621914db">More...</a><br /></td></tr>
<tr class="separator:a6ada509cc19d2040553f8f40621914db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154adda009ceab9ade7bce56d7907728"><td class="memItemLeft" align="right" valign="top"><a id="a154adda009ceab9ade7bce56d7907728"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *expr) const override</td></tr>
<tr class="separator:a154adda009ceab9ade7bce56d7907728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcsl_1_1AbstractElement"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcsl_1_1AbstractElement')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcsl_1_1AbstractElement.html">csl::AbstractElement</a></td></tr>
<tr class="memitem:a12ebb2cd662c44ca2e60106d630dbc48 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#a12ebb2cd662c44ca2e60106d630dbc48">AbstractElement</a> ()</td></tr>
<tr class="separator:a12ebb2cd662c44ca2e60106d630dbc48 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b37b4752b24ab6cb0a29dc3329eea4 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#a90b37b4752b24ab6cb0a29dc3329eea4">AbstractElement</a> (const <a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> &gt; &amp;t_parent)</td></tr>
<tr class="memdesc:a90b37b4752b24ab6cb0a29dc3329eea4 inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intializes the parent and no name.  <a href="classcsl_1_1AbstractElement.html#a90b37b4752b24ab6cb0a29dc3329eea4">More...</a><br /></td></tr>
<tr class="separator:a90b37b4752b24ab6cb0a29dc3329eea4 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ee7c198c82450d17ce0f08df2bef00 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top"><a id="a96ee7c198c82450d17ce0f08df2bef00"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#a96ee7c198c82450d17ce0f08df2bef00">~AbstractElement</a> ()</td></tr>
<tr class="memdesc:a96ee7c198c82450d17ce0f08df2bef00 inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a96ee7c198c82450d17ce0f08df2bef00 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e50d48ea0ee472c5c07f3985cc6c641 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Parent.html">Parent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#a9e50d48ea0ee472c5c07f3985cc6c641">getParent</a> () const override</td></tr>
<tr class="separator:a9e50d48ea0ee472c5c07f3985cc6c641 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde43ab4cab544c3c0aa0d695e67b4ad inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top"><a id="acde43ab4cab544c3c0aa0d695e67b4ad"></a>
<a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getParent_info</b> () const override</td></tr>
<tr class="separator:acde43ab4cab544c3c0aa0d695e67b4ad inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80699e259632a43c4f69a125b64ae30 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#ae80699e259632a43c4f69a125b64ae30">getName</a> () const override</td></tr>
<tr class="memdesc:ae80699e259632a43c4f69a125b64ae30 inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>'s name.  <a href="classcsl_1_1AbstractElement.html#ae80699e259632a43c4f69a125b64ae30">More...</a><br /></td></tr>
<tr class="separator:ae80699e259632a43c4f69a125b64ae30 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d4ceaa06fb30861b1ce4336a465f54 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top"><a id="ad8d4ceaa06fb30861b1ce4336a465f54"></a>
std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getLatexName</b> () const override</td></tr>
<tr class="separator:ad8d4ceaa06fb30861b1ce4336a465f54 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3418bd6d3548316885c8bda0a7464b8 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#ab3418bd6d3548316885c8bda0a7464b8">getCommutable</a> () const override</td></tr>
<tr class="memdesc:ab3418bd6d3548316885c8bda0a7464b8 inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to know if the object commutes with all the others.  <a href="classcsl_1_1AbstractElement.html#ab3418bd6d3548316885c8bda0a7464b8">More...</a><br /></td></tr>
<tr class="separator:ab3418bd6d3548316885c8bda0a7464b8 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2c014c2c35cad27d9df5240bfb8548 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top"><a id="a0b2c014c2c35cad27d9df5240bfb8548"></a>
<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getComplexProperty</b> () const override</td></tr>
<tr class="separator:a0b2c014c2c35cad27d9df5240bfb8548 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55db25120693bf64ed360105cb4357c inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#af55db25120693bf64ed360105cb4357c">setParent</a> (const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;t_parent) override</td></tr>
<tr class="memdesc:af55db25120693bf64ed360105cb4357c inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the <a class="el" href="classcsl_1_1Parent.html">Parent</a> of the Element, as the name and the commutability property from those of <b>t_parent</b>.  <a href="classcsl_1_1AbstractElement.html#af55db25120693bf64ed360105cb4357c">More...</a><br /></td></tr>
<tr class="separator:af55db25120693bf64ed360105cb4357c inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a0c9faec5b41fb1feb52764c4237f inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#aed5a0c9faec5b41fb1feb52764c4237f">setName</a> (const std::string &amp;t_name) override</td></tr>
<tr class="memdesc:aed5a0c9faec5b41fb1feb52764c4237f inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the name of the abstract.  <a href="classcsl_1_1AbstractElement.html#aed5a0c9faec5b41fb1feb52764c4237f">More...</a><br /></td></tr>
<tr class="separator:aed5a0c9faec5b41fb1feb52764c4237f inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f5f04326a3320b48a315ec5cee60d9 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#ab8f5f04326a3320b48a315ec5cee60d9">setCommutable</a> (bool t_commutable) override</td></tr>
<tr class="memdesc:ab8f5f04326a3320b48a315ec5cee60d9 inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the abstract to commute or not.  <a href="classcsl_1_1AbstractElement.html#ab8f5f04326a3320b48a315ec5cee60d9">More...</a><br /></td></tr>
<tr class="separator:ab8f5f04326a3320b48a315ec5cee60d9 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9bb4605dbd97ea98f721611adadd72 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top"><a id="a7d9bb4605dbd97ea98f721611adadd72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setComplexProperty</b> (<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> t_prop) override</td></tr>
<tr class="separator:a7d9bb4605dbd97ea98f721611adadd72 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3e30eeaace6c5c21cda6895daa2de9 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#a9f3e30eeaace6c5c21cda6895daa2de9">isPolynomial</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> variable) const override</td></tr>
<tr class="memdesc:a9f3e30eeaace6c5c21cda6895daa2de9 inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the expression is a mononomial term in <b>expr</b>, i.e. a term of the form C*expr^n with C independent of expr, n integer.  <a href="classcsl_1_1AbstractElement.html#a9f3e30eeaace6c5c21cda6895daa2de9">More...</a><br /></td></tr>
<tr class="separator:a9f3e30eeaace6c5c21cda6895daa2de9 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ecff66278c1e385280b761388b929 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#a028ecff66278c1e385280b761388b929">getPolynomialTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> variable, int order) const override</td></tr>
<tr class="memdesc:a028ecff66278c1e385280b761388b929 inherit pub_methods_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the polynomial term corresponding to <b>*this</b> with the variable <b>t_variable</b> at order <b>order</b>. In particular, this function assumes that the checks have already been made with the function <a class="el" href="classcsl_1_1AbstractElement.html#a9f3e30eeaace6c5c21cda6895daa2de9" title="Determines if the expression is a mononomial term in expr, i.e. a term of the form C*expr^n with C in...">isPolynomial()</a>.  <a href="classcsl_1_1AbstractElement.html#a028ecff66278c1e385280b761388b929">More...</a><br /></td></tr>
<tr class="separator:a028ecff66278c1e385280b761388b929 inherit pub_methods_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcsl_1_1Complexified"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcsl_1_1Complexified')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcsl_1_1Complexified.html">csl::Complexified</a></td></tr>
<tr class="memitem:a4c69b308c3d305cfa532eb5c653072a0 inherit pub_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a id="a4c69b308c3d305cfa532eb5c653072a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReal</b> () const override</td></tr>
<tr class="separator:a4c69b308c3d305cfa532eb5c653072a0 inherit pub_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3de4cb73eb624830da28f07ef0fa4d4 inherit pub_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a id="aa3de4cb73eb624830da28f07ef0fa4d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPurelyImaginary</b> () const override</td></tr>
<tr class="separator:aa3de4cb73eb624830da28f07ef0fa4d4 inherit pub_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f583f018b34b63b321976a8bcedf430 inherit pub_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a id="a3f583f018b34b63b321976a8bcedf430"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isComplexConjugate</b> () const override</td></tr>
<tr class="separator:a3f583f018b34b63b321976a8bcedf430 inherit pub_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de9b50162c5af5177a928e855e6b71b inherit pub_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Complexified.html#a5de9b50162c5af5177a928e855e6b71b">getRealPart</a> () const override</td></tr>
<tr class="memdesc:a5de9b50162c5af5177a928e855e6b71b inherit pub_methods_classcsl_1_1Complexified"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classcsl_1_1Complexified.html#a5de9b50162c5af5177a928e855e6b71b">More...</a><br /></td></tr>
<tr class="separator:a5de9b50162c5af5177a928e855e6b71b inherit pub_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11702661de0ea3b9c59b1f23af0ca0c0 inherit pub_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Complexified.html#a11702661de0ea3b9c59b1f23af0ca0c0">getImaginaryPart</a> () const override</td></tr>
<tr class="memdesc:a11702661de0ea3b9c59b1f23af0ca0c0 inherit pub_methods_classcsl_1_1Complexified"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classcsl_1_1Complexified.html#a11702661de0ea3b9c59b1f23af0ca0c0">More...</a><br /></td></tr>
<tr class="separator:a11702661de0ea3b9c59b1f23af0ca0c0 inherit pub_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b60556c965e51ab733e6eb5441783c inherit pub_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a id="a22b60556c965e51ab733e6eb5441783c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setConjugated</b> (bool t_conjugated) override</td></tr>
<tr class="separator:a22b60556c965e51ab733e6eb5441783c inherit pub_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c425b2145c916331f881f217e14e4b inherit pub_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a id="a42c425b2145c916331f881f217e14e4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printProp</b> (std::ostream &amp;fout=std::cout) const override</td></tr>
<tr class="separator:a42c425b2145c916331f881f217e14e4b inherit pub_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcsl_1_1AbstractBuildingBlock"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcsl_1_1AbstractBuildingBlock')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcsl_1_1AbstractBuildingBlock.html">csl::AbstractBuildingBlock</a></td></tr>
<tr class="memitem:aee083330a4490359012cf0e656758a44 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html#aee083330a4490359012cf0e656758a44">isBuildingBlock</a> () const override</td></tr>
<tr class="memdesc:aee083330a4490359012cf0e656758a44 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is a Building Block or not.  <a href="classcsl_1_1AbstractBuildingBlock.html#aee083330a4490359012cf0e656758a44">More...</a><br /></td></tr>
<tr class="separator:aee083330a4490359012cf0e656758a44 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4dd8d4ed4ea0d8817fdd79abd744cc inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html#add4dd8d4ed4ea0d8817fdd79abd744cc">commutesWith</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, int sign=-1) const override</td></tr>
<tr class="memdesc:add4dd8d4ed4ea0d8817fdd79abd744cc inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the object commutes with expr.  <a href="classcsl_1_1AbstractBuildingBlock.html#add4dd8d4ed4ea0d8817fdd79abd744cc">More...</a><br /></td></tr>
<tr class="separator:add4dd8d4ed4ea0d8817fdd79abd744cc inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbbd2edd75a84057f1622826c1efd3a inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a7cbbd2edd75a84057f1622826c1efd3a">expand</a> (bool full=false, bool inplace=false) const override</td></tr>
<tr class="memdesc:a7cbbd2edd75a84057f1622826c1efd3a inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Develops</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classcsl_1_1AbstractBuildingBlock.html#a7cbbd2edd75a84057f1622826c1efd3a">More...</a><br /></td></tr>
<tr class="separator:a7cbbd2edd75a84057f1622826c1efd3a inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f12cede626ece5382c9869d32c32146 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a2f12cede626ece5382c9869d32c32146">factor</a> (bool full=false) const override</td></tr>
<tr class="memdesc:a2f12cede626ece5382c9869d32c32146 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Factors</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classcsl_1_1AbstractBuildingBlock.html#a2f12cede626ece5382c9869d32c32146">More...</a><br /></td></tr>
<tr class="separator:a2f12cede626ece5382c9869d32c32146 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447f940bf0a08d13297fde0b50b4cb84 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a447f940bf0a08d13297fde0b50b4cb84">factor</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool full=false) const override</td></tr>
<tr class="memdesc:a447f940bf0a08d13297fde0b50b4cb84 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Factors</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt a <b>particular</b> <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classcsl_1_1AbstractBuildingBlock.html#a447f940bf0a08d13297fde0b50b4cb84">More...</a><br /></td></tr>
<tr class="separator:a447f940bf0a08d13297fde0b50b4cb84 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c627e31c2a42adec4caf39030123aa inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a58c627e31c2a42adec4caf39030123aa">getTerm</a> () const override</td></tr>
<tr class="memdesc:a58c627e31c2a42adec4caf39030123aa inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the same expression as *this but amputated of its numerical factor. Example: (4*cos(x) -&gt; cos(x)).  <a href="classcsl_1_1AbstractBuildingBlock.html#a58c627e31c2a42adec4caf39030123aa">More...</a><br /></td></tr>
<tr class="separator:a58c627e31c2a42adec4caf39030123aa inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e06ecdb4eb9c6f8434c19ede046fa1 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a09e06ecdb4eb9c6f8434c19ede046fa1">getComplexModulus</a> () const override</td></tr>
<tr class="memdesc:a09e06ecdb4eb9c6f8434c19ede046fa1 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classcsl_1_1AbstractBuildingBlock.html#a09e06ecdb4eb9c6f8434c19ede046fa1">More...</a><br /></td></tr>
<tr class="separator:a09e06ecdb4eb9c6f8434c19ede046fa1 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4000d3f204c1957f5cffc0677dd754c0 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a4000d3f204c1957f5cffc0677dd754c0">findSubExpression</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> subExpression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;newExpression) const override</td></tr>
<tr class="memdesc:a4000d3f204c1957f5cffc0677dd754c0 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sub-expression and replaces it.  <a href="classcsl_1_1AbstractBuildingBlock.html#a4000d3f204c1957f5cffc0677dd754c0">More...</a><br /></td></tr>
<tr class="separator:a4000d3f204c1957f5cffc0677dd754c0 inherit pub_methods_classcsl_1_1AbstractBuildingBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcsl_1_1Abstract"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcsl_1_1Abstract')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a></td></tr>
<tr class="memitem:ad5fee68c1f3dcbda0e936926fed17616 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad5fee68c1f3dcbda0e936926fed17616">Abstract</a> ()</td></tr>
<tr class="memdesc:ad5fee68c1f3dcbda0e936926fed17616 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classcsl_1_1Abstract.html#ad5fee68c1f3dcbda0e936926fed17616">More...</a><br /></td></tr>
<tr class="separator:ad5fee68c1f3dcbda0e936926fed17616 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bdc4c76fdbbf3cbac3af4dce8286ed inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a40bdc4c76fdbbf3cbac3af4dce8286ed"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a40bdc4c76fdbbf3cbac3af4dce8286ed">~Abstract</a> ()</td></tr>
<tr class="memdesc:a40bdc4c76fdbbf3cbac3af4dce8286ed inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a40bdc4c76fdbbf3cbac3af4dce8286ed inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c796713828ebfb74a7d8787d7802a76 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a5c796713828ebfb74a7d8787d7802a76"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> ()</td></tr>
<tr class="separator:a5c796713828ebfb74a7d8787d7802a76 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e45ffc7b65f92e77e592f76f70934c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a89e45ffc7b65f92e77e592f76f70934c">printExplicit</a> (int mode=0) const</td></tr>
<tr class="memdesc:a89e45ffc7b65f92e77e592f76f70934c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays explicitely the expression, with types of each component. This function is only used for debug.  <a href="classcsl_1_1Abstract.html#a89e45ffc7b65f92e77e592f76f70934c">More...</a><br /></td></tr>
<tr class="separator:a89e45ffc7b65f92e77e592f76f70934c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652101e34b2efa43114150e9af3c79d5 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a652101e34b2efa43114150e9af3c79d5"></a>
virtual <a class="el" href="classcsl_1_1LibDependency.html">LibDependency</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getLibDependency</b> () const</td></tr>
<tr class="separator:a652101e34b2efa43114150e9af3c79d5 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e067fc57c0c2e70d141079455fdbd7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a77e067fc57c0c2e70d141079455fdbd7"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>getElementary</b> () const</td></tr>
<tr class="separator:a77e067fc57c0c2e70d141079455fdbd7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021946e84d8c1a019908cac578b16fe8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a021946e84d8c1a019908cac578b16fe8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>getAllDependencies</b> () const</td></tr>
<tr class="separator:a021946e84d8c1a019908cac578b16fe8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856c3d55a6d1406970f3656e61efe8e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5856c3d55a6d1406970f3656e61efe8e">getDim</a> () const</td></tr>
<tr class="memdesc:a5856c3d55a6d1406970f3656e61efe8e inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>dimension</b> of the object.  <a href="classcsl_1_1Abstract.html#a5856c3d55a6d1406970f3656e61efe8e">More...</a><br /></td></tr>
<tr class="separator:a5856c3d55a6d1406970f3656e61efe8e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89eb7b1a9e0259a60154563f3315907 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ae89eb7b1a9e0259a60154563f3315907"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getOrderOf</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:ae89eb7b1a9e0259a60154563f3315907 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09992d147b39388c8936b3bff648930 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ac09992d147b39388c8936b3bff648930"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isArbitrary</b> () const</td></tr>
<tr class="separator:ac09992d147b39388c8936b3bff648930 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ce38838e35c5785f92373a1d830668 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="af2ce38838e35c5785f92373a1d830668"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isHermitianConjugate</b> () const</td></tr>
<tr class="separator:af2ce38838e35c5785f92373a1d830668 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a014bfd266b5f8471f23580e271979b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9a014bfd266b5f8471f23580e271979b">isInteger</a> () const</td></tr>
<tr class="memdesc:a9a014bfd266b5f8471f23580e271979b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is an integer. Either an <a class="el" href="classcsl_1_1Integer.html" title="Handle numbers in expr. ">Integer</a> object directly, or a <a class="el" href="classcsl_1_1Float.html" title="Handle numbers in expr. ">Float</a> that has an integer value.  <a href="classcsl_1_1Abstract.html#a9a014bfd266b5f8471f23580e271979b">More...</a><br /></td></tr>
<tr class="separator:a9a014bfd266b5f8471f23580e271979b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628563238145f3a9acc331f1a89ce32f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a628563238145f3a9acc331f1a89ce32f">getValued</a> () const</td></tr>
<tr class="memdesc:a628563238145f3a9acc331f1a89ce32f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is valued, i.e. is a function of numbers and valued literals (a <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a> or <a class="el" href="classcsl_1_1Constant.html" title="Handle an object with a name and a value. ">Constant</a> is not valued by default).  <a href="classcsl_1_1Abstract.html#a628563238145f3a9acc331f1a89ce32f">More...</a><br /></td></tr>
<tr class="separator:a628563238145f3a9acc331f1a89ce32f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f98ba06476e464e3fd2fce0d1f8243 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a78f98ba06476e464e3fd2fce0d1f8243">getValue</a> () const</td></tr>
<tr class="memdesc:a78f98ba06476e464e3fd2fce0d1f8243 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the expression, if it has one <b>explicitely</b>. In particular, it will work only on Numbers and valued Literals, not on functions.  <a href="classcsl_1_1Abstract.html#a78f98ba06476e464e3fd2fce0d1f8243">More...</a><br /></td></tr>
<tr class="separator:a78f98ba06476e464e3fd2fce0d1f8243 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a657baf1c35ed581e9db2c47a71c99 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a69a657baf1c35ed581e9db2c47a71c99"></a>
virtual long double&#160;</td><td class="memItemRight" valign="bottom"><b>getDeltaPlus</b> () const</td></tr>
<tr class="separator:a69a657baf1c35ed581e9db2c47a71c99 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f0e4c9c91f43b5cd61cbb873869eb inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa22f0e4c9c91f43b5cd61cbb873869eb"></a>
virtual long double&#160;</td><td class="memItemRight" valign="bottom"><b>getDeltaMinus</b> () const</td></tr>
<tr class="separator:aa22f0e4c9c91f43b5cd61cbb873869eb inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed">getNum</a> () const</td></tr>
<tr class="separator:a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9531d78d67c82e288c0130da5b1ba80b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9531d78d67c82e288c0130da5b1ba80b">getDenom</a> () const</td></tr>
<tr class="separator:a9531d78d67c82e288c0130da5b1ba80b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa034448201c9e7998bbbb5e409636b30 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa034448201c9e7998bbbb5e409636b30">getNArgs</a> (int axis=0) const</td></tr>
<tr class="memdesc:aa034448201c9e7998bbbb5e409636b30 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arguments of the expression. If the expression is a building block (<a class="el" href="classcsl_1_1AbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e...">AbstractBuildingBlock</a>), this function returns 0.  <a href="classcsl_1_1Abstract.html#aa034448201c9e7998bbbb5e409636b30">More...</a><br /></td></tr>
<tr class="separator:aa034448201c9e7998bbbb5e409636b30 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3794843945b8a39e2c1be073c9bacdf5 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a3794843945b8a39e2c1be073c9bacdf5"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a3794843945b8a39e2c1be073c9bacdf5 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3c3fe5010f24e8a8765ea06415c003 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0c3c3fe5010f24e8a8765ea06415c003"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:a0c3c3fe5010f24e8a8765ea06415c003 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad54ed41b2ce9bad3364fe30ad1a0d71 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aad54ed41b2ce9bad3364fe30ad1a0d71">begin</a> ()</td></tr>
<tr class="separator:aad54ed41b2ce9bad3364fe30ad1a0d71 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e4e80d998a888a1a74d9ea3e10c0f1 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a61e4e80d998a888a1a74d9ea3e10c0f1">end</a> ()</td></tr>
<tr class="separator:a61e4e80d998a888a1a74d9ea3e10c0f1 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff373df9477d4e38581d09cc6d2fee4 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#adff373df9477d4e38581d09cc6d2fee4">begin</a> () const</td></tr>
<tr class="separator:adff373df9477d4e38581d09cc6d2fee4 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2761d54f13310e13f5076d565edd7ef inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae2761d54f13310e13f5076d565edd7ef">end</a> () const</td></tr>
<tr class="separator:ae2761d54f13310e13f5076d565edd7ef inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33a42309d629d47bfdbede4e152414e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac33a42309d629d47bfdbede4e152414e">getArgument</a> (int iArg=0) const</td></tr>
<tr class="separator:ac33a42309d629d47bfdbede4e152414e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f542034e95744148f4fce5a4893e63 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a06f542034e95744148f4fce5a4893e63"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getArgument</b> (int iArg=0)</td></tr>
<tr class="separator:a06f542034e95744148f4fce5a4893e63 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94b3892af147ac0b05c1d8c960e4eba inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad94b3892af147ac0b05c1d8c960e4eba">getArgument</a> (const std::vector&lt; int &gt; &amp;indices) const</td></tr>
<tr class="memdesc:ad94b3892af147ac0b05c1d8c960e4eba inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension.  <a href="classcsl_1_1Abstract.html#ad94b3892af147ac0b05c1d8c960e4eba">More...</a><br /></td></tr>
<tr class="separator:ad94b3892af147ac0b05c1d8c960e4eba inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050aa1cdc4549cbf29181f73a5731cfc inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a050aa1cdc4549cbf29181f73a5731cfc"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getArgument</b> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:a050aa1cdc4549cbf29181f73a5731cfc inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83c44ae1e5315a38083bdb7acd8f3fa inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual const csl::vector_expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac83c44ae1e5315a38083bdb7acd8f3fa">getVectorArgument</a> () const</td></tr>
<tr class="memdesc:ac83c44ae1e5315a38083bdb7acd8f3fa inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get the entire std::vector of arguments of the expression.  <a href="classcsl_1_1Abstract.html#ac83c44ae1e5315a38083bdb7acd8f3fa">More...</a><br /></td></tr>
<tr class="separator:ac83c44ae1e5315a38083bdb7acd8f3fa inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85f810bbadbc792210c958e8f1b2ffb inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae85f810bbadbc792210c958e8f1b2ffb">getVariable</a> () const</td></tr>
<tr class="memdesc:ae85f810bbadbc792210c958e8f1b2ffb inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the variable that defines certain types of expressions.  <a href="classcsl_1_1Abstract.html#ae85f810bbadbc792210c958e8f1b2ffb">More...</a><br /></td></tr>
<tr class="separator:ae85f810bbadbc792210c958e8f1b2ffb inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9500a21d75d03c695ec0c76493600b38 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9500a21d75d03c695ec0c76493600b38">getOrder</a> () const</td></tr>
<tr class="memdesc:a9500a21d75d03c695ec0c76493600b38 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the order (integer) that defines certain types of expressions.  <a href="classcsl_1_1Abstract.html#a9500a21d75d03c695ec0c76493600b38">More...</a><br /></td></tr>
<tr class="separator:a9500a21d75d03c695ec0c76493600b38 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83df1d9dc202457113e5b38bd694fae inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa83df1d9dc202457113e5b38bd694fae">getSign</a> () const</td></tr>
<tr class="separator:aa83df1d9dc202457113e5b38bd694fae inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9347e75b0cd0b75e0f0a38db93b29d83 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9347e75b0cd0b75e0f0a38db93b29d83">isAnOperator</a> () const</td></tr>
<tr class="memdesc:a9347e75b0cd0b75e0f0a38db93b29d83 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is an operator (like a derivetive operator).  <a href="classcsl_1_1Abstract.html#a9347e75b0cd0b75e0f0a38db93b29d83">More...</a><br /></td></tr>
<tr class="separator:a9347e75b0cd0b75e0f0a38db93b29d83 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464f4f0613db9b4b0a4efe26a3a03d60 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a464f4f0613db9b4b0a4efe26a3a03d60">isEmpty</a> () const</td></tr>
<tr class="memdesc:a464f4f0613db9b4b0a4efe26a3a03d60 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells for a <a class="el" href="classcsl_1_1Derivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or an <a class="el" href="classcsl_1_1Integral.html">Integral</a> if the argument is empty i.e. if the object must apply on the next argument encountered on the right.  <a href="classcsl_1_1Abstract.html#a464f4f0613db9b4b0a4efe26a3a03d60">More...</a><br /></td></tr>
<tr class="separator:a464f4f0613db9b4b0a4efe26a3a03d60 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d9abfa88d9d09a89d3a4becd9e6429 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a75d9abfa88d9d09a89d3a4becd9e6429"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>operatorAppliesOn</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a75d9abfa88d9d09a89d3a4becd9e6429 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3ec3dfe1fbd8ead5c8d9aca421a863 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9c3ec3dfe1fbd8ead5c8d9aca421a863">getOperand</a> () const</td></tr>
<tr class="memdesc:a9c3ec3dfe1fbd8ead5c8d9aca421a863 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand of an <a class="el" href="classcsl_1_1Operator.html" title="Linear operator O(a*X+b*Y) = a*O(X) + b*O(Y) ">Operator</a>.  <a href="classcsl_1_1Abstract.html#a9c3ec3dfe1fbd8ead5c8d9aca421a863">More...</a><br /></td></tr>
<tr class="separator:a9c3ec3dfe1fbd8ead5c8d9aca421a863 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625efe55a17b97a1c0f085bdbf3a962a inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a625efe55a17b97a1c0f085bdbf3a962a">getShape</a> () const</td></tr>
<tr class="memdesc:a625efe55a17b97a1c0f085bdbf3a962a inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the shape of the tensor in the form of a std::vector of integers.  <a href="classcsl_1_1Abstract.html#a625efe55a17b97a1c0f085bdbf3a962a">More...</a><br /></td></tr>
<tr class="separator:a625efe55a17b97a1c0f085bdbf3a962a inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b1e294cf24dea17c3c4361226138b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a3d6b1e294cf24dea17c3c4361226138b"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInfBoundary</b> () const</td></tr>
<tr class="separator:a3d6b1e294cf24dea17c3c4361226138b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcc223dbf5d880e923c07df142df5c8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a2fcc223dbf5d880e923c07df142df5c8"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSupBoundary</b> () const</td></tr>
<tr class="separator:a2fcc223dbf5d880e923c07df142df5c8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7104a5b8855272a92a47c58f29e958 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aad7104a5b8855272a92a47c58f29e958"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setSupBoundary</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_inf)</td></tr>
<tr class="separator:aad7104a5b8855272a92a47c58f29e958 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecdb6ce7a2d9643da2f6161a06dfbbf inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a5ecdb6ce7a2d9643da2f6161a06dfbbf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setInfBoundary</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_inf)</td></tr>
<tr class="separator:a5ecdb6ce7a2d9643da2f6161a06dfbbf inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a9a9ef3efd6bb83b62c0a353742d25 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ae6a9a9ef3efd6bb83b62c0a353742d25"></a>
<a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructure</b> (<a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space) const</td></tr>
<tr class="separator:ae6a9a9ef3efd6bb83b62c0a353742d25 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4136dc23f1fba4bf897b54c8592ccfc inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa4136dc23f1fba4bf897b54c8592ccfc">getFreeIndexStructure</a> () const</td></tr>
<tr class="separator:aa4136dc23f1fba4bf897b54c8592ccfc inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b32036fea6a2583f506a6ef9508d74 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a06b32036fea6a2583f506a6ef9508d74"></a>
virtual <a class="el" href="classcsl_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPoint</b> () const</td></tr>
<tr class="separator:a06b32036fea6a2583f506a6ef9508d74 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42125e9765a771c47819548d342b0b28 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a42125e9765a771c47819548d342b0b28">getNContractedPairs</a> () const</td></tr>
<tr class="memdesc:a42125e9765a771c47819548d342b0b28 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of contracted pairs of indices <b>in an Indicial expression</b>.  <a href="classcsl_1_1Abstract.html#a42125e9765a771c47819548d342b0b28">More...</a><br /></td></tr>
<tr class="separator:a42125e9765a771c47819548d342b0b28 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04c0e4426f0bf9df365afe0148d59df inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af04c0e4426f0bf9df365afe0148d59df">getContractedPair</a> () const</td></tr>
<tr class="separator:af04c0e4426f0bf9df365afe0148d59df inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c2898c5d3ba96de8018a0838c402c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="af29c2898c5d3ba96de8018a0838c402c"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> () const</td></tr>
<tr class="separator:af29c2898c5d3ba96de8018a0838c402c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09648782dcf2e81abb5b864f476cc410 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a09648782dcf2e81abb5b864f476cc410"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deepCopy</b> () const</td></tr>
<tr class="separator:a09648782dcf2e81abb5b864f476cc410 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7f0692cb84ca861a5b3b641bea518b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aaf7f0692cb84ca861a5b3b641bea518b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aaf7f0692cb84ca861a5b3b641bea518b">setValue</a> (long double t_value)</td></tr>
<tr class="memdesc:aaf7f0692cb84ca861a5b3b641bea518b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value if there is one (for Numerical and Literal valued). <br /></td></tr>
<tr class="separator:aaf7f0692cb84ca861a5b3b641bea518b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49c51bd285830e724f103e9fb61c464 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa49c51bd285830e724f103e9fb61c464"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setValue</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_value)</td></tr>
<tr class="separator:aa49c51bd285830e724f103e9fb61c464 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a04bb56578e7da143b3cd8d8fb7b26 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa6a04bb56578e7da143b3cd8d8fb7b26"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setElementary</b> (bool t_elementary)</td></tr>
<tr class="separator:aa6a04bb56578e7da143b3cd8d8fb7b26 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a40ceb6eb1aa79711ca126d5bdda02 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa6a40ceb6eb1aa79711ca126d5bdda02"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setAllDependencies</b> (bool t_allDependencies)</td></tr>
<tr class="separator:aa6a40ceb6eb1aa79711ca126d5bdda02 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbab11282e5c6ac46b018642ff129f47 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="abbab11282e5c6ac46b018642ff129f47"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addDependency</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:abbab11282e5c6ac46b018642ff129f47 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e778c682b6cb02642b90e8ec8765441 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0e778c682b6cb02642b90e8ec8765441"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeDependency</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a0e778c682b6cb02642b90e8ec8765441 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2d2ac186b56d17d2cc0a105e145b11 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aab2d2ac186b56d17d2cc0a105e145b11">setArgument</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, int iArg=0)</td></tr>
<tr class="memdesc:aab2d2ac186b56d17d2cc0a105e145b11 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>iArg</b> (default=0).  <a href="classcsl_1_1Abstract.html#aab2d2ac186b56d17d2cc0a105e145b11">More...</a><br /></td></tr>
<tr class="separator:aab2d2ac186b56d17d2cc0a105e145b11 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7907d6983f47d261748870b497f6aa8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae7907d6983f47d261748870b497f6aa8">setArgument</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:ae7907d6983f47d261748870b497f6aa8 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions.  <a href="classcsl_1_1Abstract.html#ae7907d6983f47d261748870b497f6aa8">More...</a><br /></td></tr>
<tr class="separator:ae7907d6983f47d261748870b497f6aa8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa50c743b8e7e76e637e98f165ad4e5d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="afa50c743b8e7e76e637e98f165ad4e5d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setEmpty</b> (bool t_empty)</td></tr>
<tr class="separator:afa50c743b8e7e76e637e98f165ad4e5d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70df7be4486affa8dc891e3f25bf499f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a70df7be4486affa8dc891e3f25bf499f">setOperand</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand)</td></tr>
<tr class="memdesc:a70df7be4486affa8dc891e3f25bf499f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operand of an operator.  <a href="classcsl_1_1Abstract.html#a70df7be4486affa8dc891e3f25bf499f">More...</a><br /></td></tr>
<tr class="separator:a70df7be4486affa8dc891e3f25bf499f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b8a14fc746ed72e4d5abd63373c5ba inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae7b8a14fc746ed72e4d5abd63373c5ba">setOperandPrivate</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand, bool leaveEmpty)</td></tr>
<tr class="memdesc:ae7b8a14fc746ed72e4d5abd63373c5ba inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operand of an operator.  <a href="classcsl_1_1Abstract.html#ae7b8a14fc746ed72e4d5abd63373c5ba">More...</a><br /></td></tr>
<tr class="separator:ae7b8a14fc746ed72e4d5abd63373c5ba inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fee8ed28079bcac107455d58be9d5d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a83fee8ed28079bcac107455d58be9d5d">setVectorArgument</a> (const csl::vector_expr &amp;t_argument)</td></tr>
<tr class="memdesc:a83fee8ed28079bcac107455d58be9d5d inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaced the entire std::vector of argument.  <a href="classcsl_1_1Abstract.html#a83fee8ed28079bcac107455d58be9d5d">More...</a><br /></td></tr>
<tr class="separator:a83fee8ed28079bcac107455d58be9d5d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47ddab3aa047e86be34c70358d53548 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa47ddab3aa047e86be34c70358d53548"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setVariable</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_variable)</td></tr>
<tr class="separator:aa47ddab3aa047e86be34c70358d53548 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5437e7f685edf8549e6d3b34572343f8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5437e7f685edf8549e6d3b34572343f8">insert</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, bool side=1)</td></tr>
<tr class="memdesc:a5437e7f685edf8549e6d3b34572343f8 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an expression in a sum or a product.  <a href="classcsl_1_1Abstract.html#a5437e7f685edf8549e6d3b34572343f8">More...</a><br /></td></tr>
<tr class="separator:a5437e7f685edf8549e6d3b34572343f8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed79d20a0821205e6430c80a474117d3 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aed79d20a0821205e6430c80a474117d3"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>contractIndex</b> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index) const</td></tr>
<tr class="separator:aed79d20a0821205e6430c80a474117d3 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3627f1b91e9a81f27a8b8733ec615e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0e3627f1b91e9a81f27a8b8733ec615e"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>breakSpace</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *brokenSpace, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;newSpace) const</td></tr>
<tr class="separator:a0e3627f1b91e9a81f27a8b8733ec615e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c175411df619e7504feb6d888fc82f1 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a3c175411df619e7504feb6d888fc82f1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setPoint</b> (const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;t_point)</td></tr>
<tr class="separator:a3c175411df619e7504feb6d888fc82f1 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f90ebb7cf7c26782bd36bc2a67fc5d4 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a4f90ebb7cf7c26782bd36bc2a67fc5d4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4f90ebb7cf7c26782bd36bc2a67fc5d4">setFullySymmetric</a> ()</td></tr>
<tr class="memdesc:a4f90ebb7cf7c26782bd36bc2a67fc5d4 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties of symmetry / antisymmetry and sets <b>fullySymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:a4f90ebb7cf7c26782bd36bc2a67fc5d4 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac318016372d14b795893fe7e59199084 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ac318016372d14b795893fe7e59199084"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac318016372d14b795893fe7e59199084">setFullyAntiSymmetric</a> ()</td></tr>
<tr class="memdesc:ac318016372d14b795893fe7e59199084 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully anti-symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties * of symmetry / antisymmetry and sets <b>fullyAntiSymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:ac318016372d14b795893fe7e59199084 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad431770faa4291116a50175193a11a88 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad431770faa4291116a50175193a11a88">addSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:ad431770faa4291116a50175193a11a88 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a symmetry between the i1^{th} and the i2^{th} indices. If those indices are anti-symmetric, an error is thrown.  <a href="classcsl_1_1Abstract.html#ad431770faa4291116a50175193a11a88">More...</a><br /></td></tr>
<tr class="separator:ad431770faa4291116a50175193a11a88 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5549ac0c186b3c6febf332245a25a82c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5549ac0c186b3c6febf332245a25a82c">addAntiSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a5549ac0c186b3c6febf332245a25a82c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an anti-symmetry between the i1^{th} and the i2^{th} indices. If those indices are symmetric, an error is thrown.  <a href="classcsl_1_1Abstract.html#a5549ac0c186b3c6febf332245a25a82c">More...</a><br /></td></tr>
<tr class="separator:a5549ac0c186b3c6febf332245a25a82c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9aceabbc0a99642e84c9025dbdc767 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#abe9aceabbc0a99642e84c9025dbdc767">permut</a> (int i1, int i2)</td></tr>
<tr class="memdesc:abe9aceabbc0a99642e84c9025dbdc767 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to permut indices at place <b>i1</b> and <b>i2</b>. If those two indices have a symmetry property, indices are swaped and the symmetry is returned. Else the fnuction does nothing and returns 0.  <a href="classcsl_1_1Abstract.html#abe9aceabbc0a99642e84c9025dbdc767">More...</a><br /></td></tr>
<tr class="separator:abe9aceabbc0a99642e84c9025dbdc767 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25c117c8dfc4d9718ba41e8d3f33a6 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aad25c117c8dfc4d9718ba41e8d3f33a6">getNumericalFactor</a> () const</td></tr>
<tr class="memdesc:aad25c117c8dfc4d9718ba41e8d3f33a6 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numerical factor of the expression, i.e. returns <b>C</b> if the expression if of the form <b>C*x</b> (<b>x</b> having a numerical factor equal to 1), and return 1 else.  <a href="classcsl_1_1Abstract.html#aad25c117c8dfc4d9718ba41e8d3f33a6">More...</a><br /></td></tr>
<tr class="separator:aad25c117c8dfc4d9718ba41e8d3f33a6 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204dbd37b63432cb08932b995f49d3f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a204dbd37b63432cb08932b995f49d3f4">getNFactor</a> () const</td></tr>
<tr class="separator:a204dbd37b63432cb08932b995f49d3f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34c9c6f05e692faeed2f030514787ad inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac34c9c6f05e692faeed2f030514787ad">getFactors</a> () const</td></tr>
<tr class="memdesc:ac34c9c6f05e692faeed2f030514787ad inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get a std::vector of all terms than could factor the expression.  <a href="classcsl_1_1Abstract.html#ac34c9c6f05e692faeed2f030514787ad">More...</a><br /></td></tr>
<tr class="separator:ac34c9c6f05e692faeed2f030514787ad inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac513c930caa9939c2b9557f36a34ee69 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac513c930caa9939c2b9557f36a34ee69">getExponents</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;exponents) const</td></tr>
<tr class="memdesc:ac513c930caa9939c2b9557f36a34ee69 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills in a vector the exponents corresponding to some factors for the expression.  <a href="classcsl_1_1Abstract.html#ac513c930caa9939c2b9557f36a34ee69">More...</a><br /></td></tr>
<tr class="separator:ac513c930caa9939c2b9557f36a34ee69 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebd84082bb93418408cc0babe2dffe2 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1ebd84082bb93418408cc0babe2dffe2">checkIndexStructure</a> (const std::initializer_list&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;index) const</td></tr>
<tr class="memdesc:a1ebd84082bb93418408cc0babe2dffe2 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="classcsl_1_1Abstract.html#a1ebd84082bb93418408cc0babe2dffe2">More...</a><br /></td></tr>
<tr class="separator:a1ebd84082bb93418408cc0babe2dffe2 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f16fda9fe72a89c61ece36101a11d95 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0f16fda9fe72a89c61ece36101a11d95"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compareWithDummy</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool keepAllCosntraints=false) const</td></tr>
<tr class="separator:a0f16fda9fe72a89c61ece36101a11d95 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8459b3206eb3a2297eeea7688e9520 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aea8459b3206eb3a2297eeea7688e9520">getParity</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> t_variable) const</td></tr>
<tr class="memdesc:aea8459b3206eb3a2297eeea7688e9520 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parity property of the expression with respect to <b>t_variable</b>.  <a href="classcsl_1_1Abstract.html#aea8459b3206eb3a2297eeea7688e9520">More...</a><br /></td></tr>
<tr class="separator:aea8459b3206eb3a2297eeea7688e9520 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b26ad7a44e497af296318287bac539a inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0b26ad7a44e497af296318287bac539a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>dependsExplicitlyOn</b> (<a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> parent) const</td></tr>
<tr class="separator:a0b26ad7a44e497af296318287bac539a inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c1d8df9e6b1a3eca66958f7dc489d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ab79c1d8df9e6b1a3eca66958f7dc489d">matchShape</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool exact=false) const</td></tr>
<tr class="memdesc:ab79c1d8df9e6b1a3eca66958f7dc489d inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of a vectorial-type expression, this function checks if the shape of expr matches itself.  <a href="classcsl_1_1Abstract.html#ab79c1d8df9e6b1a3eca66958f7dc489d">More...</a><br /></td></tr>
<tr class="separator:ab79c1d8df9e6b1a3eca66958f7dc489d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd35096982e92b669ea55d960c5f44be inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="abd35096982e92b669ea55d960c5f44be"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>contraction</b> (const csl::vector_expr &amp;chain) const</td></tr>
<tr class="separator:abd35096982e92b669ea55d960c5f44be inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543d5a4f0432e166b492ad28a860a65f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a543d5a4f0432e166b492ad28a860a65f">evaluateScalar</a> () const</td></tr>
<tr class="memdesc:a543d5a4f0432e166b492ad28a860a65f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the value of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classcsl_1_1Abstract.html#a543d5a4f0432e166b492ad28a860a65f">More...</a><br /></td></tr>
<tr class="separator:a543d5a4f0432e166b492ad28a860a65f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3746f1d3667846824ea51b8a2e00d31 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ab3746f1d3667846824ea51b8a2e00d31">collect</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors, bool full=false) const</td></tr>
<tr class="memdesc:ab3746f1d3667846824ea51b8a2e00d31 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects terms in sum according to some factors given by the user.  <a href="classcsl_1_1Abstract.html#ab3746f1d3667846824ea51b8a2e00d31">More...</a><br /></td></tr>
<tr class="separator:ab3746f1d3667846824ea51b8a2e00d31 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43520e1d6d5fdad9b50f77c6e027f928 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a43520e1d6d5fdad9b50f77c6e027f928">suppressTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a43520e1d6d5fdad9b50f77c6e027f928 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a factor from an expr, that must have been determined before.  <a href="classcsl_1_1Abstract.html#a43520e1d6d5fdad9b50f77c6e027f928">More...</a><br /></td></tr>
<tr class="separator:a43520e1d6d5fdad9b50f77c6e027f928 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eeedaeaa39e75facf1060dce7c57a8f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4eeedaeaa39e75facf1060dce7c57a8f">suppressExponent</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;<a class="el" href="classcsl_1_1Abstract.html#a0bc0de9c4ce5f77fc716af0f502d13d3">factor</a>, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;exponent) const</td></tr>
<tr class="memdesc:a4eeedaeaa39e75facf1060dce7c57a8f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression where the factor <b>factor^exponent</b> has been suppressed.  <a href="classcsl_1_1Abstract.html#a4eeedaeaa39e75facf1060dce7c57a8f">More...</a><br /></td></tr>
<tr class="separator:a4eeedaeaa39e75facf1060dce7c57a8f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48aaaa856582b6359037fe94d2419b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aeb48aaaa856582b6359037fe94d2419b">expand_if</a> (std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, bool full=false, bool inPlace=false) const</td></tr>
<tr class="memdesc:aeb48aaaa856582b6359037fe94d2419b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Develops</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="classcsl_1_1Abstract.html#aeb48aaaa856582b6359037fe94d2419b">More...</a><br /></td></tr>
<tr class="separator:aeb48aaaa856582b6359037fe94d2419b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc64c66894acafc1f069dc40072084b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9cc64c66894acafc1f069dc40072084b">getComplexArgument</a> () const</td></tr>
<tr class="memdesc:a9cc64c66894acafc1f069dc40072084b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="classcsl_1_1Abstract.html#a9cc64c66894acafc1f069dc40072084b">More...</a><br /></td></tr>
<tr class="separator:a9cc64c66894acafc1f069dc40072084b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316956fea77627a716500a2bbfc1f3b7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a316956fea77627a716500a2bbfc1f3b7">applyOperator</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand, bool leaveEmpty=false) const</td></tr>
<tr class="memdesc:a316956fea77627a716500a2bbfc1f3b7 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the operator on an <b>operand</b>, iif the expression is an operator.  <a href="classcsl_1_1Abstract.html#a316956fea77627a716500a2bbfc1f3b7">More...</a><br /></td></tr>
<tr class="separator:a316956fea77627a716500a2bbfc1f3b7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101219973341a39cf15f07e5e1aa388f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a101219973341a39cf15f07e5e1aa388f">addition_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a101219973341a39cf15f07e5e1aa388f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special addition for Numerical- and Vectorial-types.  <a href="classcsl_1_1Abstract.html#a101219973341a39cf15f07e5e1aa388f">More...</a><br /></td></tr>
<tr class="separator:a101219973341a39cf15f07e5e1aa388f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5ed458ba62f5b4cf61a9e1f8568af1 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4f5ed458ba62f5b4cf61a9e1f8568af1">multiplication_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, bool side=1) const</td></tr>
<tr class="memdesc:a4f5ed458ba62f5b4cf61a9e1f8568af1 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special multiplication for Numerical- and Vectorial-types.  <a href="classcsl_1_1Abstract.html#a4f5ed458ba62f5b4cf61a9e1f8568af1">More...</a><br /></td></tr>
<tr class="separator:a4f5ed458ba62f5b4cf61a9e1f8568af1 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1578c74aee1050b806a67e7a81a67f5c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1578c74aee1050b806a67e7a81a67f5c">division_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a1578c74aee1050b806a67e7a81a67f5c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special division for Numerical- and Polynomial-types. For polynomial, the euclidean division of two polynomials is implemented.  <a href="classcsl_1_1Abstract.html#a1578c74aee1050b806a67e7a81a67f5c">More...</a><br /></td></tr>
<tr class="separator:a1578c74aee1050b806a67e7a81a67f5c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2696a0feb43766ef54e1e3dd3d6d134 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa2696a0feb43766ef54e1e3dd3d6d134">exponentiation_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:aa2696a0feb43766ef54e1e3dd3d6d134 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special exponentiation for Numerical- and Vectorial-types.  <a href="classcsl_1_1Abstract.html#aa2696a0feb43766ef54e1e3dd3d6d134">More...</a><br /></td></tr>
<tr class="separator:aa2696a0feb43766ef54e1e3dd3d6d134 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b77f008f4b95030641224877004f06c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5b77f008f4b95030641224877004f06c">getRegularExpression</a> () const</td></tr>
<tr class="memdesc:a5b77f008f4b95030641224877004f06c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a regular expression from the polynomial, that is a sum where the different powers of the variable appear explicitely.  <a href="classcsl_1_1Abstract.html#a5b77f008f4b95030641224877004f06c">More...</a><br /></td></tr>
<tr class="separator:a5b77f008f4b95030641224877004f06c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83c6a13716688f45b02e6291d39aba inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7b83c6a13716688f45b02e6291d39aba">tensordot</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a7b83c6a13716688f45b02e6291d39aba inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensordot of two <b>Vectorial</b> expressions.  <a href="classcsl_1_1Abstract.html#a7b83c6a13716688f45b02e6291d39aba">More...</a><br /></td></tr>
<tr class="separator:a7b83c6a13716688f45b02e6291d39aba inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc7a46deaa3eaa7593909d74e76d4af inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4cc7a46deaa3eaa7593909d74e76d4af">dot</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a4cc7a46deaa3eaa7593909d74e76d4af inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of two <b>Vectorial</b> expressions.  <a href="classcsl_1_1Abstract.html#a4cc7a46deaa3eaa7593909d74e76d4af">More...</a><br /></td></tr>
<tr class="separator:a4cc7a46deaa3eaa7593909d74e76d4af inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf8154e39ff211b12e6382e675ccaad inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aeaf8154e39ff211b12e6382e675ccaad">getSum</a> () const</td></tr>
<tr class="memdesc:aeaf8154e39ff211b12e6382e675ccaad inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the sum of all elements in the <b>Vectorial</b> object.  <a href="classcsl_1_1Abstract.html#aeaf8154e39ff211b12e6382e675ccaad">More...</a><br /></td></tr>
<tr class="separator:aeaf8154e39ff211b12e6382e675ccaad inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07489d0569bc983718796d21c73f34b3 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a07489d0569bc983718796d21c73f34b3">getProduct</a> () const</td></tr>
<tr class="memdesc:a07489d0569bc983718796d21c73f34b3 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the product of all elements in the <b>Vectorial</b> object.  <a href="classcsl_1_1Abstract.html#a07489d0569bc983718796d21c73f34b3">More...</a><br /></td></tr>
<tr class="separator:a07489d0569bc983718796d21c73f34b3 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0188b049736016c970a2513ed9f6931f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a0188b049736016c970a2513ed9f6931f">getVectorialModulus</a> () const</td></tr>
<tr class="memdesc:a0188b049736016c970a2513ed9f6931f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vectorial modulus of the <b>Vectorial</b> object, that is defined here as the squared root of the sum of element squared. Example: {A_{11}^2+A_{12}^2+}.  <a href="classcsl_1_1Abstract.html#a0188b049736016c970a2513ed9f6931f">More...</a><br /></td></tr>
<tr class="separator:a0188b049736016c970a2513ed9f6931f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcdc11b64c8c515933882168d0792ef inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7dcdc11b64c8c515933882168d0792ef">getSubVectorial</a> (int iExcept) const</td></tr>
<tr class="memdesc:a7dcdc11b64c8c515933882168d0792ef inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="classcsl_1_1Abstract.html#a7dcdc11b64c8c515933882168d0792ef">More...</a><br /></td></tr>
<tr class="separator:a7dcdc11b64c8c515933882168d0792ef inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c50b2663f57d38c1d3ec3cfeaa3ce inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a413c50b2663f57d38c1d3ec3cfeaa3ce">getSubVectorial</a> (int iExcept, int jExcept) const</td></tr>
<tr class="memdesc:a413c50b2663f57d38c1d3ec3cfeaa3ce inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the [iExcept^{th},jExcept^{th}] element (useful for matrices).  <a href="classcsl_1_1Abstract.html#a413c50b2663f57d38c1d3ec3cfeaa3ce">More...</a><br /></td></tr>
<tr class="separator:a413c50b2663f57d38c1d3ec3cfeaa3ce inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f88bae88e30b37cc3a4d4c7a476a992 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a0f88bae88e30b37cc3a4d4c7a476a992">getSubVectorial</a> (const std::vector&lt; int &gt; &amp;exceptions) const</td></tr>
<tr class="memdesc:a0f88bae88e30b37cc3a4d4c7a476a992 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="classcsl_1_1Abstract.html#a0f88bae88e30b37cc3a4d4c7a476a992">More...</a><br /></td></tr>
<tr class="separator:a0f88bae88e30b37cc3a4d4c7a476a992 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7aad9c82bc7fd4a19e495fac3673a9 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ada7aad9c82bc7fd4a19e495fac3673a9"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSubVectorial</b> (const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;keepIndices) const</td></tr>
<tr class="separator:ada7aad9c82bc7fd4a19e495fac3673a9 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d86e688cb7b1e7d7846e14ae5a3e1c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aa1d86e688cb7b1e7d7846e14ae5a3e1c"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSubVectorial</b> (std::vector&lt; std::vector&lt; int &gt;&gt;::const_iterator <a class="el" href="classcsl_1_1Abstract.html#aad54ed41b2ce9bad3364fe30ad1a0d71">begin</a>, std::vector&lt; std::vector&lt; int &gt;&gt;::const_iterator <a class="el" href="classcsl_1_1Abstract.html#a61e4e80d998a888a1a74d9ea3e10c0f1">end</a>) const</td></tr>
<tr class="separator:aa1d86e688cb7b1e7d7846e14ae5a3e1c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb08811cf370616477a92075e4a218ee inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aeb08811cf370616477a92075e4a218ee">determinant</a> () const</td></tr>
<tr class="memdesc:aeb08811cf370616477a92075e4a218ee inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the object if it corresponds to a square matrix (or a scalar), 0 else.  <a href="classcsl_1_1Abstract.html#aeb08811cf370616477a92075e4a218ee">More...</a><br /></td></tr>
<tr class="separator:aeb08811cf370616477a92075e4a218ee inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a86d21f5c5f65eb7e524a8f8002c0e7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9a86d21f5c5f65eb7e524a8f8002c0e7">trace</a> () const</td></tr>
<tr class="separator:a9a86d21f5c5f65eb7e524a8f8002c0e7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacab43e551e9259a39a79378373ce49c inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aacab43e551e9259a39a79378373ce49c">trace</a> (int axis1, int axis2) const</td></tr>
<tr class="memdesc:aacab43e551e9259a39a79378373ce49c inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the trace over the axis <b>axis1</b> and <b>axis2</b> of a tensor. <b>axis1</b> and <b>axis2</b> can be the same, in which case the trace just corresponds to the sum over this particular axis.  <a href="classcsl_1_1Abstract.html#aacab43e551e9259a39a79378373ce49c">More...</a><br /></td></tr>
<tr class="separator:aacab43e551e9259a39a79378373ce49c inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e97712696e5c40b28bc1e35987fea94 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1e97712696e5c40b28bc1e35987fea94">transpose</a> () const</td></tr>
<tr class="memdesc:a1e97712696e5c40b28bc1e35987fea94 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the transpose of a 2D matrix.  <a href="classcsl_1_1Abstract.html#a1e97712696e5c40b28bc1e35987fea94">More...</a><br /></td></tr>
<tr class="separator:a1e97712696e5c40b28bc1e35987fea94 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c42723e8bc6334c99f00898cc1d59d7 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a8c42723e8bc6334c99f00898cc1d59d7"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hermitian</b> () const</td></tr>
<tr class="separator:a8c42723e8bc6334c99f00898cc1d59d7 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faf1ffd8cb3b6c721e128980c0303d8 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4faf1ffd8cb3b6c721e128980c0303d8">symmetrise</a> () const</td></tr>
<tr class="memdesc:a4faf1ffd8cb3b6c721e128980c0303d8 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the symmetrization of a 2D matrix.  <a href="classcsl_1_1Abstract.html#a4faf1ffd8cb3b6c721e128980c0303d8">More...</a><br /></td></tr>
<tr class="separator:a4faf1ffd8cb3b6c721e128980c0303d8 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd972aed8326d4c13534594e061ee6da inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#acd972aed8326d4c13534594e061ee6da">antisymmetrise</a> () const</td></tr>
<tr class="memdesc:acd972aed8326d4c13534594e061ee6da inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the anti-symmetrization of a 2D matrix.  <a href="classcsl_1_1Abstract.html#acd972aed8326d4c13534594e061ee6da">More...</a><br /></td></tr>
<tr class="separator:acd972aed8326d4c13534594e061ee6da inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b68943aa7ecf60a63af0f2f368eef8f inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1b68943aa7ecf60a63af0f2f368eef8f">inverseMatrix</a> () const</td></tr>
<tr class="memdesc:a1b68943aa7ecf60a63af0f2f368eef8f inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the inverse of a 2D square matrix. The applied method is: A^{-1} = 1/det(A)*Com(A)^T.  <a href="classcsl_1_1Abstract.html#a1b68943aa7ecf60a63af0f2f368eef8f">More...</a><br /></td></tr>
<tr class="separator:a1b68943aa7ecf60a63af0f2f368eef8f inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d3ab932182226f4670a62bbb22af4e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a61d3ab932182226f4670a62bbb22af4e"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyDiracDelta</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;) const</td></tr>
<tr class="separator:a61d3ab932182226f4670a62bbb22af4e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff2950fc8ca319f87a730450f14545 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a59ff2950fc8ca319f87a730450f14545">operator=</a> (double t_value)</td></tr>
<tr class="memdesc:a59ff2950fc8ca319f87a730450f14545 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the <a class="el" href="classcsl_1_1Abstract.html#aaf7f0692cb84ca861a5b3b641bea518b" title="Sets the value if there is one (for Numerical and Literal valued). ">setValue()</a> function.  <a href="classcsl_1_1Abstract.html#a59ff2950fc8ca319f87a730450f14545">More...</a><br /></td></tr>
<tr class="separator:a59ff2950fc8ca319f87a730450f14545 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8334e14cd5789168b037d3888ed60edd inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a8334e14cd5789168b037d3888ed60edd">operator==</a> (int t_value) const</td></tr>
<tr class="separator:a8334e14cd5789168b037d3888ed60edd inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d929e34039e817e464abc560bd4a9d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a12d929e34039e817e464abc560bd4a9d">operator==</a> (double t_value) const</td></tr>
<tr class="separator:a12d929e34039e817e464abc560bd4a9d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b62a6308638064c42da80e9cc2cb7e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af5b62a6308638064c42da80e9cc2cb7e">operator!=</a> (int t_value) const</td></tr>
<tr class="separator:af5b62a6308638064c42da80e9cc2cb7e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fd1b57df371dac7ccfd5a909620e49 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af4fd1b57df371dac7ccfd5a909620e49">operator!=</a> (double t_value) const</td></tr>
<tr class="separator:af4fd1b57df371dac7ccfd5a909620e49 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fa41a5e014f067395467542ee8831 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aee4fa41a5e014f067395467542ee8831"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>testDummy</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:aee4fa41a5e014f067395467542ee8831 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78f0cce24c93def3050743bc5f2845 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a1f78f0cce24c93def3050743bc5f2845"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:a1f78f0cce24c93def3050743bc5f2845 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed43debcac4a19e0da44986774c522bc inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aed43debcac4a19e0da44986774c522bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:aed43debcac4a19e0da44986774c522bc inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376f08c0aa5ffe783090381d102d3ae inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a2376f08c0aa5ffe783090381d102d3ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> &amp;other) const</td></tr>
<tr class="separator:a2376f08c0aa5ffe783090381d102d3ae inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96de5935a58a96d4c5b1e47966488923 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a96de5935a58a96d4c5b1e47966488923"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a96de5935a58a96d4c5b1e47966488923 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99a619abde7e4c58f39e14d4d20fcf5 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac99a619abde7e4c58f39e14d4d20fcf5">operator!=</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:ac99a619abde7e4c58f39e14d4d20fcf5 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="classcsl_1_1Abstract.html#ac99a619abde7e4c58f39e14d4d20fcf5">More...</a><br /></td></tr>
<tr class="separator:ac99a619abde7e4c58f39e14d4d20fcf5 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45206de7c7773b3cb150451ee3eb379e inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a45206de7c7773b3cb150451ee3eb379e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:a45206de7c7773b3cb150451ee3eb379e inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3495220202bd417c1b58249c923f39 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a0d3495220202bd417c1b58249c923f39"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> &amp;other) const</td></tr>
<tr class="separator:a0d3495220202bd417c1b58249c923f39 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8331053065d1be2da89e70c45d24863 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa8331053065d1be2da89e70c45d24863">operator[]</a> (int iArg) const</td></tr>
<tr class="memdesc:aa8331053065d1be2da89e70c45d24863 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, equivalent to the function <a class="el" href="classcsl_1_1Abstract.html#ac33a42309d629d47bfdbede4e152414e">getArgument()</a>.  <a href="classcsl_1_1Abstract.html#aa8331053065d1be2da89e70c45d24863">More...</a><br /></td></tr>
<tr class="separator:aa8331053065d1be2da89e70c45d24863 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560aa9993d506551c54a8c02d1445814 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a560aa9993d506551c54a8c02d1445814">operator[]</a> (int iArg)</td></tr>
<tr class="memdesc:a560aa9993d506551c54a8c02d1445814 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, returns a reference so this function is not const.  <a href="classcsl_1_1Abstract.html#a560aa9993d506551c54a8c02d1445814">More...</a><br /></td></tr>
<tr class="separator:a560aa9993d506551c54a8c02d1445814 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1ba8dce7fbc19eb98807bd15a279c9 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5c1ba8dce7fbc19eb98807bd15a279c9">operator&lt;</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const =0</td></tr>
<tr class="memdesc:a5c1ba8dce7fbc19eb98807bd15a279c9 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#a5c1ba8dce7fbc19eb98807bd15a279c9">More...</a><br /></td></tr>
<tr class="separator:a5c1ba8dce7fbc19eb98807bd15a279c9 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e19587260a07dba65cf2a985e05516b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a6e19587260a07dba65cf2a985e05516b">operator&lt;</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:a6e19587260a07dba65cf2a985e05516b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#a6e19587260a07dba65cf2a985e05516b">More...</a><br /></td></tr>
<tr class="separator:a6e19587260a07dba65cf2a985e05516b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485c6f3e10db539a70416cd0766b117d inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a485c6f3e10db539a70416cd0766b117d">operator&gt;</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a485c6f3e10db539a70416cd0766b117d inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#a485c6f3e10db539a70416cd0766b117d">More...</a><br /></td></tr>
<tr class="separator:a485c6f3e10db539a70416cd0766b117d inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab305bdf49212f03781e7f98024faeb66 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="ab305bdf49212f03781e7f98024faeb66"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:ab305bdf49212f03781e7f98024faeb66 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1660498f2638f5e490d6e512eb32f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a2a1660498f2638f5e490d6e512eb32f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a2a1660498f2638f5e490d6e512eb32f4 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8883df19d7538b68fa96aadac9dfa9 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4c8883df19d7538b68fa96aadac9dfa9">operator&gt;=</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a4c8883df19d7538b68fa96aadac9dfa9 inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#a4c8883df19d7538b68fa96aadac9dfa9">More...</a><br /></td></tr>
<tr class="separator:a4c8883df19d7538b68fa96aadac9dfa9 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcac6df2fd7ac11f336189cf215124b inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#afbcac6df2fd7ac11f336189cf215124b">operator&lt;=</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:afbcac6df2fd7ac11f336189cf215124b inherit pub_methods_classcsl_1_1Abstract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="classcsl_1_1Abstract.html#afbcac6df2fd7ac11f336189cf215124b">More...</a><br /></td></tr>
<tr class="separator:afbcac6df2fd7ac11f336189cf215124b inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b931f7b159d57bad26ca9c9ea729aa1 inherit pub_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a6b931f7b159d57bad26ca9c9ea729aa1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:a6b931f7b159d57bad26ca9c9ea729aa1 inherit pub_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad78eb0b8122b22db79ea59b4af50f7c7"><td class="memItemLeft" align="right" valign="top"><a id="ad78eb0b8122b22db79ea59b4af50f7c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>comparePermutations</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> perm1, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> perm2) const</td></tr>
<tr class="separator:ad78eb0b8122b22db79ea59b4af50f7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cf39f1c6deadcb0191a78d32c3b441"><td class="memItemLeft" align="right" valign="top"><a id="a44cf39f1c6deadcb0191a78d32c3b441"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>selfCheckAutoIndices</b> ()</td></tr>
<tr class="separator:a44cf39f1c6deadcb0191a78d32c3b441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfaf24db5ee68ab64a2378248fdf7e4"><td class="memItemLeft" align="right" valign="top"><a id="afbfaf24db5ee68ab64a2378248fdf7e4"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>applySelfStructureOn</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const override</td></tr>
<tr class="separator:afbfaf24db5ee68ab64a2378248fdf7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2605b68051617e35fc2a443c2b38a2c"><td class="memItemLeft" align="right" valign="top"><a id="aa2605b68051617e35fc2a443c2b38a2c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjustMetricDeltaParent</b> ()</td></tr>
<tr class="separator:aa2605b68051617e35fc2a443c2b38a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e95236b2898d885c6d03ba9de17bdbf"><td class="memItemLeft" align="right" valign="top"><a id="a1e95236b2898d885c6d03ba9de17bdbf"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>applyBrokenIndices</b> (std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">Parent</a> &gt; &amp;brokenParents, const <a class="el" href="classcsl_1_1Space.html">Space</a> *broken, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;newSpaces, const std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;indices) const</td></tr>
<tr class="separator:a1e95236b2898d885c6d03ba9de17bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcsl_1_1Complexified"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcsl_1_1Complexified')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcsl_1_1Complexified.html">csl::Complexified</a></td></tr>
<tr class="memitem:ac8174f246df45364467fffd925027808 inherit pro_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a id="ac8174f246df45364467fffd925027808"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyComplexPropertiesOn</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:ac8174f246df45364467fffd925027808 inherit pro_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2b037721656af10cb29a077a567b30 inherit pro_methods_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a id="a7b2b037721656af10cb29a077a567b30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyComplexPropertiesOn</b> (unique_Expr &amp;expr) const</td></tr>
<tr class="separator:a7b2b037721656af10cb29a077a567b30 inherit pro_methods_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7f7b50e1bbd4157e8b2797740aa31b89"><td class="memItemLeft" align="right" valign="top"><a id="a7f7b50e1bbd4157e8b2797740aa31b89"></a>
<a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html#a7f7b50e1bbd4157e8b2797740aa31b89">index</a></td></tr>
<tr class="memdesc:a7f7b50e1bbd4157e8b2797740aa31b89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1IndexStructure.html" title="Manages a std::vector of Index, to be used by an TensorElement. ">IndexStructure</a> of the tensor. <br /></td></tr>
<tr class="separator:a7f7b50e1bbd4157e8b2797740aa31b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcsl_1_1AbstractElement"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcsl_1_1AbstractElement')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcsl_1_1AbstractElement.html">csl::AbstractElement</a></td></tr>
<tr class="memitem:a5ad0a45c8a069be5e3e0ce21b784bb0b inherit pro_attribs_classcsl_1_1AbstractElement"><td class="memItemLeft" align="right" valign="top"><a id="a5ad0a45c8a069be5e3e0ce21b784bb0b"></a>
<a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html#a5ad0a45c8a069be5e3e0ce21b784bb0b">parent</a></td></tr>
<tr class="memdesc:a5ad0a45c8a069be5e3e0ce21b784bb0b inherit pro_attribs_classcsl_1_1AbstractElement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the parent that gave birth to this element. <br /></td></tr>
<tr class="separator:a5ad0a45c8a069be5e3e0ce21b784bb0b inherit pro_attribs_classcsl_1_1AbstractElement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcsl_1_1Complexified"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcsl_1_1Complexified')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcsl_1_1Complexified.html">csl::Complexified</a></td></tr>
<tr class="memitem:a785754f2eac5813fcf8aa87cc0b456bf inherit pro_attribs_classcsl_1_1Complexified"><td class="memItemLeft" align="right" valign="top"><a id="a785754f2eac5813fcf8aa87cc0b456bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>conjugated</b> = false</td></tr>
<tr class="separator:a785754f2eac5813fcf8aa87cc0b456bf inherit pro_attribs_classcsl_1_1Complexified"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa4121a9ef36e5e994c6377b7639c2499"><td class="memTemplParams" colspan="2"><a id="aa4121a9ef36e5e994c6377b7639c2499"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aa4121a9ef36e5e994c6377b7639c2499"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tensorelement_s</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:aa4121a9ef36e5e994c6377b7639c2499"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classcsl_1_1Abstract"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcsl_1_1Abstract')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a></td></tr>
<tr class="memitem:aba5ef083016b2f3d9e6271f864b9b063 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="aba5ef083016b2f3d9e6271f864b9b063"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularName</b> (std::string const &amp;name)</td></tr>
<tr class="separator:aba5ef083016b2f3d9e6271f864b9b063 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8421d402d5ba82257188b545e8d668 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a1a8421d402d5ba82257188b545e8d668"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularName</b> (std::string_view name)</td></tr>
<tr class="separator:a1a8421d402d5ba82257188b545e8d668 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aab87c41acafaf1b1837b922495560d inherit pub_static_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a8aab87c41acafaf1b1837b922495560d"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularLiteral</b> (std::string const &amp;name)</td></tr>
<tr class="separator:a8aab87c41acafaf1b1837b922495560d inherit pub_static_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe749450d2e610199801b189dc3d0f8 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memItemLeft" align="right" valign="top"><a id="a2fe749450d2e610199801b189dc3d0f8"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularLiteral</b> (std::string_view name)</td></tr>
<tr class="separator:a2fe749450d2e610199801b189dc3d0f8 inherit pub_static_methods_classcsl_1_1Abstract"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specialization of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> for Indicial tensor. Building block carrying indices, and respecting Einstein's summation convention. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b29839ab99dd106e336ce900023d18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b29839ab99dd106e336ce900023d18a">&#9670;&nbsp;</a></span>TensorElement() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">csl::TensorElement::TensorElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>t_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;&#160;</td>
          <td class="paramname"><em>t_parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor called by an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a>, for a tensor with one index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>(Only) index of the tensor. </td></tr>
    <tr><td class="paramname">t_parent</td><td>Pointer to the <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> creating the tensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2169c4eabe165be2f0c455f658a0036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2169c4eabe165be2f0c455f658a0036">&#9670;&nbsp;</a></span>TensorElement() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">csl::TensorElement::TensorElement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;&#160;</td>
          <td class="paramname"><em>t_parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor called by an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a>, for a tensor with several indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>List of indices for the tensor. </td></tr>
    <tr><td class="paramname">t_parent</td><td>Pointer to the <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> creating the tensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bba3e8ce7e864a2921ad91e4019454c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bba3e8ce7e864a2921ad91e4019454c">&#9670;&nbsp;</a></span>TensorElement() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">csl::TensorElement::TensorElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;&#160;</td>
          <td class="paramname"><em>t_parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor called by an <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a>, for a tensor with several indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>List of indices for the tensor in the form of an already created <a class="el" href="classcsl_1_1IndexStructure.html" title="Manages a std::vector of Index, to be used by an TensorElement. ">IndexStructure</a>. </td></tr>
    <tr><td class="paramname">t_parent</td><td>Pointer to the <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> creating the tensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d45c8d308213ea65d46f9aeab883d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d45c8d308213ea65d46f9aeab883d9f">&#9670;&nbsp;</a></span>TensorElement() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::TensorElement::TensorElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *&amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from an Abstract*. Works only if the pointer points to another <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f78788e311f00a646e933b102fe365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f78788e311f00a646e933b102fe365c">&#9670;&nbsp;</a></span>TensorElement() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::TensorElement::TensorElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>. Works only if the pointer points to another <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad5ced3cf2d59c5ae12d9844a81877ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ced3cf2d59c5ae12d9844a81877ae9">&#9670;&nbsp;</a></span>addProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::TensorElement::addProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a property to the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The new property to add in <b>props</b>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a9cbf5ecfe10b79ecbe840ded8c3d8ced">csl::Abstract</a>.</p>

</div>
</div>
<a id="ad6f100f8c15bee5c29d97d40549a6e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f100f8c15bee5c29d97d40549a6e18">&#9670;&nbsp;</a></span>applyPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::TensorElement::applyPermutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>permutations</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a permutation of the indices on a copy of the <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>, and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutations</td><td><a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> to apply on the new <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a6ec375934423dbb60f6d00ea13ec7f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec375934423dbb60f6d00ea13ec7f80">&#9670;&nbsp;</a></span>askTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::TensorElement::askTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the term <b>expr</b> can be factorized out from the <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>, i.e. if <b>expr</b> is equal to the tensor to (may be) a renaming of index. </p>
<p>If <b>exact</b> is set to <b>true</b>, the function returns <b>true</b> if the <a class="el" href="classcsl_1_1IndexStructure.html" title="Manages a std::vector of Index, to be used by an TensorElement. ">IndexStructure</a> matches exactly. Else, the <a class="el" href="classcsl_1_1Comparator.html#ab82c75000df87b5832f77e034d064656" title="Compares two expressions considering that the index structures must match no matter the names of free...">Comparator::freeIndexComparison()</a> function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Term to compare. </td></tr>
    <tr><td class="paramname">exact</td><td>Tells if the comparison must be exact regarding indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> can be factorized out. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a27ad666bf7d533607da9675b0c645ee9">csl::Abstract</a>.</p>

</div>
</div>
<a id="ad9d1474eb8d1c53835ffb3891e01b020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d1474eb8d1c53835ffb3891e01b020">&#9670;&nbsp;</a></span>checkIndexStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::TensorElement::checkIndexStructure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>A std::vector of <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two structures match. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aa0c316b059cb2a1e3020310b148f921b">csl::Abstract</a>.</p>

</div>
</div>
<a id="acd1ac409b891dd033c1792f5473d8d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1ac409b891dd033c1792f5473d8d10">&#9670;&nbsp;</a></span>compareWithDummy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::TensorElement::compareWithDummy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classcsl_1_1Index.html">Index</a>, <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAllCosntraints</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to compare. </td></tr>
    <tr><td class="paramname">constraints</td><td>List of existing constraints between indices (it is modified in the function).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if expr == *this taking constraints into account. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a7caee12abb451168149779a668dfc59e">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#ac28ceccb0fea566ae54b2d01b70548f5">csl::TDerivativeElement</a>, and <a class="el" href="classcsl_1_1TensorFieldElement.html#a7568ac709f768fc70a4797731b7d9e7a">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a2a301cd1beb0eecde2b83c1ca6167c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a301cd1beb0eecde2b83c1ca6167c59">&#9670;&nbsp;</a></span>contraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::TensorElement::contraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a special contraction of indices. Before calling this function we must check that there is indeed a contraction by calling the function <a class="el" href="classcsl_1_1TensorElement.html#a511992d33dc54c1fb8d0c4c17afa5f8c" title="Tells (for an Indicial type) if there is a special contraction property with B. ">hasContractionProperty()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>Expression with which <b>*this</b> contracts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the contraction. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#ad874fc858295a737e6ce884530f1109b">csl::Abstract</a>.</p>

</div>
</div>
<a id="a22a5c9686859930af78f51a85b31160d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a5c9686859930af78f51a85b31160d">&#9670;&nbsp;</a></span>dependsExplicitlyOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::TensorElement::dependsExplicitlyOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check recursively if <b>expr</b> is present in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is found. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#ac3c9887977249e4d71ea36c6377b3581">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#af76375171fcd6824d8410030fb2d5c28">csl::TDerivativeElement</a>, and <a class="el" href="classcsl_1_1TensorFieldElement.html#a43644a7030777b98a28cbaa15f229bfa">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a14ad4f8a47af9ea009bcea3385e45bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ad4f8a47af9ea009bcea3385e45bc3">&#9670;&nbsp;</a></span>dependsOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::TensorElement::dependsOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check recursively if the expression depends on <b>expr</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if a dependency in <b>expr</b> is found. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a40fe2ccf376dadd21b2d7a0f134d86c6">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#a618856543c22406e8c7eed5b8a5a9c65">csl::TDerivativeElement</a>, and <a class="el" href="classcsl_1_1TensorFieldElement.html#ab452e8d298be5e58e28e92aa6eca1c25">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a7a1fc7737cce9da527d3796d2fd711d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1fc7737cce9da527d3796d2fd711d8">&#9670;&nbsp;</a></span>derive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::TensorElement::derive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the derivative of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another. </p>
<p>It is possible to derive wrt any complicated expr. In this case however, the calculation is <b>not</b> <b>always</b> <b>mathematically</b> <b>correct</b>. The program just searches for equal <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> or <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with the same name. In particular dx/d(exp(x))=0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression wrt which we derive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aecab8c872023a2d0771e7e4f83bb05f8">csl::Abstract</a>.</p>

</div>
</div>
<a id="aaaa0e8d228945bad2ef6a8474a6df0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa0e8d228945bad2ef6a8474a6df0c0">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::TensorElement::evaluate </td>
          <td>(</td>
          <td class="paramtype">csl::eval::mode&#160;</td>
          <td class="paramname"><em>user_mode</em> = <code>csl::eval::base</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>Replaces all variables by their value and evaluating. This function must be used instead of <a class="el" href="classcsl_1_1Abstract.html#a543d5a4f0432e166b492ad28a860a65f" title="Evaluates the value of the Abstract. ">evaluateScalar()</a> when treating not only real scalars.* In particular (x=2, y=3) x+iy evaluates to 3+ 3i whereas <a class="el" href="classcsl_1_1Abstract.html#a543d5a4f0432e166b492ad28a860a65f" title="Evaluates the value of the Abstract. ">evaluateScalar()</a> would return 3. </p><dl class="section return"><dt>Returns</dt><dd>The abstract result of the evaluation. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1AbstractElement.html#ad0583927014b475eb57853429c91df20">csl::AbstractElement</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorFieldElement.html#a55ad56ca57e69bdcb5b77e6d0bf254c7">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a0916129965c1d6117aa613fa8c2b42ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0916129965c1d6117aa613fa8c2b42ea">&#9670;&nbsp;</a></span>getAlternateForms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::TensorElement::getAlternateForms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x). </p>
<p>Those alternate forms are then compared in terms of simplicity, this allows automatic simplification. Alternates are tried to simplify, and the bests are chosed. More details and algorithms in file alternateForms.cpp. </p><dl class="section return"><dt>Returns</dt><dd>A std::vector containing the alternate forms of the expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#afcbcb9dd55c73dbcbfe8c091d3e5c02e">csl::Abstract</a>.</p>

</div>
</div>
<a id="a684ed9584f9bbe4ffc1e842b84a05ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684ed9584f9bbe4ffc1e842b84a05ed0">&#9670;&nbsp;</a></span>getComplexConjugate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::TensorElement::getComplexConjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the complex conjugate of the expression. </p>
<dl class="section return"><dt>Returns</dt><dd>{*this}. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Complexified.html#a9d3fec789b00de1625df53232da4cf30">csl::Complexified</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#a1b6a2e64b07222e4d5d126d2281c4816">csl::TDerivativeElement</a>.</p>

</div>
</div>
<a id="a029c4358822daed54f4f775032896790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029c4358822daed54f4f775032896790">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Index.html">Index</a> csl::TensorElement::getIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Spot of the index to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the i^{th} index of an <b>Indicial</b> expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a3234ce243f6a2e11950be42f10100943">csl::Abstract</a>.</p>

</div>
</div>
<a id="a3dc05ca45a03e8a7f8459812e07b85f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc05ca45a03e8a7f8459812e07b85f6">&#9670;&nbsp;</a></span>getIndexStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> csl::TensorElement::getIndexStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The index structure of the <b>Indicial</b> expression </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#ae125a32b6f3d0368b6055d4e58c1ff3f">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#aab730479855c747fa6baafe4c50ca8cf">csl::TDerivativeElement</a>.</p>

</div>
</div>
<a id="a5ddd03efb94ea0017def76cd6777f745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddd03efb94ea0017def76cd6777f745">&#9670;&nbsp;</a></span>getNIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::TensorElement::getNIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of indices of an <b>Indicial</b> expression. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#add364193f7a78ac28f7001c7f4036453">csl::Abstract</a>.</p>

</div>
</div>
<a id="aa0f1ab4f63aa28f3c759a666fb15636a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f1ab4f63aa28f3c759a666fb15636a">&#9670;&nbsp;</a></span>getPermutations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::TensorElement::getPermutations </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::vector of all possible permutations of an <b>Indicial</b> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector containing all possible permutations of the tensor. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a946d175d946da102c5f4cc91840703cb">csl::Abstract</a>.</p>

</div>
</div>
<a id="a1c246057031fbc18868bac66d13be37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c246057031fbc18868bac66d13be37c">&#9670;&nbsp;</a></span>getPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a> csl::TensorElement::getPrimaryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>primary</b> <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (single number, scalar function with one argument, with multiple argumments, a <a class="el" href="classcsl_1_1Vector.html">Vector</a>, etc) in order to do special treatments or simplifications. </p><dl class="section return"><dt>Returns</dt><dd>type (a non memorized integer corresponding to the type of abstract) </dd></dl>

<p>Implements <a class="el" href="classcsl_1_1Abstract.html#a8ab79682cdff4c7d7b52c2e70ac23d85">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorFieldElement.html#aab050fd18460d4842d8972a990363b0c">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a8ab3f38235ce39d3d2f1361eba25fb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab3f38235ce39d3d2f1361eba25fb3e">&#9670;&nbsp;</a></span>getProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classcsl_1_1Equation.html">Equation</a> * &gt; &amp; csl::TensorElement::getProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The properties of the object. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aca85809fef9dddefa5f9e06c3b25215d">csl::Abstract</a>.</p>

</div>
</div>
<a id="a7b99f83fdff13fb508ea8e671d4dc834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b99f83fdff13fb508ea8e671d4dc834">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a> csl::TensorElement::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (cos, product, number, etc) in order to do special treatments or simplifications. </p><dl class="section return"><dt>Returns</dt><dd>type (a non memorized integer corresponding to the type of abstract) </dd></dl>

<p>Implements <a class="el" href="classcsl_1_1Abstract.html#aa781456c3f801b37ce169c83514c51c1">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#a16ff4a3a49daf68786abbe407d1d5b8c">csl::TDerivativeElement</a>, and <a class="el" href="classcsl_1_1TensorFieldElement.html#ab78b88ff1b49707ee98aee3211214044">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a511992d33dc54c1fb8d0c4c17afa5f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511992d33dc54c1fb8d0c4c17afa5f8c">&#9670;&nbsp;</a></span>hasContractionProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::TensorElement::hasContractionProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells (for an Indicial type) if there is a special contraction property with <b>B</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>Expression with which we test if there is a special contraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if there is a contraction. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aa31e08c251d96b8ea8ec8d385895c1ff">csl::Abstract</a>.</p>

</div>
</div>
<a id="acc36470e69d6edf43f6dd7b6db0365d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc36470e69d6edf43f6dd7b6db0365d2">&#9670;&nbsp;</a></span>isIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::TensorElement::isIndexed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is indexed. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a216b7bd3930fbf047e5bf8f69e9b964c">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorFieldElement.html#a9bc54de57d7301838f673c014ed9d79f">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a6ada509cc19d2040553f8f40621914db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ada509cc19d2040553f8f40621914db">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::TensorElement::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another. </p>
<p>Here if two Abstracts have the same name, the function will return <b>true</b> even if they are <b>not</b> <b>mathematically</b> <b>equal</b>. So beware not to name different things the same way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two Abstracts are the same (or have the same name). </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Complexified.html#a10b02cb2da960264c19926a76a859488">csl::Complexified</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#a380f7ce153c1b608c232e86f79bdcbd0">csl::TDerivativeElement</a>, and <a class="el" href="classcsl_1_1TensorFieldElement.html#af7cde5cfd23cb3b4ca4ddbdbcf717db9">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a94e94f9e6ad8f67fafb25268c64512fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e94f9e6ad8f67fafb25268c64512fa">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::TensorElement::print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lib</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays the abstract in standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classcsl_1_1Abstract.html#a9995ebe97bf73c098ee1dc18b7837660">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#a458a8098137ea92aaa5a8b5f4abd46a7">csl::TDerivativeElement</a>, and <a class="el" href="classcsl_1_1TensorFieldElement.html#a3e1469844675af273bdfcc7583e48e55">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="a5e4794abc02ba5d8f80f76f64e9cab9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4794abc02ba5d8f80f76f64e9cab9c">&#9670;&nbsp;</a></span>printLaTeX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string csl::TensorElement::printLaTeX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a LaTeX output for the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string corresponding to the LaTeX output. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#aa067d4a97135bfe2052a7e21c28f75be">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#aa3b01cb3bd1dcef5901cc82ec29c66b3">csl::TDerivativeElement</a>, and <a class="el" href="classcsl_1_1TensorFieldElement.html#ac36fad3d18e46c353b4d961867d257cf">csl::TensorFieldElement</a>.</p>

</div>
</div>
<a id="aa74f724e7aa9bdf2778767aca7eba51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74f724e7aa9bdf2778767aca7eba51b">&#9670;&nbsp;</a></span>removeProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::TensorElement::removeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a property to the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>Property to remove from <b>props</b>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a70d31d945e2012d108dfc3ce3eb48161">csl::Abstract</a>.</p>

</div>
</div>
<a id="a02fe69a766b8eade9d5de6cbea8054a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fe69a766b8eade9d5de6cbea8054a6">&#9670;&nbsp;</a></span>replaceIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::TensorElement::replaceIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>indexToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>newIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refresh</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For indicial expressions, this function searches <b>indexToContract</b> and replaces it with newIndex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexToContract</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> that is newly contracted. </td></tr>
    <tr><td class="paramname">newIndex</td><td>Dummy new index that replaces <b>indexToContract</b> in the expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the index has been found. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#acc0eb077e25c9a67d15269cf8d5f0511">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#ae304eceb527459e79e9cc635350b1a70">csl::TDerivativeElement</a>.</p>

</div>
</div>
<a id="a387f69126ae40d711755945ef023de92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387f69126ae40d711755945ef023de92">&#9670;&nbsp;</a></span>setIndexStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::TensorElement::setIndexStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>t_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the index structure of the object, that must be an <b>Indicial</b> expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>A std::vector of <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> which takes the place of the structure index. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcsl_1_1Abstract.html#a70f946f9c59df045ef7416320ade89c7">csl::Abstract</a>.</p>

<p>Reimplemented in <a class="el" href="classcsl_1_1TDerivativeElement.html#ae976c5be78ef54ca485001a9807d75bc">csl::TDerivativeElement</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="indicial_8h_source.html">indicial.h</a></li>
<li>src/alternateForms.cpp</li>
<li>src/indicial.cpp</li>
<li>src/simplification.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
