<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSL: csl::Abstract Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image.png" href="../../../logo-marty.png"/>
<link href="style_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
      <a href="https://marty.in2p3.fr"><img alt="Logo" src="Logo1.svg" height=100px/></a></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">
       Documentation of <i><b>CSL</b></i>
   </div>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecsl.html">csl</a></li><li class="navelem"><a class="el" href="classcsl_1_1Abstract.html">Abstract</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">csl::Abstract Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><b>Root</b> class of the inheritance tree of abstracts.  
 <a href="classcsl_1_1Abstract.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="abstract_8h_source.html">abstract.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for csl::Abstract:</div>
<div class="dyncontent">
<div class="center"><img src="classcsl_1_1Abstract__inherit__graph.png" border="0" usemap="#csl_1_1Abstract_inherit__map" alt="Inheritance graph"/></div>
<map name="csl_1_1Abstract_inherit__map" id="csl_1_1Abstract_inherit__map">
<area shape="rect" id="node2" href="classcsl_1_1AbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e..." alt="" coords="149,259,324,285"/>
<area shape="rect" id="node12" href="classcsl_1_1AbstractDuoFunc.html" title="Handle functions of multiple arguments. In the case of the call of a simplification function..." alt="" coords="162,436,311,463"/>
<area shape="rect" id="node20" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. " alt="" coords="174,1009,299,1036"/>
<area shape="rect" id="node42" href="classcsl_1_1AbstractMultiFunc.html" title="Handle functions of multiple arguments. In the case of the call of a simplification function..." alt="" coords="160,1516,313,1543"/>
<area shape="rect" id="node46" href="classcsl_1_1AbstractVectorial.html" title="csl::AbstractVectorial" alt="" coords="163,1668,310,1695"/>
<area shape="rect" id="node3" href="classcsl_1_1AbstractNumerical.html" title="Abstract class from which derive numerical types, i.e. Float, Integer, IntFraction. " alt="" coords="394,132,549,159"/>
<area shape="rect" id="node9" href="classcsl_1_1Complexified.html" title="csl::Complexified" alt="" coords="410,259,533,285"/>
<area shape="rect" id="node4" href="classcsl_1_1Complex.html" title="csl::Complex" alt="" coords="641,5,740,32"/>
<area shape="rect" id="node5" href="classcsl_1_1Float.html" title="Handle numbers in expr. " alt="" coords="653,56,729,83"/>
<area shape="rect" id="node6" href="classcsl_1_1Integer.html" title="Handle numbers in expr. " alt="" coords="647,107,734,133"/>
<area shape="rect" id="node7" href="classcsl_1_1IntFraction.html" title="Handles fractions of Number. " alt="" coords="636,157,745,184"/>
<area shape="rect" id="node8" href="classcsl_1_1NumericalEval.html" title="csl::NumericalEval" alt="" coords="625,208,757,235"/>
<area shape="rect" id="node10" href="classcsl_1_1AbstractElement.html" title="Base class for all elements. Objects that are constructed by a parent (see AbstractParent) when the u..." alt="" coords="619,259,763,285"/>
<area shape="rect" id="node11" href="classcsl_1_1AbstractLiteral.html" title="Abstract class from which derive literal building blocks: Constant, Variable, Imaginary and IntFactor..." alt="" coords="625,309,756,336"/>
<area shape="rect" id="node13" href="classcsl_1_1Angle.html" title="Handles a angle of 2 arguments. " alt="" coords="431,309,511,336"/>
<area shape="rect" id="node14" href="classcsl_1_1Commutator.html" title="Object that represents a commutator or an anti&#45;commutator, thus is derived from AbstractDuoFunc that ..." alt="" coords="412,360,531,387"/>
<area shape="rect" id="node15" href="classcsl_1_1Pow.html" title="Handles the exponentiation of one Abstract wrt another. " alt="" coords="435,411,508,437"/>
<area shape="rect" id="node16" href="classcsl_1_1Scalar.html" title="csl::Scalar" alt="" coords="429,461,513,488"/>
<area shape="rect" id="node17" href="classcsl_1_1Operator.html" title="csl::Operator\&lt; AbstractDuo\lFunc \&gt;" alt="" coords="380,513,563,554"/>
<area shape="rect" id="node18" href="classcsl_1_1Derivative.html" title="Handles the exponentiation of one Abstract wrt another. " alt="" coords="637,495,744,521"/>
<area shape="rect" id="node19" href="classcsl_1_1Integral.html" title="csl::Integral" alt="" coords="645,545,736,572"/>
<area shape="rect" id="node21" href="classcsl_1_1Abs.html" title="Final specialization of AbstractFunc, the abs function. " alt="" coords="436,579,507,605"/>
<area shape="rect" id="node22" href="classcsl_1_1ACos.html" title="Final specialization of AbstractFunc, the acos function. " alt="" coords="431,629,511,656"/>
<area shape="rect" id="node23" href="classcsl_1_1ACosh.html" title="Final specialization of AbstractFunc, the acosh function. " alt="" coords="428,680,515,707"/>
<area shape="rect" id="node24" href="classcsl_1_1ASin.html" title="Final specialization of AbstractFunc, the asin function. " alt="" coords="434,731,509,757"/>
<area shape="rect" id="node25" href="classcsl_1_1ASinh.html" title="Final specialization of AbstractFunc, the asinh function. " alt="" coords="430,781,513,808"/>
<area shape="rect" id="node26" href="classcsl_1_1ATan.html" title="Final specialization of AbstractFunc, the atan function. " alt="" coords="432,832,511,859"/>
<area shape="rect" id="node27" href="classcsl_1_1ATanh.html" title="Final specialization of AbstractFunc, the atanh function. " alt="" coords="429,883,514,909"/>
<area shape="rect" id="node28" href="classcsl_1_1Cos.html" title="Final specialization of AbstractFunc, the cos function. " alt="" coords="436,933,507,960"/>
<area shape="rect" id="node29" href="classcsl_1_1Cosh.html" title="Final specialization of AbstractFunc, the cosh function. " alt="" coords="432,984,511,1011"/>
<area shape="rect" id="node30" href="classcsl_1_1DiracDelta.html" title="csl::DiracDelta" alt="" coords="417,1035,526,1061"/>
<area shape="rect" id="node31" href="classcsl_1_1Exp.html" title="Final specialization of AbstractFunc, the exponential function. " alt="" coords="436,1085,507,1112"/>
<area shape="rect" id="node32" href="classcsl_1_1Factorial.html" title="Final specialization of AbstractFunc, the factorial function. " alt="" coords="423,1136,520,1163"/>
<area shape="rect" id="node33" href="classcsl_1_1Log.html" title="Final specialization of AbstractFunc, the logarithm function. " alt="" coords="437,1187,505,1213"/>
<area shape="rect" id="node34" href="classcsl_1_1Sin.html" title="Final specialization of AbstractFunc, the sin function. " alt="" coords="438,1237,505,1264"/>
<area shape="rect" id="node35" href="classcsl_1_1Sinh.html" title="Final specialization of AbstractFunc, the sinh function. " alt="" coords="435,1288,508,1315"/>
<area shape="rect" id="node36" href="classcsl_1_1Tan.html" title="Final specialization of AbstractFunc, the tan function. " alt="" coords="437,1339,506,1365"/>
<area shape="rect" id="node37" href="classcsl_1_1Tanh.html" title="Final specialization of AbstractFunc, the tanh function. " alt="" coords="433,1389,509,1416"/>
<area shape="rect" id="node38" href="classcsl_1_1Operator.html" title="csl::Operator\&lt; AbstractFunc \&gt;" alt="" coords="372,1440,571,1467"/>
<area shape="rect" id="node39" href="classcsl_1_1AbstractIntegral.html" title="csl::AbstractIntegral" alt="" coords="621,1389,760,1416"/>
<area shape="rect" id="node40" href="classcsl_1_1ImaginaryPart.html" title="csl::ImaginaryPart" alt="" coords="627,1440,755,1467"/>
<area shape="rect" id="node41" href="classcsl_1_1RealPart.html" title="csl::RealPart" alt="" coords="641,1491,740,1517"/>
<area shape="rect" id="node43" href="classcsl_1_1Polynomial.html" title="Handles a polynomial, function of multiple arguments. " alt="" coords="416,1491,527,1517"/>
<area shape="rect" id="node44" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. " alt="" coords="434,1541,509,1568"/>
<area shape="rect" id="node45" href="classcsl_1_1Sum.html" title="Handles a sum, function of multiple arguments. " alt="" coords="434,1592,509,1619"/>
<area shape="rect" id="node47" href="classcsl_1_1HighDTensor.html" title="csl::HighDTensor" alt="" coords="409,1643,533,1669"/>
<area shape="rect" id="node48" href="classcsl_1_1Matrix.html" title="csl::Matrix" alt="" coords="430,1693,513,1720"/>
<area shape="rect" id="node49" href="classcsl_1_1Vector.html" title="csl::Vector" alt="" coords="429,1744,514,1771"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5fee68c1f3dcbda0e936926fed17616"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad5fee68c1f3dcbda0e936926fed17616">Abstract</a> ()</td></tr>
<tr class="memdesc:ad5fee68c1f3dcbda0e936926fed17616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#ad5fee68c1f3dcbda0e936926fed17616">More...</a><br /></td></tr>
<tr class="separator:ad5fee68c1f3dcbda0e936926fed17616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bdc4c76fdbbf3cbac3af4dce8286ed"><td class="memItemLeft" align="right" valign="top"><a id="a40bdc4c76fdbbf3cbac3af4dce8286ed"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a40bdc4c76fdbbf3cbac3af4dce8286ed">~Abstract</a> ()</td></tr>
<tr class="memdesc:a40bdc4c76fdbbf3cbac3af4dce8286ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a40bdc4c76fdbbf3cbac3af4dce8286ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c796713828ebfb74a7d8787d7802a76"><td class="memItemLeft" align="right" valign="top"><a id="a5c796713828ebfb74a7d8787d7802a76"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> ()</td></tr>
<tr class="separator:a5c796713828ebfb74a7d8787d7802a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9995ebe97bf73c098ee1dc18b7837660"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9995ebe97bf73c098ee1dc18b7837660">print</a> (int mode=0, std::ostream &amp;out=std::cout, bool lib=false) const =0</td></tr>
<tr class="memdesc:a9995ebe97bf73c098ee1dc18b7837660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the abstract in standard output.  <a href="#a9995ebe97bf73c098ee1dc18b7837660">More...</a><br /></td></tr>
<tr class="separator:a9995ebe97bf73c098ee1dc18b7837660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2910dd30d90915c11d48c01cab618dda"><td class="memItemLeft" align="right" valign="top"><a id="a2910dd30d90915c11d48c01cab618dda"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>printCode</b> (int mode=0, std::ostream &amp;out=std::cout) const</td></tr>
<tr class="separator:a2910dd30d90915c11d48c01cab618dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0645745feacf93470963b55f93cae1c0"><td class="memItemLeft" align="right" valign="top"><a id="a0645745feacf93470963b55f93cae1c0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>printProp</b> (std::ostream &amp;fout=std::cout) const</td></tr>
<tr class="separator:a0645745feacf93470963b55f93cae1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e45ffc7b65f92e77e592f76f70934c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a89e45ffc7b65f92e77e592f76f70934c">printExplicit</a> (int mode=0) const</td></tr>
<tr class="memdesc:a89e45ffc7b65f92e77e592f76f70934c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays explicitely the expression, with types of each component. This function is only used for debug.  <a href="#a89e45ffc7b65f92e77e592f76f70934c">More...</a><br /></td></tr>
<tr class="separator:a89e45ffc7b65f92e77e592f76f70934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa067d4a97135bfe2052a7e21c28f75be"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa067d4a97135bfe2052a7e21c28f75be">printLaTeX</a> (int mode=0) const</td></tr>
<tr class="memdesc:aa067d4a97135bfe2052a7e21c28f75be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a LaTeX output for the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#aa067d4a97135bfe2052a7e21c28f75be">More...</a><br /></td></tr>
<tr class="separator:aa067d4a97135bfe2052a7e21c28f75be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1268716ab52c2d262de309c8ec5328b0"><td class="memItemLeft" align="right" valign="top"><a id="a1268716ab52c2d262de309c8ec5328b0"></a>
virtual std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">Parent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getSubSymbols</b> () const =0</td></tr>
<tr class="separator:a1268716ab52c2d262de309c8ec5328b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652101e34b2efa43114150e9af3c79d5"><td class="memItemLeft" align="right" valign="top"><a id="a652101e34b2efa43114150e9af3c79d5"></a>
virtual <a class="el" href="classcsl_1_1LibDependency.html">LibDependency</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getLibDependency</b> () const</td></tr>
<tr class="separator:a652101e34b2efa43114150e9af3c79d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3978c71035bf1cda50f5b9031d631af"><td class="memItemLeft" align="right" valign="top"><a id="ac3978c71035bf1cda50f5b9031d631af"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>memoryOverhead</b> () const</td></tr>
<tr class="separator:ac3978c71035bf1cda50f5b9031d631af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5e7466e754984a2c4394a112464f7"><td class="memItemLeft" align="right" valign="top">virtual std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af7f5e7466e754984a2c4394a112464f7">getName</a> () const</td></tr>
<tr class="memdesc:af7f5e7466e754984a2c4394a112464f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>'s name.  <a href="#af7f5e7466e754984a2c4394a112464f7">More...</a><br /></td></tr>
<tr class="separator:af7f5e7466e754984a2c4394a112464f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4a302d1a3cbf4dd9394f5e5880d343"><td class="memItemLeft" align="right" valign="top"><a id="a9c4a302d1a3cbf4dd9394f5e5880d343"></a>
virtual std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getLatexName</b> () const</td></tr>
<tr class="separator:a9c4a302d1a3cbf4dd9394f5e5880d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2263731ca94825f35281e69fb258cf87"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a2263731ca94825f35281e69fb258cf87">getCommutable</a> () const</td></tr>
<tr class="memdesc:a2263731ca94825f35281e69fb258cf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to know if the object commutes with all the others.  <a href="#a2263731ca94825f35281e69fb258cf87">More...</a><br /></td></tr>
<tr class="separator:a2263731ca94825f35281e69fb258cf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e067fc57c0c2e70d141079455fdbd7"><td class="memItemLeft" align="right" valign="top"><a id="a77e067fc57c0c2e70d141079455fdbd7"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>getElementary</b> () const</td></tr>
<tr class="separator:a77e067fc57c0c2e70d141079455fdbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021946e84d8c1a019908cac578b16fe8"><td class="memItemLeft" align="right" valign="top"><a id="a021946e84d8c1a019908cac578b16fe8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>getAllDependencies</b> () const</td></tr>
<tr class="separator:a021946e84d8c1a019908cac578b16fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab79682cdff4c7d7b52c2e70ac23d85"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a8ab79682cdff4c7d7b52c2e70ac23d85">getPrimaryType</a> () const =0</td></tr>
<tr class="memdesc:a8ab79682cdff4c7d7b52c2e70ac23d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>primary</b> <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a8ab79682cdff4c7d7b52c2e70ac23d85">More...</a><br /></td></tr>
<tr class="separator:a8ab79682cdff4c7d7b52c2e70ac23d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa781456c3f801b37ce169c83514c51c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa781456c3f801b37ce169c83514c51c1">getType</a> () const =0</td></tr>
<tr class="memdesc:aa781456c3f801b37ce169c83514c51c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#aa781456c3f801b37ce169c83514c51c1">More...</a><br /></td></tr>
<tr class="separator:aa781456c3f801b37ce169c83514c51c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5856c3d55a6d1406970f3656e61efe8e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5856c3d55a6d1406970f3656e61efe8e">getDim</a> () const</td></tr>
<tr class="memdesc:a5856c3d55a6d1406970f3656e61efe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <b>dimension</b> of the object.  <a href="#a5856c3d55a6d1406970f3656e61efe8e">More...</a><br /></td></tr>
<tr class="separator:a5856c3d55a6d1406970f3656e61efe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c068f1da78856321932b6b6ae17dc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad74c068f1da78856321932b6b6ae17dc">isBuildingBlock</a> () const</td></tr>
<tr class="memdesc:ad74c068f1da78856321932b6b6ae17dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is a Building Block or not.  <a href="#ad74c068f1da78856321932b6b6ae17dc">More...</a><br /></td></tr>
<tr class="separator:ad74c068f1da78856321932b6b6ae17dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89eb7b1a9e0259a60154563f3315907"><td class="memItemLeft" align="right" valign="top"><a id="ae89eb7b1a9e0259a60154563f3315907"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getOrderOf</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:ae89eb7b1a9e0259a60154563f3315907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09992d147b39388c8936b3bff648930"><td class="memItemLeft" align="right" valign="top"><a id="ac09992d147b39388c8936b3bff648930"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isArbitrary</b> () const</td></tr>
<tr class="separator:ac09992d147b39388c8936b3bff648930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216b7bd3930fbf047e5bf8f69e9b964c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a216b7bd3930fbf047e5bf8f69e9b964c">isIndexed</a> () const</td></tr>
<tr class="separator:a216b7bd3930fbf047e5bf8f69e9b964c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca85809fef9dddefa5f9e06c3b25215d"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classcsl_1_1Equation.html">Equation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aca85809fef9dddefa5f9e06c3b25215d">getProperties</a> () const</td></tr>
<tr class="separator:aca85809fef9dddefa5f9e06c3b25215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73aba0c48a4b5740f7bfa09e438ca99"><td class="memItemLeft" align="right" valign="top"><a id="ac73aba0c48a4b5740f7bfa09e438ca99"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReal</b> () const</td></tr>
<tr class="separator:ac73aba0c48a4b5740f7bfa09e438ca99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb67e8e96735b8f116d0e7ab33d7be77"><td class="memItemLeft" align="right" valign="top"><a id="acb67e8e96735b8f116d0e7ab33d7be77"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPurelyImaginary</b> () const</td></tr>
<tr class="separator:acb67e8e96735b8f116d0e7ab33d7be77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a594845a29429c9b4f19c92bd18cad"><td class="memItemLeft" align="right" valign="top"><a id="a22a594845a29429c9b4f19c92bd18cad"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isComplexConjugate</b> () const</td></tr>
<tr class="separator:a22a594845a29429c9b4f19c92bd18cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ce38838e35c5785f92373a1d830668"><td class="memItemLeft" align="right" valign="top"><a id="af2ce38838e35c5785f92373a1d830668"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isHermitianConjugate</b> () const</td></tr>
<tr class="separator:af2ce38838e35c5785f92373a1d830668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470d9f1267fba4a82e13af4a39470f81"><td class="memItemLeft" align="right" valign="top"><a id="a470d9f1267fba4a82e13af4a39470f81"></a>
virtual <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getComplexProperty</b> () const</td></tr>
<tr class="separator:a470d9f1267fba4a82e13af4a39470f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35385480a1be08f5e7433535b58ac0b"><td class="memItemLeft" align="right" valign="top"><a id="ae35385480a1be08f5e7433535b58ac0b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setComplexProperty</b> (<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop)</td></tr>
<tr class="separator:ae35385480a1be08f5e7433535b58ac0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ebc247831d6629d44117a490fca120"><td class="memItemLeft" align="right" valign="top"><a id="a37ebc247831d6629d44117a490fca120"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setConjugated</b> (bool t_conjugated)</td></tr>
<tr class="separator:a37ebc247831d6629d44117a490fca120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a014bfd266b5f8471f23580e271979b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9a014bfd266b5f8471f23580e271979b">isInteger</a> () const</td></tr>
<tr class="memdesc:a9a014bfd266b5f8471f23580e271979b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is an integer. Either an <a class="el" href="classcsl_1_1Integer.html" title="Handle numbers in expr. ">Integer</a> object directly, or a <a class="el" href="classcsl_1_1Float.html" title="Handle numbers in expr. ">Float</a> that has an integer value.  <a href="#a9a014bfd266b5f8471f23580e271979b">More...</a><br /></td></tr>
<tr class="separator:a9a014bfd266b5f8471f23580e271979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628563238145f3a9acc331f1a89ce32f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a628563238145f3a9acc331f1a89ce32f">getValued</a> () const</td></tr>
<tr class="memdesc:a628563238145f3a9acc331f1a89ce32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is valued, i.e. is a function of numbers and valued literals (a <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a> or <a class="el" href="classcsl_1_1Constant.html" title="Handle an object with a name and a value. ">Constant</a> is not valued by default).  <a href="#a628563238145f3a9acc331f1a89ce32f">More...</a><br /></td></tr>
<tr class="separator:a628563238145f3a9acc331f1a89ce32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f98ba06476e464e3fd2fce0d1f8243"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a78f98ba06476e464e3fd2fce0d1f8243">getValue</a> () const</td></tr>
<tr class="memdesc:a78f98ba06476e464e3fd2fce0d1f8243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the expression, if it has one <b>explicitely</b>. In particular, it will work only on Numbers and valued Literals, not on functions.  <a href="#a78f98ba06476e464e3fd2fce0d1f8243">More...</a><br /></td></tr>
<tr class="separator:a78f98ba06476e464e3fd2fce0d1f8243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a657baf1c35ed581e9db2c47a71c99"><td class="memItemLeft" align="right" valign="top"><a id="a69a657baf1c35ed581e9db2c47a71c99"></a>
virtual long double&#160;</td><td class="memItemRight" valign="bottom"><b>getDeltaPlus</b> () const</td></tr>
<tr class="separator:a69a657baf1c35ed581e9db2c47a71c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f0e4c9c91f43b5cd61cbb873869eb"><td class="memItemLeft" align="right" valign="top"><a id="aa22f0e4c9c91f43b5cd61cbb873869eb"></a>
virtual long double&#160;</td><td class="memItemRight" valign="bottom"><b>getDeltaMinus</b> () const</td></tr>
<tr class="separator:aa22f0e4c9c91f43b5cd61cbb873869eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed"><td class="memItemLeft" align="right" valign="top">virtual long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed">getNum</a> () const</td></tr>
<tr class="separator:a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9531d78d67c82e288c0130da5b1ba80b"><td class="memItemLeft" align="right" valign="top">virtual long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9531d78d67c82e288c0130da5b1ba80b">getDenom</a> () const</td></tr>
<tr class="separator:a9531d78d67c82e288c0130da5b1ba80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa034448201c9e7998bbbb5e409636b30"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa034448201c9e7998bbbb5e409636b30">getNArgs</a> (int axis=0) const</td></tr>
<tr class="memdesc:aa034448201c9e7998bbbb5e409636b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arguments of the expression. If the expression is a building block (<a class="el" href="classcsl_1_1AbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e...">AbstractBuildingBlock</a>), this function returns 0.  <a href="#aa034448201c9e7998bbbb5e409636b30">More...</a><br /></td></tr>
<tr class="separator:aa034448201c9e7998bbbb5e409636b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3794843945b8a39e2c1be073c9bacdf5"><td class="memItemLeft" align="right" valign="top"><a id="a3794843945b8a39e2c1be073c9bacdf5"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a3794843945b8a39e2c1be073c9bacdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3c3fe5010f24e8a8765ea06415c003"><td class="memItemLeft" align="right" valign="top"><a id="a0c3c3fe5010f24e8a8765ea06415c003"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:a0c3c3fe5010f24e8a8765ea06415c003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad54ed41b2ce9bad3364fe30ad1a0d71"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aad54ed41b2ce9bad3364fe30ad1a0d71">begin</a> ()</td></tr>
<tr class="separator:aad54ed41b2ce9bad3364fe30ad1a0d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e4e80d998a888a1a74d9ea3e10c0f1"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a61e4e80d998a888a1a74d9ea3e10c0f1">end</a> ()</td></tr>
<tr class="separator:a61e4e80d998a888a1a74d9ea3e10c0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff373df9477d4e38581d09cc6d2fee4"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#adff373df9477d4e38581d09cc6d2fee4">begin</a> () const</td></tr>
<tr class="separator:adff373df9477d4e38581d09cc6d2fee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2761d54f13310e13f5076d565edd7ef"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae2761d54f13310e13f5076d565edd7ef">end</a> () const</td></tr>
<tr class="separator:ae2761d54f13310e13f5076d565edd7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33a42309d629d47bfdbede4e152414e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac33a42309d629d47bfdbede4e152414e">getArgument</a> (int iArg=0) const</td></tr>
<tr class="separator:ac33a42309d629d47bfdbede4e152414e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f542034e95744148f4fce5a4893e63"><td class="memItemLeft" align="right" valign="top"><a id="a06f542034e95744148f4fce5a4893e63"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getArgument</b> (int iArg=0)</td></tr>
<tr class="separator:a06f542034e95744148f4fce5a4893e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94b3892af147ac0b05c1d8c960e4eba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad94b3892af147ac0b05c1d8c960e4eba">getArgument</a> (const std::vector&lt; int &gt; &amp;indices) const</td></tr>
<tr class="memdesc:ad94b3892af147ac0b05c1d8c960e4eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension.  <a href="#ad94b3892af147ac0b05c1d8c960e4eba">More...</a><br /></td></tr>
<tr class="separator:ad94b3892af147ac0b05c1d8c960e4eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050aa1cdc4549cbf29181f73a5731cfc"><td class="memItemLeft" align="right" valign="top"><a id="a050aa1cdc4549cbf29181f73a5731cfc"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getArgument</b> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:a050aa1cdc4549cbf29181f73a5731cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83c44ae1e5315a38083bdb7acd8f3fa"><td class="memItemLeft" align="right" valign="top">virtual const csl::vector_expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac83c44ae1e5315a38083bdb7acd8f3fa">getVectorArgument</a> () const</td></tr>
<tr class="memdesc:ac83c44ae1e5315a38083bdb7acd8f3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get the entire std::vector of arguments of the expression.  <a href="#ac83c44ae1e5315a38083bdb7acd8f3fa">More...</a><br /></td></tr>
<tr class="separator:ac83c44ae1e5315a38083bdb7acd8f3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85f810bbadbc792210c958e8f1b2ffb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae85f810bbadbc792210c958e8f1b2ffb">getVariable</a> () const</td></tr>
<tr class="memdesc:ae85f810bbadbc792210c958e8f1b2ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the variable that defines certain types of expressions.  <a href="#ae85f810bbadbc792210c958e8f1b2ffb">More...</a><br /></td></tr>
<tr class="separator:ae85f810bbadbc792210c958e8f1b2ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9500a21d75d03c695ec0c76493600b38"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9500a21d75d03c695ec0c76493600b38">getOrder</a> () const</td></tr>
<tr class="memdesc:a9500a21d75d03c695ec0c76493600b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the order (integer) that defines certain types of expressions.  <a href="#a9500a21d75d03c695ec0c76493600b38">More...</a><br /></td></tr>
<tr class="separator:a9500a21d75d03c695ec0c76493600b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83df1d9dc202457113e5b38bd694fae"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa83df1d9dc202457113e5b38bd694fae">getSign</a> () const</td></tr>
<tr class="separator:aa83df1d9dc202457113e5b38bd694fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9347e75b0cd0b75e0f0a38db93b29d83"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9347e75b0cd0b75e0f0a38db93b29d83">isAnOperator</a> () const</td></tr>
<tr class="memdesc:a9347e75b0cd0b75e0f0a38db93b29d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the expression is an operator (like a derivetive operator).  <a href="#a9347e75b0cd0b75e0f0a38db93b29d83">More...</a><br /></td></tr>
<tr class="separator:a9347e75b0cd0b75e0f0a38db93b29d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464f4f0613db9b4b0a4efe26a3a03d60"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a464f4f0613db9b4b0a4efe26a3a03d60">isEmpty</a> () const</td></tr>
<tr class="memdesc:a464f4f0613db9b4b0a4efe26a3a03d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells for a <a class="el" href="classcsl_1_1Derivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or an <a class="el" href="classcsl_1_1Integral.html">Integral</a> if the argument is empty i.e. if the object must apply on the next argument encountered on the right.  <a href="#a464f4f0613db9b4b0a4efe26a3a03d60">More...</a><br /></td></tr>
<tr class="separator:a464f4f0613db9b4b0a4efe26a3a03d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d9abfa88d9d09a89d3a4becd9e6429"><td class="memItemLeft" align="right" valign="top"><a id="a75d9abfa88d9d09a89d3a4becd9e6429"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>operatorAppliesOn</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a75d9abfa88d9d09a89d3a4becd9e6429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3ec3dfe1fbd8ead5c8d9aca421a863"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9c3ec3dfe1fbd8ead5c8d9aca421a863">getOperand</a> () const</td></tr>
<tr class="memdesc:a9c3ec3dfe1fbd8ead5c8d9aca421a863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand of an <a class="el" href="classcsl_1_1Operator.html" title="Linear operator O(a*X+b*Y) = a*O(X) + b*O(Y) ">Operator</a>.  <a href="#a9c3ec3dfe1fbd8ead5c8d9aca421a863">More...</a><br /></td></tr>
<tr class="separator:a9c3ec3dfe1fbd8ead5c8d9aca421a863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625efe55a17b97a1c0f085bdbf3a962a"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a625efe55a17b97a1c0f085bdbf3a962a">getShape</a> () const</td></tr>
<tr class="memdesc:a625efe55a17b97a1c0f085bdbf3a962a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the shape of the tensor in the form of a std::vector of integers.  <a href="#a625efe55a17b97a1c0f085bdbf3a962a">More...</a><br /></td></tr>
<tr class="separator:a625efe55a17b97a1c0f085bdbf3a962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b1e294cf24dea17c3c4361226138b"><td class="memItemLeft" align="right" valign="top"><a id="a3d6b1e294cf24dea17c3c4361226138b"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInfBoundary</b> () const</td></tr>
<tr class="separator:a3d6b1e294cf24dea17c3c4361226138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcc223dbf5d880e923c07df142df5c8"><td class="memItemLeft" align="right" valign="top"><a id="a2fcc223dbf5d880e923c07df142df5c8"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSupBoundary</b> () const</td></tr>
<tr class="separator:a2fcc223dbf5d880e923c07df142df5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7104a5b8855272a92a47c58f29e958"><td class="memItemLeft" align="right" valign="top"><a id="aad7104a5b8855272a92a47c58f29e958"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setSupBoundary</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_inf)</td></tr>
<tr class="separator:aad7104a5b8855272a92a47c58f29e958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecdb6ce7a2d9643da2f6161a06dfbbf"><td class="memItemLeft" align="right" valign="top"><a id="a5ecdb6ce7a2d9643da2f6161a06dfbbf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setInfBoundary</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_inf)</td></tr>
<tr class="separator:a5ecdb6ce7a2d9643da2f6161a06dfbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add364193f7a78ac28f7001c7f4036453"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#add364193f7a78ac28f7001c7f4036453">getNIndices</a> () const</td></tr>
<tr class="separator:add364193f7a78ac28f7001c7f4036453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3234ce243f6a2e11950be42f10100943"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a3234ce243f6a2e11950be42f10100943">getIndex</a> (int i=0) const</td></tr>
<tr class="separator:a3234ce243f6a2e11950be42f10100943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d95f3edc0562b1d75d60b670119842"><td class="memItemLeft" align="right" valign="top"><a id="af0d95f3edc0562b1d75d60b670119842"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>resetIndexStructure</b> ()</td></tr>
<tr class="separator:af0d95f3edc0562b1d75d60b670119842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae125a32b6f3d0368b6055d4e58c1ff3f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae125a32b6f3d0368b6055d4e58c1ff3f">getIndexStructure</a> () const</td></tr>
<tr class="separator:ae125a32b6f3d0368b6055d4e58c1ff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a9a9ef3efd6bb83b62c0a353742d25"><td class="memItemLeft" align="right" valign="top"><a id="ae6a9a9ef3efd6bb83b62c0a353742d25"></a>
<a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructure</b> (<a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space) const</td></tr>
<tr class="separator:ae6a9a9ef3efd6bb83b62c0a353742d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb848bf4cdea207484a71e9b1006ead"><td class="memItemLeft" align="right" valign="top"><a id="addb848bf4cdea207484a71e9b1006ead"></a>
virtual const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructureView</b> () const</td></tr>
<tr class="separator:addb848bf4cdea207484a71e9b1006ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632e28530a68539fadacd7ab7ffc8be1"><td class="memItemLeft" align="right" valign="top"><a id="a632e28530a68539fadacd7ab7ffc8be1"></a>
virtual <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexStructureView</b> ()</td></tr>
<tr class="separator:a632e28530a68539fadacd7ab7ffc8be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4136dc23f1fba4bf897b54c8592ccfc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa4136dc23f1fba4bf897b54c8592ccfc">getFreeIndexStructure</a> () const</td></tr>
<tr class="separator:aa4136dc23f1fba4bf897b54c8592ccfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab150130c9f67daaf6aba52b9f6b90941"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Parent.html">Parent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ab150130c9f67daaf6aba52b9f6b90941">getParent</a> () const</td></tr>
<tr class="memdesc:ab150130c9f67daaf6aba52b9f6b90941"><td class="mdescLeft">&#160;</td><td class="mdescRight">For indicial expressions this function returns a pointer to the parent object of type <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> (not an expression).  <a href="#ab150130c9f67daaf6aba52b9f6b90941">More...</a><br /></td></tr>
<tr class="separator:ab150130c9f67daaf6aba52b9f6b90941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f775b5add9af8727ead2cfaab78ba2"><td class="memItemLeft" align="right" valign="top"><a id="a15f775b5add9af8727ead2cfaab78ba2"></a>
virtual <a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getParent_info</b> () const</td></tr>
<tr class="separator:a15f775b5add9af8727ead2cfaab78ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b32036fea6a2583f506a6ef9508d74"><td class="memItemLeft" align="right" valign="top"><a id="a06b32036fea6a2583f506a6ef9508d74"></a>
virtual <a class="el" href="classcsl_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPoint</b> () const</td></tr>
<tr class="separator:a06b32036fea6a2583f506a6ef9508d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42125e9765a771c47819548d342b0b28"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a42125e9765a771c47819548d342b0b28">getNContractedPairs</a> () const</td></tr>
<tr class="memdesc:a42125e9765a771c47819548d342b0b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of contracted pairs of indices <b>in an Indicial expression</b>.  <a href="#a42125e9765a771c47819548d342b0b28">More...</a><br /></td></tr>
<tr class="separator:a42125e9765a771c47819548d342b0b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946d175d946da102c5f4cc91840703cb"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a946d175d946da102c5f4cc91840703cb">getPermutations</a> (bool optimize=true) const</td></tr>
<tr class="memdesc:a946d175d946da102c5f4cc91840703cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::vector of all possible permutations of an <b>Indicial</b> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object.  <a href="#a946d175d946da102c5f4cc91840703cb">More...</a><br /></td></tr>
<tr class="separator:a946d175d946da102c5f4cc91840703cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04c0e4426f0bf9df365afe0148d59df"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af04c0e4426f0bf9df365afe0148d59df">getContractedPair</a> () const</td></tr>
<tr class="separator:af04c0e4426f0bf9df365afe0148d59df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c2898c5d3ba96de8018a0838c402c"><td class="memItemLeft" align="right" valign="top"><a id="af29c2898c5d3ba96de8018a0838c402c"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> () const</td></tr>
<tr class="separator:af29c2898c5d3ba96de8018a0838c402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa996819710adc3b7529c74a628be623"><td class="memItemLeft" align="right" valign="top"><a id="aaa996819710adc3b7529c74a628be623"></a>
virtual unique_Expr&#160;</td><td class="memItemRight" valign="bottom"><b>copy_unique</b> () const =0</td></tr>
<tr class="separator:aaa996819710adc3b7529c74a628be623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09648782dcf2e81abb5b864f476cc410"><td class="memItemLeft" align="right" valign="top"><a id="a09648782dcf2e81abb5b864f476cc410"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deepCopy</b> () const</td></tr>
<tr class="separator:a09648782dcf2e81abb5b864f476cc410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeab3809e91989adbdf29c3f56d905b6"><td class="memItemLeft" align="right" valign="top"><a id="aaeab3809e91989adbdf29c3f56d905b6"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>refresh</b> () const</td></tr>
<tr class="separator:aaeab3809e91989adbdf29c3f56d905b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10358c33402ed520dc5888b25bb26af3"><td class="memItemLeft" align="right" valign="top"><a id="a10358c33402ed520dc5888b25bb26af3"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deepRefresh</b> () const</td></tr>
<tr class="separator:a10358c33402ed520dc5888b25bb26af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867135c96776248add60018f4aa7a578"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a867135c96776248add60018f4aa7a578">setName</a> (const std::string &amp;t_name)</td></tr>
<tr class="memdesc:a867135c96776248add60018f4aa7a578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the name of the abstract.  <a href="#a867135c96776248add60018f4aa7a578">More...</a><br /></td></tr>
<tr class="separator:a867135c96776248add60018f4aa7a578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb29d316b8f64652cef472a6c23f001"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7bb29d316b8f64652cef472a6c23f001">setCommutable</a> (bool t_commutable)</td></tr>
<tr class="memdesc:a7bb29d316b8f64652cef472a6c23f001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the abstract to commute or not.  <a href="#a7bb29d316b8f64652cef472a6c23f001">More...</a><br /></td></tr>
<tr class="separator:a7bb29d316b8f64652cef472a6c23f001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf5ecfe10b79ecbe840ded8c3d8ced"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9cbf5ecfe10b79ecbe840ded8c3d8ced">addProperty</a> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *property)</td></tr>
<tr class="memdesc:a9cbf5ecfe10b79ecbe840ded8c3d8ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a property to the object.  <a href="#a9cbf5ecfe10b79ecbe840ded8c3d8ced">More...</a><br /></td></tr>
<tr class="separator:a9cbf5ecfe10b79ecbe840ded8c3d8ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d31d945e2012d108dfc3ce3eb48161"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a70d31d945e2012d108dfc3ce3eb48161">removeProperty</a> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *property)</td></tr>
<tr class="memdesc:a70d31d945e2012d108dfc3ce3eb48161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a property to the object.  <a href="#a70d31d945e2012d108dfc3ce3eb48161">More...</a><br /></td></tr>
<tr class="separator:a70d31d945e2012d108dfc3ce3eb48161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7f0692cb84ca861a5b3b641bea518b"><td class="memItemLeft" align="right" valign="top"><a id="aaf7f0692cb84ca861a5b3b641bea518b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aaf7f0692cb84ca861a5b3b641bea518b">setValue</a> (long double t_value)</td></tr>
<tr class="memdesc:aaf7f0692cb84ca861a5b3b641bea518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value if there is one (for Numerical and Literal valued). <br /></td></tr>
<tr class="separator:aaf7f0692cb84ca861a5b3b641bea518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49c51bd285830e724f103e9fb61c464"><td class="memItemLeft" align="right" valign="top"><a id="aa49c51bd285830e724f103e9fb61c464"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setValue</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_value)</td></tr>
<tr class="separator:aa49c51bd285830e724f103e9fb61c464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a04bb56578e7da143b3cd8d8fb7b26"><td class="memItemLeft" align="right" valign="top"><a id="aa6a04bb56578e7da143b3cd8d8fb7b26"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setElementary</b> (bool t_elementary)</td></tr>
<tr class="separator:aa6a04bb56578e7da143b3cd8d8fb7b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a40ceb6eb1aa79711ca126d5bdda02"><td class="memItemLeft" align="right" valign="top"><a id="aa6a40ceb6eb1aa79711ca126d5bdda02"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setAllDependencies</b> (bool t_allDependencies)</td></tr>
<tr class="separator:aa6a40ceb6eb1aa79711ca126d5bdda02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbab11282e5c6ac46b018642ff129f47"><td class="memItemLeft" align="right" valign="top"><a id="abbab11282e5c6ac46b018642ff129f47"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addDependency</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:abbab11282e5c6ac46b018642ff129f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e778c682b6cb02642b90e8ec8765441"><td class="memItemLeft" align="right" valign="top"><a id="a0e778c682b6cb02642b90e8ec8765441"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeDependency</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a0e778c682b6cb02642b90e8ec8765441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2d2ac186b56d17d2cc0a105e145b11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aab2d2ac186b56d17d2cc0a105e145b11">setArgument</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, int iArg=0)</td></tr>
<tr class="memdesc:aab2d2ac186b56d17d2cc0a105e145b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>iArg</b> (default=0).  <a href="#aab2d2ac186b56d17d2cc0a105e145b11">More...</a><br /></td></tr>
<tr class="separator:aab2d2ac186b56d17d2cc0a105e145b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7907d6983f47d261748870b497f6aa8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae7907d6983f47d261748870b497f6aa8">setArgument</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:ae7907d6983f47d261748870b497f6aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions.  <a href="#ae7907d6983f47d261748870b497f6aa8">More...</a><br /></td></tr>
<tr class="separator:ae7907d6983f47d261748870b497f6aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa50c743b8e7e76e637e98f165ad4e5d"><td class="memItemLeft" align="right" valign="top"><a id="afa50c743b8e7e76e637e98f165ad4e5d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setEmpty</b> (bool t_empty)</td></tr>
<tr class="separator:afa50c743b8e7e76e637e98f165ad4e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70df7be4486affa8dc891e3f25bf499f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a70df7be4486affa8dc891e3f25bf499f">setOperand</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand)</td></tr>
<tr class="memdesc:a70df7be4486affa8dc891e3f25bf499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operand of an operator.  <a href="#a70df7be4486affa8dc891e3f25bf499f">More...</a><br /></td></tr>
<tr class="separator:a70df7be4486affa8dc891e3f25bf499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b8a14fc746ed72e4d5abd63373c5ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ae7b8a14fc746ed72e4d5abd63373c5ba">setOperandPrivate</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand, bool leaveEmpty)</td></tr>
<tr class="memdesc:ae7b8a14fc746ed72e4d5abd63373c5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operand of an operator.  <a href="#ae7b8a14fc746ed72e4d5abd63373c5ba">More...</a><br /></td></tr>
<tr class="separator:ae7b8a14fc746ed72e4d5abd63373c5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fee8ed28079bcac107455d58be9d5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a83fee8ed28079bcac107455d58be9d5d">setVectorArgument</a> (const csl::vector_expr &amp;t_argument)</td></tr>
<tr class="memdesc:a83fee8ed28079bcac107455d58be9d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaced the entire std::vector of argument.  <a href="#a83fee8ed28079bcac107455d58be9d5d">More...</a><br /></td></tr>
<tr class="separator:a83fee8ed28079bcac107455d58be9d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47ddab3aa047e86be34c70358d53548"><td class="memItemLeft" align="right" valign="top"><a id="aa47ddab3aa047e86be34c70358d53548"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setVariable</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;t_variable)</td></tr>
<tr class="separator:aa47ddab3aa047e86be34c70358d53548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5437e7f685edf8549e6d3b34572343f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5437e7f685edf8549e6d3b34572343f8">insert</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, bool side=1)</td></tr>
<tr class="memdesc:a5437e7f685edf8549e6d3b34572343f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an expression in a sum or a product.  <a href="#a5437e7f685edf8549e6d3b34572343f8">More...</a><br /></td></tr>
<tr class="separator:a5437e7f685edf8549e6d3b34572343f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3003698af4978e774eeb2e62038f7432"><td class="memItemLeft" align="right" valign="top"><a id="a3003698af4978e774eeb2e62038f7432"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setParent</b> (const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;t_parent)</td></tr>
<tr class="separator:a3003698af4978e774eeb2e62038f7432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0eb077e25c9a67d15269cf8d5f0511"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#acc0eb077e25c9a67d15269cf8d5f0511">replaceIndex</a> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;indexToReplace, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;newIndex, bool refresh=true) const</td></tr>
<tr class="memdesc:acc0eb077e25c9a67d15269cf8d5f0511"><td class="mdescLeft">&#160;</td><td class="mdescRight">For indicial expressions, this function searches <b>indexToContract</b> and replaces it with newIndex.  <a href="#acc0eb077e25c9a67d15269cf8d5f0511">More...</a><br /></td></tr>
<tr class="separator:acc0eb077e25c9a67d15269cf8d5f0511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e54a236015d14af42b0bcde41953f3"><td class="memItemLeft" align="right" valign="top"><a id="ac9e54a236015d14af42b0bcde41953f3"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>replaceIndices</b> (std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; const &amp;indexToReplace, std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; const &amp;newIndex, bool refresh=true, bool flipped=false) const</td></tr>
<tr class="separator:ac9e54a236015d14af42b0bcde41953f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9372ddd521fa661c5d3371e0d8d4dfc3"><td class="memItemLeft" align="right" valign="top"><a id="a9372ddd521fa661c5d3371e0d8d4dfc3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>replaceIndexInPlace</b> (<a class="el" href="classcsl_1_1Index.html">Index</a> const &amp;oldIndex, <a class="el" href="classcsl_1_1Index.html">Index</a> const &amp;newIndex)</td></tr>
<tr class="separator:a9372ddd521fa661c5d3371e0d8d4dfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed79d20a0821205e6430c80a474117d3"><td class="memItemLeft" align="right" valign="top"><a id="aed79d20a0821205e6430c80a474117d3"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>contractIndex</b> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index) const</td></tr>
<tr class="separator:aed79d20a0821205e6430c80a474117d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3627f1b91e9a81f27a8b8733ec615e"><td class="memItemLeft" align="right" valign="top"><a id="a0e3627f1b91e9a81f27a8b8733ec615e"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>breakSpace</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *brokenSpace, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;newSpace) const</td></tr>
<tr class="separator:a0e3627f1b91e9a81f27a8b8733ec615e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbadc809396b1a2515a4b7ca33ffb98"><td class="memItemLeft" align="right" valign="top"><a id="acdbadc809396b1a2515a4b7ca33ffb98"></a>
virtual csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>breakSpace</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *brokenSpace, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;newSpace, const std::vector&lt; std::string &gt; &amp;indexNames) const</td></tr>
<tr class="separator:acdbadc809396b1a2515a4b7ca33ffb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f946f9c59df045ef7416320ade89c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a70f946f9c59df045ef7416320ade89c7">setIndexStructure</a> (const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;t_index)</td></tr>
<tr class="memdesc:a70f946f9c59df045ef7416320ade89c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the index structure of the object, that must be an <b>Indicial</b> expression.  <a href="#a70f946f9c59df045ef7416320ade89c7">More...</a><br /></td></tr>
<tr class="separator:a70f946f9c59df045ef7416320ade89c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c175411df619e7504feb6d888fc82f1"><td class="memItemLeft" align="right" valign="top"><a id="a3c175411df619e7504feb6d888fc82f1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setPoint</b> (const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;t_point)</td></tr>
<tr class="separator:a3c175411df619e7504feb6d888fc82f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f90ebb7cf7c26782bd36bc2a67fc5d4"><td class="memItemLeft" align="right" valign="top"><a id="a4f90ebb7cf7c26782bd36bc2a67fc5d4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4f90ebb7cf7c26782bd36bc2a67fc5d4">setFullySymmetric</a> ()</td></tr>
<tr class="memdesc:a4f90ebb7cf7c26782bd36bc2a67fc5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties of symmetry / antisymmetry and sets <b>fullySymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:a4f90ebb7cf7c26782bd36bc2a67fc5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac318016372d14b795893fe7e59199084"><td class="memItemLeft" align="right" valign="top"><a id="ac318016372d14b795893fe7e59199084"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac318016372d14b795893fe7e59199084">setFullyAntiSymmetric</a> ()</td></tr>
<tr class="memdesc:ac318016372d14b795893fe7e59199084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an <b>Indicial</b> object fully anti-symmetric. Allows to set quickly a frequent property of tensors. This function then erases all properties * of symmetry / antisymmetry and sets <b>fullyAntiSymmetric</b> to <b>True</b>. <br /></td></tr>
<tr class="separator:ac318016372d14b795893fe7e59199084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad431770faa4291116a50175193a11a88"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad431770faa4291116a50175193a11a88">addSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:ad431770faa4291116a50175193a11a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a symmetry between the i1^{th} and the i2^{th} indices. If those indices are anti-symmetric, an error is thrown.  <a href="#ad431770faa4291116a50175193a11a88">More...</a><br /></td></tr>
<tr class="separator:ad431770faa4291116a50175193a11a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5549ac0c186b3c6febf332245a25a82c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5549ac0c186b3c6febf332245a25a82c">addAntiSymmetry</a> (int i1, int i2)</td></tr>
<tr class="memdesc:a5549ac0c186b3c6febf332245a25a82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an anti-symmetry between the i1^{th} and the i2^{th} indices. If those indices are symmetric, an error is thrown.  <a href="#a5549ac0c186b3c6febf332245a25a82c">More...</a><br /></td></tr>
<tr class="separator:a5549ac0c186b3c6febf332245a25a82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9aceabbc0a99642e84c9025dbdc767"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#abe9aceabbc0a99642e84c9025dbdc767">permut</a> (int i1, int i2)</td></tr>
<tr class="memdesc:abe9aceabbc0a99642e84c9025dbdc767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to permut indices at place <b>i1</b> and <b>i2</b>. If those two indices have a symmetry property, indices are swaped and the symmetry is returned. Else the fnuction does nothing and returns 0.  <a href="#abe9aceabbc0a99642e84c9025dbdc767">More...</a><br /></td></tr>
<tr class="separator:abe9aceabbc0a99642e84c9025dbdc767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25c117c8dfc4d9718ba41e8d3f33a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aad25c117c8dfc4d9718ba41e8d3f33a6">getNumericalFactor</a> () const</td></tr>
<tr class="memdesc:aad25c117c8dfc4d9718ba41e8d3f33a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numerical factor of the expression, i.e. returns <b>C</b> if the expression if of the form <b>C*x</b> (<b>x</b> having a numerical factor equal to 1), and return 1 else.  <a href="#aad25c117c8dfc4d9718ba41e8d3f33a6">More...</a><br /></td></tr>
<tr class="separator:aad25c117c8dfc4d9718ba41e8d3f33a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204dbd37b63432cb08932b995f49d3f4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a204dbd37b63432cb08932b995f49d3f4">getNFactor</a> () const</td></tr>
<tr class="separator:a204dbd37b63432cb08932b995f49d3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34c9c6f05e692faeed2f030514787ad"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac34c9c6f05e692faeed2f030514787ad">getFactors</a> () const</td></tr>
<tr class="memdesc:ac34c9c6f05e692faeed2f030514787ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to get a std::vector of all terms than could factor the expression.  <a href="#ac34c9c6f05e692faeed2f030514787ad">More...</a><br /></td></tr>
<tr class="separator:ac34c9c6f05e692faeed2f030514787ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36e7a5acc50766d5cd3f6d59df978d"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1d36e7a5acc50766d5cd3f6d59df978d">getTerm</a> () const</td></tr>
<tr class="memdesc:a1d36e7a5acc50766d5cd3f6d59df978d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the same expression as *this but amputated of its numerical factor. Example: (4*cos(x) -&gt; cos(x)).  <a href="#a1d36e7a5acc50766d5cd3f6d59df978d">More...</a><br /></td></tr>
<tr class="separator:a1d36e7a5acc50766d5cd3f6d59df978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac513c930caa9939c2b9557f36a34ee69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac513c930caa9939c2b9557f36a34ee69">getExponents</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;exponents) const</td></tr>
<tr class="memdesc:ac513c930caa9939c2b9557f36a34ee69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills in a vector the exponents corresponding to some factors for the expression.  <a href="#ac513c930caa9939c2b9557f36a34ee69">More...</a><br /></td></tr>
<tr class="separator:ac513c930caa9939c2b9557f36a34ee69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c316b059cb2a1e3020310b148f921b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa0c316b059cb2a1e3020310b148f921b">checkIndexStructure</a> (const std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;t_index) const</td></tr>
<tr class="memdesc:aa0c316b059cb2a1e3020310b148f921b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="#aa0c316b059cb2a1e3020310b148f921b">More...</a><br /></td></tr>
<tr class="separator:aa0c316b059cb2a1e3020310b148f921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebd84082bb93418408cc0babe2dffe2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1ebd84082bb93418408cc0babe2dffe2">checkIndexStructure</a> (const std::initializer_list&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;index) const</td></tr>
<tr class="memdesc:a1ebd84082bb93418408cc0babe2dffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure.  <a href="#a1ebd84082bb93418408cc0babe2dffe2">More...</a><br /></td></tr>
<tr class="separator:a1ebd84082bb93418408cc0babe2dffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caee12abb451168149779a668dfc59e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7caee12abb451168149779a668dfc59e">compareWithDummy</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, std::map&lt; <a class="el" href="classcsl_1_1Index.html">Index</a>, <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;constraints, bool keepAllCosntraints=false) const</td></tr>
<tr class="memdesc:a7caee12abb451168149779a668dfc59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr.  <a href="#a7caee12abb451168149779a668dfc59e">More...</a><br /></td></tr>
<tr class="separator:a7caee12abb451168149779a668dfc59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f16fda9fe72a89c61ece36101a11d95"><td class="memItemLeft" align="right" valign="top"><a id="a0f16fda9fe72a89c61ece36101a11d95"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compareWithDummy</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool keepAllCosntraints=false) const</td></tr>
<tr class="separator:a0f16fda9fe72a89c61ece36101a11d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8459b3206eb3a2297eeea7688e9520"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aea8459b3206eb3a2297eeea7688e9520">getParity</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> t_variable) const</td></tr>
<tr class="memdesc:aea8459b3206eb3a2297eeea7688e9520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parity property of the expression with respect to <b>t_variable</b>.  <a href="#aea8459b3206eb3a2297eeea7688e9520">More...</a><br /></td></tr>
<tr class="separator:aea8459b3206eb3a2297eeea7688e9520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad666bf7d533607da9675b0c645ee9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a27ad666bf7d533607da9675b0c645ee9">askTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool exact=false) const</td></tr>
<tr class="memdesc:a27ad666bf7d533607da9675b0c645ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <b>expr</b> can factor <b>*this</b>.  <a href="#a27ad666bf7d533607da9675b0c645ee9">More...</a><br /></td></tr>
<tr class="separator:a27ad666bf7d533607da9675b0c645ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fe2ccf376dadd21b2d7a0f134d86c6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a40fe2ccf376dadd21b2d7a0f134d86c6">dependsOn</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a40fe2ccf376dadd21b2d7a0f134d86c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if the expression depends on <b>expr</b>.  <a href="#a40fe2ccf376dadd21b2d7a0f134d86c6">More...</a><br /></td></tr>
<tr class="separator:a40fe2ccf376dadd21b2d7a0f134d86c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7d8586a0df66ba8da33528d6400e66"><td class="memItemLeft" align="right" valign="top"><a id="a9d7d8586a0df66ba8da33528d6400e66"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>dependsOn</b> (<a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> parent) const</td></tr>
<tr class="separator:a9d7d8586a0df66ba8da33528d6400e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c9887977249e4d71ea36c6377b3581"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac3c9887977249e4d71ea36c6377b3581">dependsExplicitlyOn</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:ac3c9887977249e4d71ea36c6377b3581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check recursively if <b>expr</b> is present in the expression.  <a href="#ac3c9887977249e4d71ea36c6377b3581">More...</a><br /></td></tr>
<tr class="separator:ac3c9887977249e4d71ea36c6377b3581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b26ad7a44e497af296318287bac539a"><td class="memItemLeft" align="right" valign="top"><a id="a0b26ad7a44e497af296318287bac539a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>dependsExplicitlyOn</b> (<a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> parent) const</td></tr>
<tr class="separator:a0b26ad7a44e497af296318287bac539a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f68d0cd93dfe2ac02d6d4afc80fb41a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a3f68d0cd93dfe2ac02d6d4afc80fb41a">commutesWith</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, int sign=-1) const</td></tr>
<tr class="memdesc:a3f68d0cd93dfe2ac02d6d4afc80fb41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the object commutes with expr.  <a href="#a3f68d0cd93dfe2ac02d6d4afc80fb41a">More...</a><br /></td></tr>
<tr class="separator:a3f68d0cd93dfe2ac02d6d4afc80fb41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299b1fd6c2b9d80ad90a08c7acef28d2"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a299b1fd6c2b9d80ad90a08c7acef28d2">findSubExpression</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> subExpression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;newExpression) const</td></tr>
<tr class="memdesc:a299b1fd6c2b9d80ad90a08c7acef28d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sub-expression and replaces it.  <a href="#a299b1fd6c2b9d80ad90a08c7acef28d2">More...</a><br /></td></tr>
<tr class="separator:a299b1fd6c2b9d80ad90a08c7acef28d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae10d5685ccec295fbd9be7996073cb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#acae10d5685ccec295fbd9be7996073cb">isPolynomial</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:acae10d5685ccec295fbd9be7996073cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the expression is a mononomial term in <b>expr</b>, i.e. a term of the form C*expr^n with C independent of expr, n integer.  <a href="#acae10d5685ccec295fbd9be7996073cb">More...</a><br /></td></tr>
<tr class="separator:acae10d5685ccec295fbd9be7996073cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c1d8df9e6b1a3eca66958f7dc489d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ab79c1d8df9e6b1a3eca66958f7dc489d">matchShape</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr, bool exact=false) const</td></tr>
<tr class="memdesc:ab79c1d8df9e6b1a3eca66958f7dc489d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of a vectorial-type expression, this function checks if the shape of expr matches itself.  <a href="#ab79c1d8df9e6b1a3eca66958f7dc489d">More...</a><br /></td></tr>
<tr class="separator:ab79c1d8df9e6b1a3eca66958f7dc489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31e08c251d96b8ea8ec8d385895c1ff"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa31e08c251d96b8ea8ec8d385895c1ff">hasContractionProperty</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B) const</td></tr>
<tr class="memdesc:aa31e08c251d96b8ea8ec8d385895c1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells (for an Indicial type) if there is a special contraction property with <b>B</b>.  <a href="#aa31e08c251d96b8ea8ec8d385895c1ff">More...</a><br /></td></tr>
<tr class="separator:aa31e08c251d96b8ea8ec8d385895c1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bf1455397fdd2df8dbbc3b41c2f3f4"><td class="memItemLeft" align="right" valign="top"><a id="a94bf1455397fdd2df8dbbc3b41c2f3f4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasChainContractionProperty</b> () const</td></tr>
<tr class="separator:a94bf1455397fdd2df8dbbc3b41c2f3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec707d949f0f98e08ab4642c93dd9eb5"><td class="memItemLeft" align="right" valign="top"><a id="aec707d949f0f98e08ab4642c93dd9eb5"></a>
virtual std::vector&lt; <a class="el" href="classcsl_1_1ContractionChain.html">ContractionChain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getContractionProperties</b> () const</td></tr>
<tr class="separator:aec707d949f0f98e08ab4642c93dd9eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad874fc858295a737e6ce884530f1109b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ad874fc858295a737e6ce884530f1109b">contraction</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B) const</td></tr>
<tr class="memdesc:ad874fc858295a737e6ce884530f1109b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a special contraction of indices. Before calling this function we must check that there is indeed a contraction by calling the function <a class="el" href="classcsl_1_1Abstract.html#aa31e08c251d96b8ea8ec8d385895c1ff" title="Tells (for an Indicial type) if there is a special contraction property with B. ">hasContractionProperty()</a>.  <a href="#ad874fc858295a737e6ce884530f1109b">More...</a><br /></td></tr>
<tr class="separator:ad874fc858295a737e6ce884530f1109b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd35096982e92b669ea55d960c5f44be"><td class="memItemLeft" align="right" valign="top"><a id="abd35096982e92b669ea55d960c5f44be"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>contraction</b> (const csl::vector_expr &amp;chain) const</td></tr>
<tr class="separator:abd35096982e92b669ea55d960c5f44be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543d5a4f0432e166b492ad28a860a65f"><td class="memItemLeft" align="right" valign="top">virtual long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a543d5a4f0432e166b492ad28a860a65f">evaluateScalar</a> () const</td></tr>
<tr class="memdesc:a543d5a4f0432e166b492ad28a860a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the value of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a543d5a4f0432e166b492ad28a860a65f">More...</a><br /></td></tr>
<tr class="separator:a543d5a4f0432e166b492ad28a860a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d5a98ec433dad08613083c12f587cd"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa2d5a98ec433dad08613083c12f587cd">evaluate</a> (csl::eval::mode user_mode=csl::eval::base) const =0</td></tr>
<tr class="memdesc:aa2d5a98ec433dad08613083c12f587cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#aa2d5a98ec433dad08613083c12f587cd">More...</a><br /></td></tr>
<tr class="separator:aa2d5a98ec433dad08613083c12f587cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecab8c872023a2d0771e7e4f83bb05f8"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aecab8c872023a2d0771e7e4f83bb05f8">derive</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:aecab8c872023a2d0771e7e4f83bb05f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another.  <a href="#aecab8c872023a2d0771e7e4f83bb05f8">More...</a><br /></td></tr>
<tr class="separator:aecab8c872023a2d0771e7e4f83bb05f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc0de9c4ce5f77fc716af0f502d13d3"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a0bc0de9c4ce5f77fc716af0f502d13d3">factor</a> (bool full=false) const</td></tr>
<tr class="memdesc:a0bc0de9c4ce5f77fc716af0f502d13d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Factors</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a0bc0de9c4ce5f77fc716af0f502d13d3">More...</a><br /></td></tr>
<tr class="separator:a0bc0de9c4ce5f77fc716af0f502d13d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb3d657c65606d520688db6401fe650"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a8fb3d657c65606d520688db6401fe650">factor</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor, bool full=false) const</td></tr>
<tr class="memdesc:a8fb3d657c65606d520688db6401fe650"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Factors</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt a <b>particular</b> <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a8fb3d657c65606d520688db6401fe650">More...</a><br /></td></tr>
<tr class="separator:a8fb3d657c65606d520688db6401fe650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3746f1d3667846824ea51b8a2e00d31"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ab3746f1d3667846824ea51b8a2e00d31">collect</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors, bool full=false) const</td></tr>
<tr class="memdesc:ab3746f1d3667846824ea51b8a2e00d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects terms in sum according to some factors given by the user.  <a href="#ab3746f1d3667846824ea51b8a2e00d31">More...</a><br /></td></tr>
<tr class="separator:ab3746f1d3667846824ea51b8a2e00d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43520e1d6d5fdad9b50f77c6e027f928"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a43520e1d6d5fdad9b50f77c6e027f928">suppressTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a43520e1d6d5fdad9b50f77c6e027f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a factor from an expr, that must have been determined before.  <a href="#a43520e1d6d5fdad9b50f77c6e027f928">More...</a><br /></td></tr>
<tr class="separator:a43520e1d6d5fdad9b50f77c6e027f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eeedaeaa39e75facf1060dce7c57a8f"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4eeedaeaa39e75facf1060dce7c57a8f">suppressExponent</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;<a class="el" href="classcsl_1_1Abstract.html#a0bc0de9c4ce5f77fc716af0f502d13d3">factor</a>, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;exponent) const</td></tr>
<tr class="memdesc:a4eeedaeaa39e75facf1060dce7c57a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression where the factor <b>factor^exponent</b> has been suppressed.  <a href="#a4eeedaeaa39e75facf1060dce7c57a8f">More...</a><br /></td></tr>
<tr class="separator:a4eeedaeaa39e75facf1060dce7c57a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a87ab082152fea4fc2444659028b840"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a3a87ab082152fea4fc2444659028b840">expand</a> (bool full=false, bool inPlace=false) const</td></tr>
<tr class="memdesc:a3a87ab082152fea4fc2444659028b840"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Develops</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#a3a87ab082152fea4fc2444659028b840">More...</a><br /></td></tr>
<tr class="separator:a3a87ab082152fea4fc2444659028b840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48aaaa856582b6359037fe94d2419b"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aeb48aaaa856582b6359037fe94d2419b">expand_if</a> (std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, bool full=false, bool inPlace=false) const</td></tr>
<tr class="memdesc:aeb48aaaa856582b6359037fe94d2419b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Develops</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>.  <a href="#aeb48aaaa856582b6359037fe94d2419b">More...</a><br /></td></tr>
<tr class="separator:aeb48aaaa856582b6359037fe94d2419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415f64fdddaae445014d5e052956f889"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a415f64fdddaae445014d5e052956f889">getRealPart</a> () const</td></tr>
<tr class="memdesc:a415f64fdddaae445014d5e052956f889"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a415f64fdddaae445014d5e052956f889">More...</a><br /></td></tr>
<tr class="separator:a415f64fdddaae445014d5e052956f889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f44bbb3685fc9f4a0402223b2e1004"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a43f44bbb3685fc9f4a0402223b2e1004">getImaginaryPart</a> () const</td></tr>
<tr class="memdesc:a43f44bbb3685fc9f4a0402223b2e1004"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a43f44bbb3685fc9f4a0402223b2e1004">More...</a><br /></td></tr>
<tr class="separator:a43f44bbb3685fc9f4a0402223b2e1004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859f792aec52ba1fe1181f81d1cc3451"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a859f792aec52ba1fe1181f81d1cc3451">getComplexModulus</a> () const</td></tr>
<tr class="memdesc:a859f792aec52ba1fe1181f81d1cc3451"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a859f792aec52ba1fe1181f81d1cc3451">More...</a><br /></td></tr>
<tr class="separator:a859f792aec52ba1fe1181f81d1cc3451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc64c66894acafc1f069dc40072084b"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9cc64c66894acafc1f069dc40072084b">getComplexArgument</a> () const</td></tr>
<tr class="memdesc:a9cc64c66894acafc1f069dc40072084b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it.  <a href="#a9cc64c66894acafc1f069dc40072084b">More...</a><br /></td></tr>
<tr class="separator:a9cc64c66894acafc1f069dc40072084b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e8bdba20c6192a948892f212f09dbe"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a03e8bdba20c6192a948892f212f09dbe">getComplexConjugate</a> () const</td></tr>
<tr class="memdesc:a03e8bdba20c6192a948892f212f09dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the complex conjugate of the expression.  <a href="#a03e8bdba20c6192a948892f212f09dbe">More...</a><br /></td></tr>
<tr class="separator:a03e8bdba20c6192a948892f212f09dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6305ce90c795bfb416d8e958c62f905c"><td class="memItemLeft" align="right" valign="top"><a id="a6305ce90c795bfb416d8e958c62f905c"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>applySelfStructureOn</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:a6305ce90c795bfb416d8e958c62f905c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404c5e89a3aad8a8dabcb56d4120c0fe"><td class="memItemLeft" align="right" valign="top"><a id="a404c5e89a3aad8a8dabcb56d4120c0fe"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTransposed</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *space, bool applyProp=true) const</td></tr>
<tr class="separator:a404c5e89a3aad8a8dabcb56d4120c0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1e82fc94c0d0734f382edf865d8428"><td class="memItemLeft" align="right" valign="top"><a id="a9d1e82fc94c0d0734f382edf865d8428"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTransposed</b> (const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces, bool applyProp=true) const</td></tr>
<tr class="separator:a9d1e82fc94c0d0734f382edf865d8428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b707a5efdaef7c7945cbd921c3f526"><td class="memItemLeft" align="right" valign="top"><a id="aa5b707a5efdaef7c7945cbd921c3f526"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHermitianConjugate</b> (const <a class="el" href="classcsl_1_1Space.html">Space</a> *space) const</td></tr>
<tr class="separator:aa5b707a5efdaef7c7945cbd921c3f526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c74100bc93fd703bc15f0d426697154"><td class="memItemLeft" align="right" valign="top"><a id="a8c74100bc93fd703bc15f0d426697154"></a>
virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHermitianConjugate</b> (const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces) const</td></tr>
<tr class="separator:a8c74100bc93fd703bc15f0d426697154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade540a127da7304f2b7282f4dcaffc7f"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ade540a127da7304f2b7282f4dcaffc7f">getPolynomialTerm</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> t_variable, int order) const</td></tr>
<tr class="memdesc:ade540a127da7304f2b7282f4dcaffc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the polynomial term corresponding to <b>*this</b> with the variable <b>t_variable</b> at order <b>order</b>. In particular, this function assumes that the checks have already been made with the function <a class="el" href="classcsl_1_1Abstract.html#acae10d5685ccec295fbd9be7996073cb" title="Determines if the expression is a mononomial term in expr, i.e. a term of the form C*expr^n with C in...">isPolynomial()</a>.  <a href="#ade540a127da7304f2b7282f4dcaffc7f">More...</a><br /></td></tr>
<tr class="separator:ade540a127da7304f2b7282f4dcaffc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbcb9dd55c73dbcbfe8c091d3e5c02e"><td class="memItemLeft" align="right" valign="top">virtual csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#afcbcb9dd55c73dbcbfe8c091d3e5c02e">getAlternateForms</a> () const</td></tr>
<tr class="memdesc:afcbcb9dd55c73dbcbfe8c091d3e5c02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x).  <a href="#afcbcb9dd55c73dbcbfe8c091d3e5c02e">More...</a><br /></td></tr>
<tr class="separator:afcbcb9dd55c73dbcbfe8c091d3e5c02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316956fea77627a716500a2bbfc1f3b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a316956fea77627a716500a2bbfc1f3b7">applyOperator</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand, bool leaveEmpty=false) const</td></tr>
<tr class="memdesc:a316956fea77627a716500a2bbfc1f3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the operator on an <b>operand</b>, iif the expression is an operator.  <a href="#a316956fea77627a716500a2bbfc1f3b7">More...</a><br /></td></tr>
<tr class="separator:a316956fea77627a716500a2bbfc1f3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101219973341a39cf15f07e5e1aa388f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a101219973341a39cf15f07e5e1aa388f">addition_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a101219973341a39cf15f07e5e1aa388f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special addition for Numerical- and Vectorial-types.  <a href="#a101219973341a39cf15f07e5e1aa388f">More...</a><br /></td></tr>
<tr class="separator:a101219973341a39cf15f07e5e1aa388f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5ed458ba62f5b4cf61a9e1f8568af1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4f5ed458ba62f5b4cf61a9e1f8568af1">multiplication_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, bool side=1) const</td></tr>
<tr class="memdesc:a4f5ed458ba62f5b4cf61a9e1f8568af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special multiplication for Numerical- and Vectorial-types.  <a href="#a4f5ed458ba62f5b4cf61a9e1f8568af1">More...</a><br /></td></tr>
<tr class="separator:a4f5ed458ba62f5b4cf61a9e1f8568af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1578c74aee1050b806a67e7a81a67f5c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1578c74aee1050b806a67e7a81a67f5c">division_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a1578c74aee1050b806a67e7a81a67f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special division for Numerical- and Polynomial-types. For polynomial, the euclidean division of two polynomials is implemented.  <a href="#a1578c74aee1050b806a67e7a81a67f5c">More...</a><br /></td></tr>
<tr class="separator:a1578c74aee1050b806a67e7a81a67f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2696a0feb43766ef54e1e3dd3d6d134"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa2696a0feb43766ef54e1e3dd3d6d134">exponentiation_own</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:aa2696a0feb43766ef54e1e3dd3d6d134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation of special exponentiation for Numerical- and Vectorial-types.  <a href="#aa2696a0feb43766ef54e1e3dd3d6d134">More...</a><br /></td></tr>
<tr class="separator:aa2696a0feb43766ef54e1e3dd3d6d134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b77f008f4b95030641224877004f06c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5b77f008f4b95030641224877004f06c">getRegularExpression</a> () const</td></tr>
<tr class="memdesc:a5b77f008f4b95030641224877004f06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a regular expression from the polynomial, that is a sum where the different powers of the variable appear explicitely.  <a href="#a5b77f008f4b95030641224877004f06c">More...</a><br /></td></tr>
<tr class="separator:a5b77f008f4b95030641224877004f06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83c6a13716688f45b02e6291d39aba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7b83c6a13716688f45b02e6291d39aba">tensordot</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a7b83c6a13716688f45b02e6291d39aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tensordot of two <b>Vectorial</b> expressions.  <a href="#a7b83c6a13716688f45b02e6291d39aba">More...</a><br /></td></tr>
<tr class="separator:a7b83c6a13716688f45b02e6291d39aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc7a46deaa3eaa7593909d74e76d4af"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4cc7a46deaa3eaa7593909d74e76d4af">dot</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="memdesc:a4cc7a46deaa3eaa7593909d74e76d4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of two <b>Vectorial</b> expressions.  <a href="#a4cc7a46deaa3eaa7593909d74e76d4af">More...</a><br /></td></tr>
<tr class="separator:a4cc7a46deaa3eaa7593909d74e76d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf8154e39ff211b12e6382e675ccaad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aeaf8154e39ff211b12e6382e675ccaad">getSum</a> () const</td></tr>
<tr class="memdesc:aeaf8154e39ff211b12e6382e675ccaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the sum of all elements in the <b>Vectorial</b> object.  <a href="#aeaf8154e39ff211b12e6382e675ccaad">More...</a><br /></td></tr>
<tr class="separator:aeaf8154e39ff211b12e6382e675ccaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07489d0569bc983718796d21c73f34b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a07489d0569bc983718796d21c73f34b3">getProduct</a> () const</td></tr>
<tr class="memdesc:a07489d0569bc983718796d21c73f34b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the product of all elements in the <b>Vectorial</b> object.  <a href="#a07489d0569bc983718796d21c73f34b3">More...</a><br /></td></tr>
<tr class="separator:a07489d0569bc983718796d21c73f34b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0188b049736016c970a2513ed9f6931f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a0188b049736016c970a2513ed9f6931f">getVectorialModulus</a> () const</td></tr>
<tr class="memdesc:a0188b049736016c970a2513ed9f6931f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Vectorial modulus of the <b>Vectorial</b> object, that is defined here as the squared root of the sum of element squared. Example: {A_{11}^2+A_{12}^2+}.  <a href="#a0188b049736016c970a2513ed9f6931f">More...</a><br /></td></tr>
<tr class="separator:a0188b049736016c970a2513ed9f6931f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcdc11b64c8c515933882168d0792ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a7dcdc11b64c8c515933882168d0792ef">getSubVectorial</a> (int iExcept) const</td></tr>
<tr class="memdesc:a7dcdc11b64c8c515933882168d0792ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="#a7dcdc11b64c8c515933882168d0792ef">More...</a><br /></td></tr>
<tr class="separator:a7dcdc11b64c8c515933882168d0792ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c50b2663f57d38c1d3ec3cfeaa3ce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a413c50b2663f57d38c1d3ec3cfeaa3ce">getSubVectorial</a> (int iExcept, int jExcept) const</td></tr>
<tr class="memdesc:a413c50b2663f57d38c1d3ec3cfeaa3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the [iExcept^{th},jExcept^{th}] element (useful for matrices).  <a href="#a413c50b2663f57d38c1d3ec3cfeaa3ce">More...</a><br /></td></tr>
<tr class="separator:a413c50b2663f57d38c1d3ec3cfeaa3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f88bae88e30b37cc3a4d4c7a476a992"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a0f88bae88e30b37cc3a4d4c7a476a992">getSubVectorial</a> (const std::vector&lt; int &gt; &amp;exceptions) const</td></tr>
<tr class="memdesc:a0f88bae88e30b37cc3a4d4c7a476a992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element.  <a href="#a0f88bae88e30b37cc3a4d4c7a476a992">More...</a><br /></td></tr>
<tr class="separator:a0f88bae88e30b37cc3a4d4c7a476a992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7aad9c82bc7fd4a19e495fac3673a9"><td class="memItemLeft" align="right" valign="top"><a id="ada7aad9c82bc7fd4a19e495fac3673a9"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSubVectorial</b> (const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;keepIndices) const</td></tr>
<tr class="separator:ada7aad9c82bc7fd4a19e495fac3673a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d86e688cb7b1e7d7846e14ae5a3e1c"><td class="memItemLeft" align="right" valign="top"><a id="aa1d86e688cb7b1e7d7846e14ae5a3e1c"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSubVectorial</b> (std::vector&lt; std::vector&lt; int &gt;&gt;::const_iterator <a class="el" href="classcsl_1_1Abstract.html#aad54ed41b2ce9bad3364fe30ad1a0d71">begin</a>, std::vector&lt; std::vector&lt; int &gt;&gt;::const_iterator <a class="el" href="classcsl_1_1Abstract.html#a61e4e80d998a888a1a74d9ea3e10c0f1">end</a>) const</td></tr>
<tr class="separator:aa1d86e688cb7b1e7d7846e14ae5a3e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb08811cf370616477a92075e4a218ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aeb08811cf370616477a92075e4a218ee">determinant</a> () const</td></tr>
<tr class="memdesc:aeb08811cf370616477a92075e4a218ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the object if it corresponds to a square matrix (or a scalar), 0 else.  <a href="#aeb08811cf370616477a92075e4a218ee">More...</a><br /></td></tr>
<tr class="separator:aeb08811cf370616477a92075e4a218ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a86d21f5c5f65eb7e524a8f8002c0e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a9a86d21f5c5f65eb7e524a8f8002c0e7">trace</a> () const</td></tr>
<tr class="separator:a9a86d21f5c5f65eb7e524a8f8002c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacab43e551e9259a39a79378373ce49c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aacab43e551e9259a39a79378373ce49c">trace</a> (int axis1, int axis2) const</td></tr>
<tr class="memdesc:aacab43e551e9259a39a79378373ce49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the trace over the axis <b>axis1</b> and <b>axis2</b> of a tensor. <b>axis1</b> and <b>axis2</b> can be the same, in which case the trace just corresponds to the sum over this particular axis.  <a href="#aacab43e551e9259a39a79378373ce49c">More...</a><br /></td></tr>
<tr class="separator:aacab43e551e9259a39a79378373ce49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e97712696e5c40b28bc1e35987fea94"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1e97712696e5c40b28bc1e35987fea94">transpose</a> () const</td></tr>
<tr class="memdesc:a1e97712696e5c40b28bc1e35987fea94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the transpose of a 2D matrix.  <a href="#a1e97712696e5c40b28bc1e35987fea94">More...</a><br /></td></tr>
<tr class="separator:a1e97712696e5c40b28bc1e35987fea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c42723e8bc6334c99f00898cc1d59d7"><td class="memItemLeft" align="right" valign="top"><a id="a8c42723e8bc6334c99f00898cc1d59d7"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hermitian</b> () const</td></tr>
<tr class="separator:a8c42723e8bc6334c99f00898cc1d59d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faf1ffd8cb3b6c721e128980c0303d8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4faf1ffd8cb3b6c721e128980c0303d8">symmetrise</a> () const</td></tr>
<tr class="memdesc:a4faf1ffd8cb3b6c721e128980c0303d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the symmetrization of a 2D matrix.  <a href="#a4faf1ffd8cb3b6c721e128980c0303d8">More...</a><br /></td></tr>
<tr class="separator:a4faf1ffd8cb3b6c721e128980c0303d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd972aed8326d4c13534594e061ee6da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#acd972aed8326d4c13534594e061ee6da">antisymmetrise</a> () const</td></tr>
<tr class="memdesc:acd972aed8326d4c13534594e061ee6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the anti-symmetrization of a 2D matrix.  <a href="#acd972aed8326d4c13534594e061ee6da">More...</a><br /></td></tr>
<tr class="separator:acd972aed8326d4c13534594e061ee6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b68943aa7ecf60a63af0f2f368eef8f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a1b68943aa7ecf60a63af0f2f368eef8f">inverseMatrix</a> () const</td></tr>
<tr class="memdesc:a1b68943aa7ecf60a63af0f2f368eef8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the inverse of a 2D square matrix. The applied method is: A^{-1} = 1/det(A)*Com(A)^T.  <a href="#a1b68943aa7ecf60a63af0f2f368eef8f">More...</a><br /></td></tr>
<tr class="separator:a1b68943aa7ecf60a63af0f2f368eef8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb26e1382411448ce3c65d50fefd8bb"><td class="memItemLeft" align="right" valign="top"><a id="afeb26e1382411448ce3c65d50fefd8bb"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCanonicalPermutation</b> () const</td></tr>
<tr class="separator:afeb26e1382411448ce3c65d50fefd8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d3ab932182226f4670a62bbb22af4e"><td class="memItemLeft" align="right" valign="top"><a id="a61d3ab932182226f4670a62bbb22af4e"></a>
virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyDiracDelta</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;) const</td></tr>
<tr class="separator:a61d3ab932182226f4670a62bbb22af4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff2950fc8ca319f87a730450f14545"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a59ff2950fc8ca319f87a730450f14545">operator=</a> (double t_value)</td></tr>
<tr class="memdesc:a59ff2950fc8ca319f87a730450f14545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the <a class="el" href="classcsl_1_1Abstract.html#aaf7f0692cb84ca861a5b3b641bea518b" title="Sets the value if there is one (for Numerical and Literal valued). ">setValue()</a> function.  <a href="#a59ff2950fc8ca319f87a730450f14545">More...</a><br /></td></tr>
<tr class="separator:a59ff2950fc8ca319f87a730450f14545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8334e14cd5789168b037d3888ed60edd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a8334e14cd5789168b037d3888ed60edd">operator==</a> (int t_value) const</td></tr>
<tr class="separator:a8334e14cd5789168b037d3888ed60edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d929e34039e817e464abc560bd4a9d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a12d929e34039e817e464abc560bd4a9d">operator==</a> (double t_value) const</td></tr>
<tr class="separator:a12d929e34039e817e464abc560bd4a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b62a6308638064c42da80e9cc2cb7e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af5b62a6308638064c42da80e9cc2cb7e">operator!=</a> (int t_value) const</td></tr>
<tr class="separator:af5b62a6308638064c42da80e9cc2cb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fd1b57df371dac7ccfd5a909620e49"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#af4fd1b57df371dac7ccfd5a909620e49">operator!=</a> (double t_value) const</td></tr>
<tr class="separator:af4fd1b57df371dac7ccfd5a909620e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3775f3088e784cc924cb7d26e118660e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a3775f3088e784cc924cb7d26e118660e">operator==</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const =0</td></tr>
<tr class="memdesc:a3775f3088e784cc924cb7d26e118660e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="#a3775f3088e784cc924cb7d26e118660e">More...</a><br /></td></tr>
<tr class="separator:a3775f3088e784cc924cb7d26e118660e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fa41a5e014f067395467542ee8831"><td class="memItemLeft" align="right" valign="top"><a id="aee4fa41a5e014f067395467542ee8831"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>testDummy</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:aee4fa41a5e014f067395467542ee8831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78f0cce24c93def3050743bc5f2845"><td class="memItemLeft" align="right" valign="top"><a id="a1f78f0cce24c93def3050743bc5f2845"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:a1f78f0cce24c93def3050743bc5f2845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed43debcac4a19e0da44986774c522bc"><td class="memItemLeft" align="right" valign="top"><a id="aed43debcac4a19e0da44986774c522bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:aed43debcac4a19e0da44986774c522bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376f08c0aa5ffe783090381d102d3ae"><td class="memItemLeft" align="right" valign="top"><a id="a2376f08c0aa5ffe783090381d102d3ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> &amp;other) const</td></tr>
<tr class="separator:a2376f08c0aa5ffe783090381d102d3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96de5935a58a96d4c5b1e47966488923"><td class="memItemLeft" align="right" valign="top"><a id="a96de5935a58a96d4c5b1e47966488923"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a96de5935a58a96d4c5b1e47966488923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99a619abde7e4c58f39e14d4d20fcf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#ac99a619abde7e4c58f39e14d4d20fcf5">operator!=</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:ac99a619abde7e4c58f39e14d4d20fcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another.  <a href="#ac99a619abde7e4c58f39e14d4d20fcf5">More...</a><br /></td></tr>
<tr class="separator:ac99a619abde7e4c58f39e14d4d20fcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45206de7c7773b3cb150451ee3eb379e"><td class="memItemLeft" align="right" valign="top"><a id="a45206de7c7773b3cb150451ee3eb379e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr) const</td></tr>
<tr class="separator:a45206de7c7773b3cb150451ee3eb379e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3495220202bd417c1b58249c923f39"><td class="memItemLeft" align="right" valign="top"><a id="a0d3495220202bd417c1b58249c923f39"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> &amp;other) const</td></tr>
<tr class="separator:a0d3495220202bd417c1b58249c923f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8331053065d1be2da89e70c45d24863"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#aa8331053065d1be2da89e70c45d24863">operator[]</a> (int iArg) const</td></tr>
<tr class="memdesc:aa8331053065d1be2da89e70c45d24863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, equivalent to the function <a class="el" href="classcsl_1_1Abstract.html#ac33a42309d629d47bfdbede4e152414e">getArgument()</a>.  <a href="#aa8331053065d1be2da89e70c45d24863">More...</a><br /></td></tr>
<tr class="separator:aa8331053065d1be2da89e70c45d24863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560aa9993d506551c54a8c02d1445814"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a560aa9993d506551c54a8c02d1445814">operator[]</a> (int iArg)</td></tr>
<tr class="memdesc:a560aa9993d506551c54a8c02d1445814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator for multi-argument expressions, returns a reference so this function is not const.  <a href="#a560aa9993d506551c54a8c02d1445814">More...</a><br /></td></tr>
<tr class="separator:a560aa9993d506551c54a8c02d1445814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1ba8dce7fbc19eb98807bd15a279c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a5c1ba8dce7fbc19eb98807bd15a279c9">operator&lt;</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const =0</td></tr>
<tr class="memdesc:a5c1ba8dce7fbc19eb98807bd15a279c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#a5c1ba8dce7fbc19eb98807bd15a279c9">More...</a><br /></td></tr>
<tr class="separator:a5c1ba8dce7fbc19eb98807bd15a279c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e19587260a07dba65cf2a985e05516b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a6e19587260a07dba65cf2a985e05516b">operator&lt;</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:a6e19587260a07dba65cf2a985e05516b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#a6e19587260a07dba65cf2a985e05516b">More...</a><br /></td></tr>
<tr class="separator:a6e19587260a07dba65cf2a985e05516b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485c6f3e10db539a70416cd0766b117d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a485c6f3e10db539a70416cd0766b117d">operator&gt;</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a485c6f3e10db539a70416cd0766b117d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#a485c6f3e10db539a70416cd0766b117d">More...</a><br /></td></tr>
<tr class="separator:a485c6f3e10db539a70416cd0766b117d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab305bdf49212f03781e7f98024faeb66"><td class="memItemLeft" align="right" valign="top"><a id="ab305bdf49212f03781e7f98024faeb66"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:ab305bdf49212f03781e7f98024faeb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1660498f2638f5e490d6e512eb32f4"><td class="memItemLeft" align="right" valign="top"><a id="a2a1660498f2638f5e490d6e512eb32f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="separator:a2a1660498f2638f5e490d6e512eb32f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8883df19d7538b68fa96aadac9dfa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#a4c8883df19d7538b68fa96aadac9dfa9">operator&gt;=</a> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr) const</td></tr>
<tr class="memdesc:a4c8883df19d7538b68fa96aadac9dfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#a4c8883df19d7538b68fa96aadac9dfa9">More...</a><br /></td></tr>
<tr class="separator:a4c8883df19d7538b68fa96aadac9dfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcac6df2fd7ac11f336189cf215124b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html#afbcac6df2fd7ac11f336189cf215124b">operator&lt;=</a> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="memdesc:afbcac6df2fd7ac11f336189cf215124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the simplicity of the expression to another.  <a href="#afbcac6df2fd7ac11f336189cf215124b">More...</a><br /></td></tr>
<tr class="separator:afbcac6df2fd7ac11f336189cf215124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b931f7b159d57bad26ca9c9ea729aa1"><td class="memItemLeft" align="right" valign="top"><a id="a6b931f7b159d57bad26ca9c9ea729aa1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr) const</td></tr>
<tr class="separator:a6b931f7b159d57bad26ca9c9ea729aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aba5ef083016b2f3d9e6271f864b9b063"><td class="memItemLeft" align="right" valign="top"><a id="aba5ef083016b2f3d9e6271f864b9b063"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularName</b> (std::string const &amp;name)</td></tr>
<tr class="separator:aba5ef083016b2f3d9e6271f864b9b063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8421d402d5ba82257188b545e8d668"><td class="memItemLeft" align="right" valign="top"><a id="a1a8421d402d5ba82257188b545e8d668"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularName</b> (std::string_view name)</td></tr>
<tr class="separator:a1a8421d402d5ba82257188b545e8d668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aab87c41acafaf1b1837b922495560d"><td class="memItemLeft" align="right" valign="top"><a id="a8aab87c41acafaf1b1837b922495560d"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularLiteral</b> (std::string const &amp;name)</td></tr>
<tr class="separator:a8aab87c41acafaf1b1837b922495560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe749450d2e610199801b189dc3d0f8"><td class="memItemLeft" align="right" valign="top"><a id="a2fe749450d2e610199801b189dc3d0f8"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>regularLiteral</b> (std::string_view name)</td></tr>
<tr class="separator:a2fe749450d2e610199801b189dc3d0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b>Root</b> class of the inheritance tree of abstracts. </p>
<p>Contains all functions that derived class needs. In particular all documented functions of the class <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> are <b>specialized</b> in all the <b>derived</b> <b>classes</b>. </p><dl class="section note"><dt>Note</dt><dd>Some functions are not documented here because not every derived class use them. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5fee68c1f3dcbda0e936926fed17616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fee68c1f3dcbda0e936926fed17616">&#9670;&nbsp;</a></span>Abstract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::Abstract::Abstract </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>
<p>Initializes name empty and commutable to <b>True</b>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5549ac0c186b3c6febf332245a25a82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5549ac0c186b3c6febf332245a25a82c">&#9670;&nbsp;</a></span>addAntiSymmetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::addAntiSymmetry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an anti-symmetry between the i1^{th} and the i2^{th} indices. If those indices are symmetric, an error is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1</td><td>Position of the first index. </td></tr>
    <tr><td class="paramname">i2</td><td>Position of the second index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a101219973341a39cf15f07e5e1aa388f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101219973341a39cf15f07e5e1aa388f">&#9670;&nbsp;</a></span>addition_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::addition_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special addition for Numerical- and Vectorial-types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Right operrand of the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two operands. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Complex.html#a69a2af4ec8f4f12a56cc1fc41223bc78">csl::Complex</a>, <a class="el" href="classcsl_1_1IntFraction.html#ac3d446b547d4c8b7d3b5359b87c756d5">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Polynomial.html#aa3ba91ac2475de7236ee8d48b85fc9fb">csl::Polynomial</a>, <a class="el" href="classcsl_1_1Float.html#ac269f085d5e4f9f43d4a5500751cfe33">csl::Float</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a91561bc3d02d055e86b7f3e35a76e25c">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1Integer.html#ad00b35bd5e52a36445b6e99265f20240">csl::Integer</a>, and <a class="el" href="classcsl_1_1NumericalEval.html#a558f10166698b0a00b9e844fc8781dd4">csl::NumericalEval</a>.</p>

</div>
</div>
<a id="a9cbf5ecfe10b79ecbe840ded8c3d8ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbf5ecfe10b79ecbe840ded8c3d8ced">&#9670;&nbsp;</a></span>addProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::addProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a property to the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The new property to add in <b>props</b>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#ad5ced3cf2d59c5ae12d9844a81877ae9">csl::TensorElement</a>, and <a class="el" href="classcsl_1_1AbstractLiteral.html#ae2187241c045a7399b1063d777bdf339">csl::AbstractLiteral</a>.</p>

</div>
</div>
<a id="ad431770faa4291116a50175193a11a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad431770faa4291116a50175193a11a88">&#9670;&nbsp;</a></span>addSymmetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::addSymmetry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a symmetry between the i1^{th} and the i2^{th} indices. If those indices are anti-symmetric, an error is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1</td><td>Position of the first index. </td></tr>
    <tr><td class="paramname">i2</td><td>Position of the second index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd972aed8326d4c13534594e061ee6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd972aed8326d4c13534594e061ee6da">&#9670;&nbsp;</a></span>antisymmetrise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::antisymmetrise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the anti-symmetrization of a 2D matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>1/2*(A - A^T) for a matrix (2D) A. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Matrix.html#a95c95848700fecd5d7041f5c28877946">csl::Matrix</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#a71a8d453b3d5c57f2d09b17e99302ef8">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a316956fea77627a716500a2bbfc1f3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316956fea77627a716500a2bbfc1f3b7">&#9670;&nbsp;</a></span>applyOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::applyOperator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leaveEmpty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the operator on an <b>operand</b>, iif the expression is an operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>Operand of the operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The operator filled with <b>operand</b>. </dd></dl>

</div>
</div>
<a id="a27ad666bf7d533607da9675b0c645ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ad666bf7d533607da9675b0c645ee9">&#9670;&nbsp;</a></span>askTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::askTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <b>expr</b> can factor <b>*this</b>. </p>
<p>In almost every case this corresponds just to the comparison ** *this == expr**. For <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a>, <a class="el" href="classcsl_1_1Pow.html" title="Handles the exponentiation of one Abstract wrt another. ">Pow</a>, Fraction types (all that are multiplicative) we must check if the factor hides in a product. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Factor to search in the expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is a possible factor. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a6ec375934423dbb60f6d00ea13ec7f80">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Pow.html#aca1c3fe5c3b30c69807073da07fe9d4e">csl::Pow</a>, <a class="el" href="classcsl_1_1Prod.html#adb2f82801fb73fb0baaaa18079e6cfa5">csl::Prod</a>, and <a class="el" href="classcsl_1_1Sum.html#a1620a408e74aa2b452a176f006fb3e5c">csl::Sum</a>.</p>

</div>
</div>
<a id="aad54ed41b2ce9bad3364fe30ad1a0d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad54ed41b2ce9bad3364fe30ad1a0d71">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr::iterator csl::Abstract::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A csl::vector_expr::iterator at the beginning of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a6236c27a797993973fb45dc9f4906962">csl::AbstractMultiFunc</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#aa8225d3dd07be192735c766e8d267774">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="adff373df9477d4e38581d09cc6d2fee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff373df9477d4e38581d09cc6d2fee4">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr::const_iterator csl::Abstract::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A csl::vector_expr::iterator at the beginning of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#aa405a3e5cd03bb390ce3e804fe8af806">csl::AbstractMultiFunc</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#a135f3df162ac8e7128a3e666e26cb81b">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="aa0c316b059cb2a1e3020310b148f921b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c316b059cb2a1e3020310b148f921b">&#9670;&nbsp;</a></span>checkIndexStructure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool csl::Abstract::checkIndexStructure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>A std::vector of <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two structures match. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#ad9d1474eb8d1c53835ffb3891e01b020">csl::TensorElement</a>.</p>

</div>
</div>
<a id="a1ebd84082bb93418408cc0babe2dffe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebd84082bb93418408cc0babe2dffe2">&#9670;&nbsp;</a></span>checkIndexStructure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool csl::Abstract::checkIndexStructure </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the compatibility of the index structure of an <b>Indicial</b> expression with another. In a sum, two terms must have exaclty the same index structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>A std::initializer_list of <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two structures match. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="ab3746f1d3667846824ea51b8a2e00d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3746f1d3667846824ea51b8a2e00d31">&#9670;&nbsp;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::collect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects terms in sum according to some factors given by the user. </p>
<p>This function allows the factor with some specific scalar variables. For example, <img class="formulaInl" alt="$ ax + ay + by $" src="form_6.png"/> can be factored in two ways. Either with <img class="formulaInl" alt="$ (a, b) $" src="form_7.png"/> which gives <img class="formulaInl" alt="$ a(x+y) + by $" src="form_8.png"/> ; or with <img class="formulaInl" alt="$ (x, y) $" src="form_9.png"/> which gives <img class="formulaInl" alt="$ ax + (a+b)y $" src="form_10.png"/>. With the collect function it is possible to choose precisely the set of variables that will be factored to express results in a standard way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factors</td><td>Factors to search in the expression. </td></tr>
    <tr><td class="paramname">full</td><td>Boolean (default = false) that tells if the collection must be recursive (full expression depth).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The collected expression if modifications have been done. </dd>
<dd>
std::nullopt else.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will probably replace the <a class="el" href="classcsl_1_1Abstract.html#a0bc0de9c4ce5f77fc716af0f502d13d3" title="Factors the Abstract. ">factor()</a> function in the future.</dd>
<dd>
For now, the collect function does not support factorization by indicial tensors, whereas <a class="el" href="classcsl_1_1Abstract.html#a0bc0de9c4ce5f77fc716af0f502d13d3" title="Factors the Abstract. ">factor()</a> does. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#accd66bc16179cf88684a6db68e277921">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#aeec6c024c50776cf5439872586451579">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#ac4f47febdbe3b773bce05b39d506e452">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Sum.html#af1f3a6d6201fef00ca9d4ad334cd01bd">csl::Sum</a>, and <a class="el" href="classcsl_1_1AbstractFunc.html#a2b1a66c3b926cd7a95060464a3bb6a62">csl::AbstractFunc</a>.</p>

</div>
</div>
<a id="a3f68d0cd93dfe2ac02d6d4afc80fb41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f68d0cd93dfe2ac02d6d4afc80fb41a">&#9670;&nbsp;</a></span>commutesWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::commutesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the object commutes with expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>*this</b> commutes with <b>expr</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#ac54eff0c503e2c2947b232622261c998">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#ac84821d717ca9ab1aed295b644fe8cae">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Variable.html#adfa4fb552a7ff6ab32eeea0a39dc97cd">csl::Variable</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#aa9de316c2975e097ea77162d7d1040c8">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#ae2422de442a3c2b7d3011012a5cb7a46">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1ScalarField.html#a678cb823606f003ce2ef6324c84d497b">csl::ScalarField</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a7a90b9f26666f4aff635bfbf7cd865b6">csl::AbstractVectorial</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#add4dd8d4ed4ea0d8817fdd79abd744cc">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a7caee12abb451168149779a668dfc59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7caee12abb451168149779a668dfc59e">&#9670;&nbsp;</a></span>compareWithDummy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool csl::Abstract::compareWithDummy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classcsl_1_1Index.html">Index</a>, <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAllCosntraints</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison disregarding name of dummy indices, i.e. the two expressions * are equals even if dummy indices have not the same names in *this and * expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to compare. </td></tr>
    <tr><td class="paramname">constraints</td><td>List of existing constraints between indices (it is modified in the function).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if expr == *this taking constraints into account. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IProd.html#a55b05e348d5a51d47d119059659b0ccb">csl::IProd</a>, <a class="el" href="classcsl_1_1ISum.html#a55c31985f0a3ee26f551f28c7b651d1d">csl::ISum</a>, <a class="el" href="classcsl_1_1TensorElement.html#acd1ac409b891dd033c1792f5473d8d10">csl::TensorElement</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#ac28ceccb0fea566ae54b2d01b70548f5">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1VectorIntegral.html#a6a1e720e6db9d81db825d18cea8a334a">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#a7568ac709f768fc70a4797731b7d9e7a">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#af16a648041a09ff87602427add048ee0">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1Scalar.html#af13ccfc54ed62f166cec31737bd02032">csl::Scalar</a>.</p>

</div>
</div>
<a id="ad874fc858295a737e6ce884530f1109b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad874fc858295a737e6ce884530f1109b">&#9670;&nbsp;</a></span>contraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::contraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a special contraction of indices. Before calling this function we must check that there is indeed a contraction by calling the function <a class="el" href="classcsl_1_1Abstract.html#aa31e08c251d96b8ea8ec8d385895c1ff" title="Tells (for an Indicial type) if there is a special contraction property with B. ">hasContractionProperty()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>Expression with which <b>*this</b> contracts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the contraction. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a2a301cd1beb0eecde2b83c1ca6167c59">csl::TensorElement</a>.</p>

</div>
</div>
<a id="ac3c9887977249e4d71ea36c6377b3581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c9887977249e4d71ea36c6377b3581">&#9670;&nbsp;</a></span>dependsExplicitlyOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::dependsExplicitlyOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check recursively if <b>expr</b> is present in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is found. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a22a5c9686859930af78f51a85b31160d">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Integral.html#a467c09b5b03f5e5a6ee28410ded0d09f">csl::Integral</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#ad072ccb3f8007430a6d6dce53f32b441">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#af76375171fcd6824d8410030fb2d5c28">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a6642c1edceccda7928bbd70256446428">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#a43644a7030777b98a28cbaa15f229bfa">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#aa67b2133ef52393513ecbdc72e45acb0">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1AbstractIntegral.html#ab675c7672e9523a8fdfaf71f9741bb93">csl::AbstractIntegral</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a5dfd1e8233507457f725e10e2624ec0f">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1AbstractField.html#a68758a644b0fa32760660acd3898910a">csl::AbstractField</a>, and <a class="el" href="classcsl_1_1AbstractNumerical.html#a1cc3b916f6ff6b0b63c17095c1375adc">csl::AbstractNumerical</a>.</p>

</div>
</div>
<a id="a40fe2ccf376dadd21b2d7a0f134d86c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fe2ccf376dadd21b2d7a0f134d86c6">&#9670;&nbsp;</a></span>dependsOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::dependsOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check recursively if the expression depends on <b>expr</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if a dependency in <b>expr</b> is found. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a14ad4f8a47af9ea009bcea3385e45bc3">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Integral.html#ae3d145e84f749ba49f57d59a277742c5">csl::Integral</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a9d64fefa1c3718d1fe431edfa4934e71">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a618856543c22406e8c7eed5b8a5a9c65">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a423dcc1eccb833f88b3f98caa52189a9">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Variable.html#aa8f5dda90b3f915c633745740e579abd">csl::Variable</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#ab452e8d298be5e58e28e92aa6eca1c25">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a8c3e75947048293c9c6cc0c8e261049f">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1AbstractIntegral.html#a72eadc4f6452f7139be88c9bfe0c8649">csl::AbstractIntegral</a>, <a class="el" href="classcsl_1_1Constant.html#a93af5fcd73748abeb661cd37206902d2">csl::Constant</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#acca79f2a53255ee6b10d51efc658cb19">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1AbstractField.html#a8697f4ebaaa9683457bb69f5f8c93f7a">csl::AbstractField</a>, and <a class="el" href="classcsl_1_1AbstractNumerical.html#afe459bd13460da89d77acb73d19baa59">csl::AbstractNumerical</a>.</p>

</div>
</div>
<a id="aecab8c872023a2d0771e7e4f83bb05f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecab8c872023a2d0771e7e4f83bb05f8">&#9670;&nbsp;</a></span>derive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::derive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the derivative of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another. </p>
<p>It is possible to derive wrt any complicated expr. In this case however, the calculation is <b>not</b> <b>always</b> <b>mathematically</b> <b>correct</b>. The program just searches for equal <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> or <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with the same name. In particular dx/d(exp(x))=0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression wrt which we derive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1DiracDelta.html#aa5b3c23a06e1de1af366eac1470784d6">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Factorial.html#aff04d4330b43f2a0c54d1f2089d09e97">csl::Factorial</a>, <a class="el" href="classcsl_1_1ATanh.html#a96c5e0b223b93c2a4469a73dfe3924f6">csl::ATanh</a>, <a class="el" href="classcsl_1_1ASinh.html#a4fb38ca160a4e8e770885ecaf2cc62f8">csl::ASinh</a>, <a class="el" href="classcsl_1_1ACosh.html#acb4452efbe7c588945a6f4e78d69d2fc">csl::ACosh</a>, <a class="el" href="classcsl_1_1Tanh.html#a4a70018c2b554641a3ab51291ca4a878">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#a8c235daf099d1ff4ebbff9fa846a7e82">csl::Sinh</a>, <a class="el" href="classcsl_1_1TensorElement.html#a7a1fc7737cce9da527d3796d2fd711d8">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Cosh.html#a028b7c99b3703dd1fb12c47cada7aaaf">csl::Cosh</a>, <a class="el" href="classcsl_1_1Angle.html#a739e0603cbf9fdee3c3a5373ff96a04a">csl::Angle</a>, <a class="el" href="classcsl_1_1Integral.html#a1c9d0d773d2fcc59eaf1e72dd55695df">csl::Integral</a>, <a class="el" href="classcsl_1_1ATan.html#a4b4ed4cfcd4c834f3a99ac2a474bad51">csl::ATan</a>, <a class="el" href="classcsl_1_1Derivative.html#af13a07941f0d3c519aca857daa01ee10">csl::Derivative</a>, <a class="el" href="classcsl_1_1ASin.html#afec8424240e853545a33c5c260195716">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#aa0c7176fd612d3d1ed3f1f61eb900399">csl::ACos</a>, <a class="el" href="classcsl_1_1Pow.html#a01955e262d0a06de299d1debf1e14da8">csl::Pow</a>, <a class="el" href="classcsl_1_1Tan.html#a53bc7f2997e0380a6d148c2f1dbf395a">csl::Tan</a>, <a class="el" href="classcsl_1_1Imaginary.html#a41cff9496eaf914c3a55a2ded645d334">csl::Imaginary</a>, <a class="el" href="classcsl_1_1Complex.html#acb2b53b0866d8fb7fb6a3911285944aa">csl::Complex</a>, <a class="el" href="classcsl_1_1Prod.html#a3830459faf91d3cf17c7fa401fb00557">csl::Prod</a>, <a class="el" href="classcsl_1_1Sin.html#a4a9faa3552509a110f6182306a3dd66c">csl::Sin</a>, <a class="el" href="classcsl_1_1IntFactorial.html#ab973e4c55cd0ecc72949b97de3029c98">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1IntFraction.html#a36c47cf74777eb484bd138d826c23edc">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Cos.html#ae4305e350e7d257c189df1d051169f9c">csl::Cos</a>, <a class="el" href="classcsl_1_1Variable.html#a22efd34dbcb5934a5acaf95efeef91b3">csl::Variable</a>, <a class="el" href="classcsl_1_1Log.html#a6fa3e9448a30bfb341a7ef9253841240">csl::Log</a>, <a class="el" href="classcsl_1_1Polynomial.html#ac50287568d1413fc72734a631e1e9f5c">csl::Polynomial</a>, <a class="el" href="classcsl_1_1Float.html#ad8c19d92099f26157248fc9023f9f599">csl::Float</a>, <a class="el" href="classcsl_1_1Exp.html#aff1fdef24f13fcc5f8ccccb8152eaa63">csl::Exp</a>, <a class="el" href="classcsl_1_1Constant.html#ac7602a9ee61e0821667fa6264c003a0b">csl::Constant</a>, <a class="el" href="classcsl_1_1Integer.html#a341c2f0b7aa9cd523ff5ee48c9ba49f0">csl::Integer</a>, <a class="el" href="classcsl_1_1AbstractIntegral.html#a9570853b5def96e519e54fc81a14f840">csl::AbstractIntegral</a>, <a class="el" href="classcsl_1_1Sum.html#a7dd23134290bcfeffb529e2c03ca17ff">csl::Sum</a>, <a class="el" href="classcsl_1_1Commutator.html#a74087e962f48d16fce0c02537372eea6">csl::Commutator</a>, <a class="el" href="classcsl_1_1NumericalEval.html#ac1eee86b7e08b0b5b39638cebd5abef2">csl::NumericalEval</a>, and <a class="el" href="classcsl_1_1Abs.html#afe47e46685e38164123937fffa8c3072">csl::Abs</a>.</p>

</div>
</div>
<a id="aeb08811cf370616477a92075e4a218ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb08811cf370616477a92075e4a218ee">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the determinant of the object if it corresponds to a square matrix (or a scalar), 0 else. </p>
<dl class="section return"><dt>Returns</dt><dd>det(<b>*this</b>) if <b>*this</b> is a square matrix or scalar. </dd>
<dd>
0 else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Matrix.html#a8015bb0c18517f1fc9429f8c5b95da38">csl::Matrix</a>.</p>

</div>
</div>
<a id="a1578c74aee1050b806a67e7a81a67f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1578c74aee1050b806a67e7a81a67f5c">&#9670;&nbsp;</a></span>division_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::division_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special division for Numerical- and Polynomial-types. For polynomial, the euclidean division of two polynomials is implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Right operrand of the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The division of the two operands. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Complex.html#a63e2aab7c637beb7fa67ccbc9b8b8c12">csl::Complex</a>, <a class="el" href="classcsl_1_1IntFraction.html#a0dc80b9e319900617056e4ab3c233c06">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Polynomial.html#ace27cf683f51c1a50f35e28b9250e5e6">csl::Polynomial</a>, <a class="el" href="classcsl_1_1Float.html#a7a35025055eaba4cc64707ac79e2aabc">csl::Float</a>, <a class="el" href="classcsl_1_1Integer.html#a98edda5fd2b84eb6fb6a5c0000d4c4fe">csl::Integer</a>, and <a class="el" href="classcsl_1_1NumericalEval.html#a042f302585cd78a8d323f3f28dd74c52">csl::NumericalEval</a>.</p>

</div>
</div>
<a id="a4cc7a46deaa3eaa7593909d74e76d4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc7a46deaa3eaa7593909d74e76d4af">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of two <b>Vectorial</b> expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The right operand of the dot product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum _k (*this)[i,j,...,k]*expr[k,l,m,...]. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a0ed41f66d207d34ebafc90bc473109ca">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a61e4e80d998a888a1a74d9ea3e10c0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e4e80d998a888a1a74d9ea3e10c0f1">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr::iterator csl::Abstract::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A csl::vector_expr::iterator at the end of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a178ccaec7d4546873084591d93398153">csl::AbstractMultiFunc</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#a06f69d432a047d7b48757d8362de68d4">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="ae2761d54f13310e13f5076d565edd7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2761d54f13310e13f5076d565edd7ef">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr::const_iterator csl::Abstract::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A csl::vector_expr::iterator at the end of argument for multi-argument expressions. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a42f8f99108068dca2bd7a259577a0bcf">csl::AbstractMultiFunc</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#ada11a590d79c87baf92a98888ee32c44">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="aa2d5a98ec433dad08613083c12f587cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d5a98ec433dad08613083c12f587cd">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt;<a class="el" href="classcsl_1_1Expr.html">Expr</a>&gt; csl::Abstract::evaluate </td>
          <td>(</td>
          <td class="paramtype">csl::eval::mode&#160;</td>
          <td class="paramname"><em>user_mode</em> = <code>csl::eval::base</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>Replaces all variables by their value and evaluating. This function must be used instead of <a class="el" href="classcsl_1_1Abstract.html#a543d5a4f0432e166b492ad28a860a65f" title="Evaluates the value of the Abstract. ">evaluateScalar()</a> when treating not only real scalars.* In particular (x=2, y=3) x+iy evaluates to 3+ 3i whereas <a class="el" href="classcsl_1_1Abstract.html#a543d5a4f0432e166b492ad28a860a65f" title="Evaluates the value of the Abstract. ">evaluateScalar()</a> would return 3. </p><dl class="section return"><dt>Returns</dt><dd>The abstract result of the evaluation. </dd></dl>

<p>Implemented in <a class="el" href="classcsl_1_1Factorial.html#ab104048896f3aafb93bf35a73d8fa783">csl::Factorial</a>, <a class="el" href="classcsl_1_1ATanh.html#ad9ee39eda573051de9b45699ed886f83">csl::ATanh</a>, <a class="el" href="classcsl_1_1ASinh.html#a6489126c02c25e4cfb295db5d85cadd5">csl::ASinh</a>, <a class="el" href="classcsl_1_1IProd.html#ac336baabde24424fc39efd66acc084ca">csl::IProd</a>, <a class="el" href="classcsl_1_1ACosh.html#a1b3ac8c059d26ae9142d9f240f7aeb78">csl::ACosh</a>, <a class="el" href="classcsl_1_1Tanh.html#a094ae3e5b29e66a9d4319fb774b5bfcb">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#aa7b24dd1844a99aa1bf73f59829d6cb0">csl::Sinh</a>, <a class="el" href="classcsl_1_1TensorElement.html#aaaa0e8d228945bad2ef6a8474a6df0c0">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Cosh.html#ad40b853fb9959e63b514ed9c71b5bf2a">csl::Cosh</a>, <a class="el" href="classcsl_1_1Angle.html#a2f0b4708a98d477767a53218adf0affa">csl::Angle</a>, <a class="el" href="classcsl_1_1Integral.html#a058cb4c2238b8ff1c66908c80d21fd8f">csl::Integral</a>, <a class="el" href="classcsl_1_1ATan.html#a275592a7ba6a9985e921b3a791dc461f">csl::ATan</a>, <a class="el" href="classcsl_1_1Derivative.html#a5165c55343cf326d361e7f4c44df986f">csl::Derivative</a>, <a class="el" href="classcsl_1_1ASin.html#afd6d69a61c924d596c1f7adb859893b0">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#a17e119e2f6d22f0b6c1f149e2ebefcd5">csl::ACos</a>, <a class="el" href="classcsl_1_1Pow.html#aa12ddb1c3b4952756d9eb15196a1674f">csl::Pow</a>, <a class="el" href="classcsl_1_1Tan.html#a1c5025345411cb71d081394524492ae1">csl::Tan</a>, <a class="el" href="classcsl_1_1Imaginary.html#aac1fdac38ead90cfe0d4033896cfb13a">csl::Imaginary</a>, <a class="el" href="classcsl_1_1Complex.html#a0651cc75f7010f12fdd80cd0d458b568">csl::Complex</a>, <a class="el" href="classcsl_1_1Sin.html#a9977b55ee7079bf9bc7205a57975dd5f">csl::Sin</a>, <a class="el" href="classcsl_1_1Prod.html#abd8408064c53f614ef5e2bdff399c6d3">csl::Prod</a>, <a class="el" href="classcsl_1_1IntFactorial.html#a5cfc7511cbf57edd5f47d3bbde9d0798">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1Cos.html#a3baf3fecf9ea48db4ba1fbbfd3aee05b">csl::Cos</a>, <a class="el" href="classcsl_1_1IntFraction.html#aff12a6c06a577d55f295d3d474118a73">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Variable.html#a96c4549dce7d30db1f06180f8d3d0145">csl::Variable</a>, <a class="el" href="classcsl_1_1Log.html#a6007d682abe9cd508476984a051c0844">csl::Log</a>, <a class="el" href="classcsl_1_1Polynomial.html#a4ef2dc0f782257d31ba7f5028cbd5e34">csl::Polynomial</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#a55ad56ca57e69bdcb5b77e6d0bf254c7">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1Float.html#ab4d0c0ffa060f4a4242fa1920b5f7c7e">csl::Float</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a224c6e6a26a42ac2dba35e30e2e7a521">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1Exp.html#a9927422cac69f3ef722551ac4d37d33f">csl::Exp</a>, <a class="el" href="classcsl_1_1Constant.html#a77a25c084010808eae31429df43996eb">csl::Constant</a>, <a class="el" href="classcsl_1_1AbstractIntegral.html#a03f67aec1f7e9b74fd65383e0fc6600f">csl::AbstractIntegral</a>, <a class="el" href="classcsl_1_1ScalarField.html#ab4d59ddc0a293ba0220073ad43124165">csl::ScalarField</a>, <a class="el" href="classcsl_1_1Integer.html#a029be2af666fd37d37412473cceeb546">csl::Integer</a>, <a class="el" href="classcsl_1_1Commutator.html#a41beafb3d55c2f33e20a904a09ded5a9">csl::Commutator</a>, <a class="el" href="classcsl_1_1Sum.html#af3c54e000687a23ad678c77760ffaaf1">csl::Sum</a>, <a class="el" href="classcsl_1_1ImaginaryPart.html#a8423033a6934636a15e47b5ccb0df70e">csl::ImaginaryPart</a>, <a class="el" href="classcsl_1_1AbstractElement.html#ad0583927014b475eb57853429c91df20">csl::AbstractElement</a>, <a class="el" href="classcsl_1_1NumericalEval.html#a594785ad7587567191a29f7fa39f27ab">csl::NumericalEval</a>, <a class="el" href="classcsl_1_1Arbitrary.html#ab4744294dedcb8b4402b76f821b275cf">csl::Arbitrary</a>, <a class="el" href="classcsl_1_1Abs.html#ac08757293e89b6352824ae09843a5c18">csl::Abs</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#afaf73d258e30ae78513cfaa4d7c65d59">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1RealPart.html#aeb57b368c5ae7caa278ca998cb3a4782">csl::RealPart</a>, and <a class="el" href="classcsl_1_1Scalar.html#a6a314ec848b531241824a715da3c9eb2">csl::Scalar</a>.</p>

</div>
</div>
<a id="a543d5a4f0432e166b492ad28a860a65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543d5a4f0432e166b492ad28a860a65f">&#9670;&nbsp;</a></span>evaluateScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double csl::Abstract::evaluateScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the value of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>Tries to replace all variables by a real value. If it is not possible (for example treating a <a class="el" href="classcsl_1_1Vector.html">Vector</a> or an <a class="el" href="classcsl_1_1Imaginary.html" title="Numerical representation of i. ">Imaginary</a>) the considered object is replaced by 0. A warning message is displayed in the case of i. </p><dl class="section return"><dt>Returns</dt><dd>The value of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> (double). </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Factorial.html#a59bdb12cae8d39b453b2f345f4a388ad">csl::Factorial</a>, <a class="el" href="classcsl_1_1ATanh.html#a7a486ca2937c53a6d5940c2245da87b5">csl::ATanh</a>, <a class="el" href="classcsl_1_1ASinh.html#a22b8dc76ae36362de29bb2614925a8b6">csl::ASinh</a>, <a class="el" href="classcsl_1_1ACosh.html#a3cece5a5ecb328b31e7f235b43bdab67">csl::ACosh</a>, <a class="el" href="classcsl_1_1Tanh.html#ae507f59e44931085e7ac8a7d85a28ee5">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#ad2e6606fa0e330acc102e4057a627425">csl::Sinh</a>, <a class="el" href="classcsl_1_1Cosh.html#a403d11f101661cb030e72f41907fdfc7">csl::Cosh</a>, <a class="el" href="classcsl_1_1Angle.html#ab6f5cc0b8e682f2d670d65c76402a738">csl::Angle</a>, <a class="el" href="classcsl_1_1ATan.html#a5cc44ce49897c4488538e7b2f8ecf0b3">csl::ATan</a>, <a class="el" href="classcsl_1_1Derivative.html#a2cdecc31aec95ae92fdbb0a24f3f8589">csl::Derivative</a>, <a class="el" href="classcsl_1_1ASin.html#af81b867514a85671642e52445b18e4d9">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#a24cd3961c5c39c3788a702410c437808">csl::ACos</a>, <a class="el" href="classcsl_1_1Pow.html#aa2d9132cb7ca63dfba3eb81466a9c3c9">csl::Pow</a>, <a class="el" href="classcsl_1_1Tan.html#a01cd6db9fc2543411cba9362d082b54d">csl::Tan</a>, <a class="el" href="classcsl_1_1Imaginary.html#a6c195a0913b72cd58940bd06fedd8432">csl::Imaginary</a>, <a class="el" href="classcsl_1_1Complex.html#a4a5a2813d3cba5cc8c761959f3dd17fb">csl::Complex</a>, <a class="el" href="classcsl_1_1Sin.html#af7b3d229ea8b52816102b4facbd7d6bb">csl::Sin</a>, <a class="el" href="classcsl_1_1Prod.html#a3bfdd94f06244aa5af7027901d9e00dd">csl::Prod</a>, <a class="el" href="classcsl_1_1IntFactorial.html#aa25285ce9c79edb763716c5d903febc0">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1Cos.html#a6eb534b4b475261522c8c93ce594646c">csl::Cos</a>, <a class="el" href="classcsl_1_1IntFraction.html#a73241811979616fa6106f9ba2addd23e">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Variable.html#a07be9df0d692e8a4dcd7ac913baee1ac">csl::Variable</a>, <a class="el" href="classcsl_1_1Log.html#a557c51c92ffe849c9f96e9a9f65d39de">csl::Log</a>, <a class="el" href="classcsl_1_1Polynomial.html#a7a0909807aa3cd11e0d213370c742bb4">csl::Polynomial</a>, <a class="el" href="classcsl_1_1Float.html#a244fc461c1b78ecdf0791d64cef8100d">csl::Float</a>, <a class="el" href="classcsl_1_1Exp.html#a396b88644ca6fe350fff11960592c4b7">csl::Exp</a>, <a class="el" href="classcsl_1_1Constant.html#ab324b60959cde778500b675b3bf6433e">csl::Constant</a>, <a class="el" href="classcsl_1_1Integer.html#a3b0670d4d8bddf30871f72a15a30f856">csl::Integer</a>, <a class="el" href="classcsl_1_1Commutator.html#a1540b8e45df030f7828a092370feafaf">csl::Commutator</a>, <a class="el" href="classcsl_1_1Sum.html#aa8f5632f8b3be2615f29085195c7abe2">csl::Sum</a>, <a class="el" href="classcsl_1_1Abs.html#abd250986b9ce084c98fb968db0fb587b">csl::Abs</a>, and <a class="el" href="classcsl_1_1NumericalEval.html#a818803fe8a90c3959de011c2142106e0">csl::NumericalEval</a>.</p>

</div>
</div>
<a id="a3a87ab082152fea4fc2444659028b840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a87ab082152fea4fc2444659028b840">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::expand </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inPlace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Develops</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full</td><td>If true the expandment is <b>recursive</b> through all the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expand <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#ad5d18f22f9eed16868b1e8e14a0797c3">csl::Pow</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#aa7b240760c1c7d930053fbd38c812196">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Prod.html#a2c508afc1d4a74cd1ca69b1f900993d5">csl::Prod</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#add5adbf1747cd9343c96dca5a2b7479b">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a5dbc9bf69fbe0beb1034b21f83ba6aba">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Exp.html#a53d5fa8b9bf211862d9c6dde6fcad3a6">csl::Exp</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a09396a6b80940ac8c99604e9b845c815">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a8bc591288c134387b71c758229d65f54">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a7cbbd2edd75a84057f1622826c1efd3a">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="aeb48aaaa856582b6359037fe94d2419b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb48aaaa856582b6359037fe94d2419b">&#9670;&nbsp;</a></span>expand_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::expand_if </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inPlace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Develops</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>This function concerns only products (and exponents) that will be flatten to give at the end a sum of independant terms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functions that returns a boolean that determines which arguments must be expanded in products. </td></tr>
    <tr><td class="paramname">full</td><td>If true the expandment is <b>recursive</b> through all the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expand <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#a9b2bb69232d43c764369d8859662ecda">csl::Pow</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#af09641d4d997d869626ff660ca4d3f8b">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Prod.html#aa6bb716b3dea854dd7e897976cf08788">csl::Prod</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a1fee5554d976f77bf0e2dd5a451890b7">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#adda5dcff671af0afed2ce13d81b1a903">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Exp.html#a0742b26f0efd5a82473f3d8b26524fcd">csl::Exp</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a8907475ad6468725bafe0c81dfbeb688">csl::AbstractVectorial</a>, and <a class="el" href="classcsl_1_1AbstractFunc.html#a3be99a2a139aeb34596b598bafa9975d">csl::AbstractFunc</a>.</p>

</div>
</div>
<a id="aa2696a0feb43766ef54e1e3dd3d6d134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2696a0feb43766ef54e1e3dd3d6d134">&#9670;&nbsp;</a></span>exponentiation_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::exponentiation_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special exponentiation for Numerical- and Vectorial-types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>exponent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponentiation of the two operands. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Complex.html#a46dbf92ea6c22239857b6e41eb01b297">csl::Complex</a>, <a class="el" href="classcsl_1_1IntFraction.html#a2184e11c09413bea72653bad45e8f997">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Float.html#a6a20dfce78e1b4a979d11731db030987">csl::Float</a>, <a class="el" href="classcsl_1_1Integer.html#a26e655bb92db0fad0c3970746c8e5c93">csl::Integer</a>, and <a class="el" href="classcsl_1_1NumericalEval.html#a2aefa5e08a16b11494b5fa221ed66150">csl::NumericalEval</a>.</p>

</div>
</div>
<a id="a0bc0de9c4ce5f77fc716af0f502d13d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc0de9c4ce5f77fc716af0f502d13d3">&#9670;&nbsp;</a></span>factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::factor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Factors</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>This function tries to factor the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt any <b>factor</b>. This will be more involved in calculation than the other factorizing function that takes the factor as a parameter. So this function <b>must be used only</b> if we don't know the factors we want at the end. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full</td><td>If true the factorization is <b>recursive</b> through all the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1ISum.html#a04d25076743802b4a5d98f082e3441c6">csl::ISum</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#ad9eed372c276bc55ce8614a94962fef6">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a984d8c40c787a0d7350aa0de1969c65f">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a0a9110ce4150f135902865efdd99c130">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Polynomial.html#ae49aeb195fc59129d3c9e087b32a35b1">csl::Polynomial</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a9b1f0b9354e966da0d740965ec068ccd">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1Sum.html#af56a4a850dcb91db747ff8ca36f458a2">csl::Sum</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#ad13204b56adf098d9c4b886ea7b8681f">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a2f12cede626ece5382c9869d32c32146">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a8fb3d657c65606d520688db6401fe650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb3d657c65606d520688db6401fe650">&#9670;&nbsp;</a></span>factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Factors</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt a <b>particular</b> <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt which we try to factor. </td></tr>
    <tr><td class="paramname">full</td><td>If true the factorization is <b>recursive</b> through all the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a71ffe88901a200f59bdb88d4adf09a44">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#afff58e758180748e03f566e9ac83e728">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a8bfd43c575fadc19e46948953af5f2a5">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a368c2a6b5fb359cc8f6f209ec548f0ad">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1Sum.html#aeb31f0009bdb90913b98c693578b54a3">csl::Sum</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a281d2d19b84b9b5fec66dbf1eb89a27d">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a447f940bf0a08d13297fde0b50b4cb84">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a299b1fd6c2b9d80ad90a08c7acef28d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299b1fd6c2b9d80ad90a08c7acef28d2">&#9670;&nbsp;</a></span>findSubExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::findSubExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>subExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>newExpression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches a sub-expression and replaces it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subExpression</td><td>Expression to search. </td></tr>
    <tr><td class="paramname">newExpression</td><td>Expression that replaces <b>subExpression</b> if it is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expression with the replacement done. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#acb17ac601dd6fb6c98a6de6983d41009">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Prod.html#a6658c74878dc31902a45b75994baef85">csl::Prod</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a86ac8ca4a6eed274d004d989f3a65f3d">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a2844b245ea8608c32be1ae2794a12858">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a4000d3f204c1957f5cffc0677dd754c0">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="afcbcb9dd55c73dbcbfe8c091d3e5c02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbcb9dd55c73dbcbfe8c091d3e5c02e">&#9670;&nbsp;</a></span>getAlternateForms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::Abstract::getAlternateForms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns all possible alternate forms of the expression in terms of simplifications. For example 1-sin^2(x) is one of the alternate forms of cos^2(x). </p>
<p>Those alternate forms are then compared in terms of simplicity, this allows automatic simplification. Alternates are tried to simplify, and the bests are chosed. More details and algorithms in file alternateForms.cpp. </p><dl class="section return"><dt>Returns</dt><dd>A std::vector containing the alternate forms of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Tanh.html#a5aace400a17b4fae94f6f0d182fe3087">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#a7db2a3f1e51c96c719cae29b24ab7b4e">csl::Sinh</a>, <a class="el" href="classcsl_1_1TensorElement.html#a0916129965c1d6117aa613fa8c2b42ea">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Cosh.html#a79a4bfedadb816425b60fc15d9c4d22c">csl::Cosh</a>, <a class="el" href="classcsl_1_1Pow.html#ac0345493ba5c3ab02b35f88054e1c230">csl::Pow</a>, <a class="el" href="classcsl_1_1Tan.html#a19786abcea9ea33b4ac3905b659512ff">csl::Tan</a>, <a class="el" href="classcsl_1_1Prod.html#a5a047d58293033f1c409430d281ff805">csl::Prod</a>, <a class="el" href="classcsl_1_1Sin.html#a758f32e24c7e614d7fc1d2199db252da">csl::Sin</a>, <a class="el" href="classcsl_1_1Cos.html#a100feac29b277523022558ee400791f0">csl::Cos</a>, and <a class="el" href="classcsl_1_1Sum.html#adcc92cb4e44f443feb122841ff960f5e">csl::Sum</a>.</p>

</div>
</div>
<a id="ac33a42309d629d47bfdbede4e152414e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33a42309d629d47bfdbede4e152414e">&#9670;&nbsp;</a></span>getArgument() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp; csl::Abstract::getArgument </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The i^{th} argument of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a75ae783c1bd8e55ccc005af538599def">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a3f571d26e241f9a943e11191c3ebe9a6">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a6db2c19ea96bee60189534d583fc2af3">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a2320c9f9c71eb81a2348175dd14404a9">csl::AbstractVectorial</a>, and <a class="el" href="classcsl_1_1AbstractFunc.html#adf8cb8650883f5ea7729cdabec2aeab0">csl::AbstractFunc</a>.</p>

</div>
</div>
<a id="ad94b3892af147ac0b05c1d8c960e4eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94b3892af147ac0b05c1d8c960e4eba">&#9670;&nbsp;</a></span>getArgument() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> const&amp; csl::Abstract::getArgument </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get specific arguments of expressions in multiple dimensions, by giving the indices in each dimension. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The argument {i,j,...} of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a0b390a72cda8abec3954bfc8229cb0f7">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a2263731ca94825f35281e69fb258cf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2263731ca94825f35281e69fb258cf87">&#9670;&nbsp;</a></span>getCommutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::getCommutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to know if the object commutes with all the others. </p>
<dl class="section return"><dt>Returns</dt><dd><em>commutable</em> </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a2bc449bd37728479b8c6b0a9eea3bccf">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a032adea087db90b6ed2c222942fdebd6">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Variable.html#ab418e2b424462798f44ebfe186b445c3">csl::Variable</a>, <a class="el" href="classcsl_1_1Constant.html#adfbd3cd70f84232b7518ff59b22ed0e6">csl::Constant</a>, <a class="el" href="classcsl_1_1AbstractElement.html#ab3418bd6d3548316885c8bda0a7464b8">csl::AbstractElement</a>, and <a class="el" href="classcsl_1_1AbstractFunc.html#ab41faa67ed807f3cc2c95f5f175e9099">csl::AbstractFunc</a>.</p>

</div>
</div>
<a id="a9cc64c66894acafc1f069dc40072084b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc64c66894acafc1f069dc40072084b">&#9670;&nbsp;</a></span>getComplexArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::getComplexArgument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>argument in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The argument part of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1DiracDelta.html#a3dd7b9fb46af05be5d43baa83412ebac">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Tanh.html#a3c66791362233e86cf739e907303d697">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#a596d1ee28a2d06a4e4c0bf55d7f12041">csl::Sinh</a>, <a class="el" href="classcsl_1_1Cosh.html#a6efd3054c14922af72c0e057395869f2">csl::Cosh</a>, <a class="el" href="classcsl_1_1ASin.html#a390673a164b5daae797188ebebc2a4fc">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#a745db1e3e6c7e9afb433a89b0f10b0a0">csl::ACos</a>, <a class="el" href="classcsl_1_1Tan.html#a36c5713ba2b02de5da810bbdc1cf0cce">csl::Tan</a>, <a class="el" href="classcsl_1_1Complex.html#a3cbe87d94da0eeca27369afc69f2fa4d">csl::Complex</a>, <a class="el" href="classcsl_1_1Imaginary.html#a4a8beac2eb84273afdfbb771918f04e3">csl::Imaginary</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a46c3300eb0f87234002c476d3c7c9a14">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Sin.html#a91951762c50bbf889d5d0aa1cfd7847f">csl::Sin</a>, <a class="el" href="classcsl_1_1Prod.html#aad33ce50bdda177231353749abb24b71">csl::Prod</a>, <a class="el" href="classcsl_1_1Cos.html#aae93b65d1aa61e9c6a4422d5c168f617">csl::Cos</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a14a9ddd387b869c129c48dfaea5974ad">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Log.html#a16aff9ed9a21cb6653deb96048f29225">csl::Log</a>, <a class="el" href="classcsl_1_1Exp.html#a9834c3827d1af36549c055f3a4f65c6d">csl::Exp</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#ae67e2d46dfb78e3278fc2134b7d039e4">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1Sum.html#adc1cd9a04f2299205aa8d896ba03482b">csl::Sum</a>.</p>

</div>
</div>
<a id="a03e8bdba20c6192a948892f212f09dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e8bdba20c6192a948892f212f09dbe">&#9670;&nbsp;</a></span>getComplexConjugate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::getComplexConjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the complex conjugate of the expression. </p>
<dl class="section return"><dt>Returns</dt><dd>{*this}. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a684ed9584f9bbe4ffc1e842b84a05ed0">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Complex.html#ae87c5c2100541896a3b474d5908a6e3d">csl::Complex</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#abd84cb1aa54ef9875bae6f806ed1d753">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a1b6a2e64b07222e4d5d126d2281c4816">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a04866fe8e757f391e79d6aaa18885221">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1ImaginaryPart.html#adfe21172f295b803952c5541750b338e">csl::ImaginaryPart</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a3a466c8804d5c855dd2b906be2b1be5f">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a2a2c1314e65baf839542e6fb7845ad44">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1Complexified.html#a9d3fec789b00de1625df53232da4cf30">csl::Complexified</a>, and <a class="el" href="classcsl_1_1RealPart.html#a1f8b200d737183f15a2edb7d923d464d">csl::RealPart</a>.</p>

</div>
</div>
<a id="a859f792aec52ba1fe1181f81d1cc3451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859f792aec52ba1fe1181f81d1cc3451">&#9670;&nbsp;</a></span>getComplexModulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::getComplexModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>modulus in the complex plane</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The modulus part of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1DiracDelta.html#acb4f35b6aef57ce0426f581f65ad7d68">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Tanh.html#ae5ecb5e85628afc42d25872291a718ed">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#a9c8562fa4fa0a8b9bfd299659b2948cf">csl::Sinh</a>, <a class="el" href="classcsl_1_1Cosh.html#a1eead10ed28b194fd75399d748a63254">csl::Cosh</a>, <a class="el" href="classcsl_1_1ASin.html#a776b7c1794fe574114e1e3198d73fa18">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#a9363acfe89a647a562322a036fe68469">csl::ACos</a>, <a class="el" href="classcsl_1_1Tan.html#a34ccf0fdcfa2a43f5725e32e9c201aeb">csl::Tan</a>, <a class="el" href="classcsl_1_1Complex.html#afc7177213e2612bddfe1e299847a0386">csl::Complex</a>, <a class="el" href="classcsl_1_1Imaginary.html#a6a4442943faf0d148692e6f3f70823b2">csl::Imaginary</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#ac1bea898b7169caabc409badff44c710">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Sin.html#a34f3048a1f09a214bc240cb0030c2c11">csl::Sin</a>, <a class="el" href="classcsl_1_1Prod.html#af42fef880d91a3705f0a86065f53560d">csl::Prod</a>, <a class="el" href="classcsl_1_1Cos.html#a7f26952b1462ae3b1cd2ee13ce5dcaff">csl::Cos</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#ab8d3db6601adde22f9cfcaa5b046bcbe">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Log.html#a130216294a13120423ff0d742321d4b1">csl::Log</a>, <a class="el" href="classcsl_1_1Exp.html#a6fd77dde2c403a67d2020966a14b0033">csl::Exp</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a1c8b58da63fe78c40174e6f2f582cbf3">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a83aa54cdff8a16f0a305358d992096f1">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1Sum.html#a6a358933e479aa4dcb68c9fff7a4dcc3">csl::Sum</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a09e06ecdb4eb9c6f8434c19ede046fa1">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="af04c0e4426f0bf9df365afe0148d59df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04c0e4426f0bf9df365afe0148d59df">&#9670;&nbsp;</a></span>getContractedPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; pair&lt; int, int &gt; &gt; csl::Abstract::getContractedPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All contracted pairs of indices of an <b>Indicial</b> expression. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not yet well implemented and may not be useful in the future. </dd></dl>

</div>
</div>
<a id="a9531d78d67c82e288c0130da5b1ba80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9531d78d67c82e288c0130da5b1ba80b">&#9670;&nbsp;</a></span>getDenom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long int csl::Abstract::getDenom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The denominator for a <a class="el" href="classcsl_1_1IntFraction.html" title="Handles fractions of Number. ">IntFraction</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IntFraction.html#ab3c87296f84c24abd4e5d0531b992404">csl::IntFraction</a>.</p>

</div>
</div>
<a id="a5856c3d55a6d1406970f3656e61efe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5856c3d55a6d1406970f3656e61efe8e">&#9670;&nbsp;</a></span>getDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::getDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>dimension</b> of the object. </p>
<p>Allows to know if we are manipulating a pure scalar (i.e. that can have a real value) or something else. There is the particular case of the <a class="el" href="classcsl_1_1Imaginary.html" title="Numerical representation of i. ">Imaginary</a> <b>i</b> that is considered as a scalar for simplicity but in reality cannot be evaluated with a real. Example: 1 + <b>i</b> cannot be reduced. </p><dl class="section return"><dt>Returns</dt><dd>dim (a non memorized integer corresponding to the dimension of the abstract) </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#afda6fa063a671a3a0feee716621c19c3">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="ac513c930caa9939c2b9557f36a34ee69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac513c930caa9939c2b9557f36a34ee69">&#9670;&nbsp;</a></span>getExponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::getExponents </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills in a vector the exponents corresponding to some factors for the expression. </p>
<p>For example, an expression like <img class="formulaInl" alt="$ 2ax^2\cos y $" src="form_0.png"/> will have exponents <img class="formulaInl" alt="$ (1, 2, 0) $" src="form_1.png"/> for the set of factors <img class="formulaInl" alt="$ (a, x, y). $" src="form_2.png"/> <b>factors</b> and <b>exponents</b> must of course be of the same size. Otherwise the behaviour is undefined.</p>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the expression is canonical, in particular that no terms like <img class="formulaInl" alt="$ x\cdot x^2 $" src="form_3.png"/> can appear.</dd>
<dd>
This function does not take into account factors in sums like <img class="formulaInl" alt="$ (1 + x) $" src="form_4.png"/> (this will return a factor 0 for <img class="formulaInl" alt="$ x $" src="form_5.png"/>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factors</td><td>Factors. </td></tr>
    <tr><td class="paramname">exponents</td><td>Exponents (out variable, modified during the run). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#a6906b6f3c06c1e1c7aad71d272eac65f">csl::Pow</a>, and <a class="el" href="classcsl_1_1Prod.html#a1b3dfc8deb0baece750b925ef1a95402">csl::Prod</a>.</p>

</div>
</div>
<a id="ac34c9c6f05e692faeed2f030514787ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34c9c6f05e692faeed2f030514787ad">&#9670;&nbsp;</a></span>getFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::Abstract::getFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get a std::vector of all terms than could factor the expression. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector containing the possible factors of <b>*this</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#ae28914863f9dfd25c0acdeb372ef2455">csl::Pow</a>, <a class="el" href="classcsl_1_1Prod.html#aaa4dca91f1ce4fc9d6f04d528e07db90">csl::Prod</a>, and <a class="el" href="classcsl_1_1Sum.html#ab2e21f4faf128cc9d9e471370def40e7">csl::Sum</a>.</p>

</div>
</div>
<a id="aa4136dc23f1fba4bf897b54c8592ccfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4136dc23f1fba4bf897b54c8592ccfc">&#9670;&nbsp;</a></span>getFreeIndexStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> csl::Abstract::getFreeIndexStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The free index structure of the <b>Indicial</b> expression </dd></dl>

</div>
</div>
<a id="a43f44bbb3685fc9f4a0402223b2e1004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f44bbb3685fc9f4a0402223b2e1004">&#9670;&nbsp;</a></span>getImaginaryPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getImaginaryPart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>imaginary part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The imaginary part of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1DiracDelta.html#aea8385f39d0ddccf6b45caa1942ec3cd">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Tanh.html#a6079ee469f697fb680639537590ebd0f">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#aa9674cc4b3452c469d0c1314e3c8bd5b">csl::Sinh</a>, <a class="el" href="classcsl_1_1Cosh.html#a86f7a0850d4ee1968733701c27273fce">csl::Cosh</a>, <a class="el" href="classcsl_1_1ASin.html#ab7c943492f3eb479cc7f846049e86811">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#aab3e1ceb5273ff6ada3c1d0d207f75d3">csl::ACos</a>, <a class="el" href="classcsl_1_1Tan.html#af3ffacb8a8af004785a01eb099d5c246">csl::Tan</a>, <a class="el" href="classcsl_1_1Complex.html#a38b17d76b63dc1afdb59c4405b1aff6d">csl::Complex</a>, <a class="el" href="classcsl_1_1Imaginary.html#ae7380d519a460d8cf1dff4f676b9df78">csl::Imaginary</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a232e9782e303c525a18f436e5e5f97b9">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Sin.html#a84960733192e56a4335215ba5ebb6a65">csl::Sin</a>, <a class="el" href="classcsl_1_1Prod.html#add2e178b9370eba2bd70d3ed17512a0c">csl::Prod</a>, <a class="el" href="classcsl_1_1Cos.html#adfb13db23ecb0b199fd19ce03a68af09">csl::Cos</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a484a42c8d029d02f2def2df2bf24c7c0">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Log.html#a2c9e7604ea16b86991190c95a48b6819">csl::Log</a>, <a class="el" href="classcsl_1_1Exp.html#a08b474f3f0dbf2255e4c142ad5e095e1">csl::Exp</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a4d3d4dbce8837fc40b19131a019044a3">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a24aee4ffda2255a56fd2eb2e04c9baad">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1Sum.html#a91c2be7f869326606fba475ea557b409">csl::Sum</a>, and <a class="el" href="classcsl_1_1Complexified.html#a11702661de0ea3b9c59b1f23af0ca0c0">csl::Complexified</a>.</p>

</div>
</div>
<a id="a3234ce243f6a2e11950be42f10100943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3234ce243f6a2e11950be42f10100943">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Index.html">Index</a> csl::Abstract::getIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Spot of the index to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the i^{th} index of an <b>Indicial</b> expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a029c4358822daed54f4f775032896790">csl::TensorElement</a>.</p>

</div>
</div>
<a id="ae125a32b6f3d0368b6055d4e58c1ff3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae125a32b6f3d0368b6055d4e58c1ff3f">&#9670;&nbsp;</a></span>getIndexStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> csl::Abstract::getIndexStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The index structure of the <b>Indicial</b> expression </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IProd.html#ae5870d95277493876ab0464e98d30c6a">csl::IProd</a>, <a class="el" href="classcsl_1_1ISum.html#ab5cffff2ab64b2f15099955102849bdb">csl::ISum</a>, <a class="el" href="classcsl_1_1TensorElement.html#a3dc05ca45a03e8a7f8459812e07b85f6">csl::TensorElement</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#aab730479855c747fa6baafe4c50ca8cf">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1VectorIntegral.html#a2b23eb2012ae1b985e0e2318f11cf3f5">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a7b6c806179b294bbbcd606cb9257fd99">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Polynomial.html#a7990b3e8d7eb1fc76e6270c71eb4a89c">csl::Polynomial</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a53ef9c900304f02f54ce6ea1485b4537">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1Scalar.html#a503524f6c324165a9aefa4edd7792462">csl::Scalar</a>.</p>

</div>
</div>
<a id="af7f5e7466e754984a2c4394a112464f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5e7466e754984a2c4394a112464f7">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const  &amp; csl::Abstract::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>'s name. </p>
<dl class="section return"><dt>Returns</dt><dd><em>name</em> </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Variable.html#a7ebe3e5b8b4ce47890e7ca4bbf6d634e">csl::Variable</a>, <a class="el" href="classcsl_1_1Constant.html#a8ab390edad6e1237057a217800526862">csl::Constant</a>, <a class="el" href="classcsl_1_1AbstractElement.html#ae80699e259632a43c4f69a125b64ae30">csl::AbstractElement</a>, <a class="el" href="classcsl_1_1Arbitrary.html#a25dce08825f0efbf6715c8db35f981e6">csl::Arbitrary</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#aae5db88feee1be51e3ad429c6c10df58">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="aa034448201c9e7998bbbb5e409636b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa034448201c9e7998bbbb5e409636b30">&#9670;&nbsp;</a></span>getNArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::getNArgs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of arguments of the expression. If the expression is a building block (<a class="el" href="classcsl_1_1AbstractBuildingBlock.html" title="Abstract class from which derive all building blocks of exprs, i.e. objects not function of further e...">AbstractBuildingBlock</a>), this function returns 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of arguments of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#af12bbdfb8a1b45d722d37f2444443457">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a2effb7bc0153b8c4e6d3c695d3b245cb">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#ae32e5909a9d7616ceac05b22a74b1284">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#a2689157ec6445f198e36dadb4d9aef78">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a42125e9765a771c47819548d342b0b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42125e9765a771c47819548d342b0b28">&#9670;&nbsp;</a></span>getNContractedPairs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::getNContractedPairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of contracted pairs of indices <b>in an Indicial expression</b>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of contracted pairs of indices. </dd></dl>

</div>
</div>
<a id="a204dbd37b63432cb08932b995f49d3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204dbd37b63432cb08932b995f49d3f4">&#9670;&nbsp;</a></span>getNFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::getNFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of possible factors for the expression </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#a5f65eed081f73e0c0ff2c9c5247e5aa9">csl::Pow</a>, and <a class="el" href="classcsl_1_1Prod.html#a065a0b483082e58a478016d0821427ab">csl::Prod</a>.</p>

</div>
</div>
<a id="add364193f7a78ac28f7001c7f4036453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add364193f7a78ac28f7001c7f4036453">&#9670;&nbsp;</a></span>getNIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::getNIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of indices of an <b>Indicial</b> expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a5ddd03efb94ea0017def76cd6777f745">csl::TensorElement</a>.</p>

</div>
</div>
<a id="a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa6bcc7cb8ee1574f29dc6ab6c6f0ed">&#9670;&nbsp;</a></span>getNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long int csl::Abstract::getNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The numerator for a <a class="el" href="classcsl_1_1IntFraction.html" title="Handles fractions of Number. ">IntFraction</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IntFraction.html#aafccd523414a7c7ae8d2a4081bbc76a8">csl::IntFraction</a>, and <a class="el" href="classcsl_1_1Arbitrary.html#a0e1f9042536b8ec8f361e7fd556b58d4">csl::Arbitrary</a>.</p>

</div>
</div>
<a id="aad25c117c8dfc4d9718ba41e8d3f33a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad25c117c8dfc4d9718ba41e8d3f33a6">&#9670;&nbsp;</a></span>getNumericalFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getNumericalFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the numerical factor of the expression, i.e. returns <b>C</b> if the expression if of the form <b>C*x</b> (<b>x</b> having a numerical factor equal to 1), and return 1 else. </p>
<dl class="section note"><dt>Note</dt><dd>This function returns the factor in an Expression (then of Numerical type). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The numerical factor in front of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#aefbb5ef66721e97b90dc1bb82b9e6823">csl::Pow</a>, <a class="el" href="classcsl_1_1Prod.html#a31991415ad6e7e8e5e9b703f9128af39">csl::Prod</a>, <a class="el" href="classcsl_1_1Sum.html#ae5a42358fbbca3043d216049222455d6">csl::Sum</a>, and <a class="el" href="classcsl_1_1AbstractNumerical.html#ac3c2bbe76a12e7e7d08009b82e1fb7c1">csl::AbstractNumerical</a>.</p>

</div>
</div>
<a id="a9c3ec3dfe1fbd8ead5c8d9aca421a863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3ec3dfe1fbd8ead5c8d9aca421a863">&#9670;&nbsp;</a></span>getOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getOperand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operand of an <a class="el" href="classcsl_1_1Operator.html" title="Linear operator O(a*X+b*Y) = a*O(X) + b*O(Y) ">Operator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><b>operand</b> of an <a class="el" href="classcsl_1_1Operator.html" title="Linear operator O(a*X+b*Y) = a*O(X) + b*O(Y) ">Operator</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Integral.html#a304552a9becfb10cb337210117de575c">csl::Integral</a>, <a class="el" href="classcsl_1_1Derivative.html#a08574b1aa7967ca4f6b98f4ed9534bc0">csl::Derivative</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#aba17709ddc3ea5ae260a6b713a032355">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractIntegral.html#a0e22ef62f91cf61f7d3067d7ae4af007">csl::AbstractIntegral</a>, <a class="el" href="classcsl_1_1ImaginaryPart.html#abaabfff6c5bbda6ce39627bf632d380d">csl::ImaginaryPart</a>, and <a class="el" href="classcsl_1_1RealPart.html#a10e389ad0a81beffe8c0a134f4f48847">csl::RealPart</a>.</p>

</div>
</div>
<a id="a9500a21d75d03c695ec0c76493600b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9500a21d75d03c695ec0c76493600b38">&#9670;&nbsp;</a></span>getOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::getOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the order (integer) that defines certain types of expressions. </p>
<dl class="section return"><dt>Returns</dt><dd><b>order</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Derivative.html#a8debf6f0fe771b1c0fa0280faf0f3283">csl::Derivative</a>, and <a class="el" href="classcsl_1_1Polynomial.html#acdfc0c1919d2b4989019e53a80c89f33">csl::Polynomial</a>.</p>

</div>
</div>
<a id="ab150130c9f67daaf6aba52b9f6b90941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab150130c9f67daaf6aba52b9f6b90941">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Parent.html">Parent</a> csl::Abstract::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For indicial expressions this function returns a pointer to the parent object of type <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> (not an expression). </p>
<dl class="section return"><dt>Returns</dt><dd><b>parent</b> for TensorElement-type expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1VectorIntegral.html#a956aaa1428471ce72c9c273cd5ce4ac8">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1Variable.html#a3eea13fd67db0b8f0b5accea6adefb21">csl::Variable</a>, <a class="el" href="classcsl_1_1Constant.html#af7a592da98893ac5bfc3b145ace1fa01">csl::Constant</a>, and <a class="el" href="classcsl_1_1AbstractElement.html#a9e50d48ea0ee472c5c07f3985cc6c641">csl::AbstractElement</a>.</p>

</div>
</div>
<a id="aea8459b3206eb3a2297eeea7688e9520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8459b3206eb3a2297eeea7688e9520">&#9670;&nbsp;</a></span>getParity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::getParity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>t_variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parity property of the expression with respect to <b>t_variable</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_variable.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the expression is <b>even</b> in <b>t_variable</b>. </dd>
<dd>
-1 if the expression is <b>odd</b> in <b>t_variable</b>. </dd>
<dd>
0 else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1DiracDelta.html#a7a0264b21f4abad295c61e89ead32b88">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Factorial.html#a687d7064e35ad99d4981e940c509440d">csl::Factorial</a>, <a class="el" href="classcsl_1_1ATanh.html#afb2c14500cc281ef0a642294bda73e99">csl::ATanh</a>, <a class="el" href="classcsl_1_1ASinh.html#a22a4862646c4cbaffcff45a8876c0648">csl::ASinh</a>, <a class="el" href="classcsl_1_1ACosh.html#a2dcbe0e8c6fc07d7d4ca3b02c24ced42">csl::ACosh</a>, <a class="el" href="classcsl_1_1Tanh.html#a33d8c0c83c0e2c9500448ceba8b61428">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#a32616979f93899f873439e54c65ab376">csl::Sinh</a>, <a class="el" href="classcsl_1_1Cosh.html#a1ad8069e9a1236eb00551780684b1240">csl::Cosh</a>, <a class="el" href="classcsl_1_1Angle.html#a1c2c4dff4cecb505f6d9ce05701dfde0">csl::Angle</a>, <a class="el" href="classcsl_1_1Integral.html#a75d07b7ec8e8ede6c9c15157e6a4b47f">csl::Integral</a>, <a class="el" href="classcsl_1_1ATan.html#abce45fbcda74eb7acf909c5c711176c0">csl::ATan</a>, <a class="el" href="classcsl_1_1Derivative.html#a7d906b1b3929000ec0a6100bb5957697">csl::Derivative</a>, <a class="el" href="classcsl_1_1ASin.html#a142897732f1f6c347bc4e65c344bbb27">csl::ASin</a>, <a class="el" href="classcsl_1_1Pow.html#af0de63b31d13243da82cea81cdda9c39">csl::Pow</a>, <a class="el" href="classcsl_1_1ACos.html#a95a6076fdc3cae921b5cde90a835e74e">csl::ACos</a>, <a class="el" href="classcsl_1_1Tan.html#a888df766c47e82b50a9e2bd72192cbbb">csl::Tan</a>, <a class="el" href="classcsl_1_1Prod.html#a68dff5c0b393ad75f5e7e0ac97d229dc">csl::Prod</a>, <a class="el" href="classcsl_1_1Sin.html#a51c0924da089969435b2fb45118e9a52">csl::Sin</a>, <a class="el" href="classcsl_1_1Cos.html#a8a840d5af4c79bf20430b144ee0da9b1">csl::Cos</a>, <a class="el" href="classcsl_1_1Variable.html#a12415e4c7a0296803e0b4fb6a174ac4b">csl::Variable</a>, <a class="el" href="classcsl_1_1Log.html#a53b05a1dd7c973da172358bb673e4549">csl::Log</a>, <a class="el" href="classcsl_1_1Polynomial.html#abba6b5b6abd6d86b1aa3f51ebd34201d">csl::Polynomial</a>, <a class="el" href="classcsl_1_1Exp.html#a074d3618469cd4ab010d6c48c47f4976">csl::Exp</a>, <a class="el" href="classcsl_1_1Constant.html#a969cc1cbf65be1a69d2693911b3c4617">csl::Constant</a>, <a class="el" href="classcsl_1_1Sum.html#abd3105d37243fd781e0b2da2de60c295">csl::Sum</a>, <a class="el" href="classcsl_1_1Commutator.html#ad15cf75bcb8e00335ac9f8fd36f1b048">csl::Commutator</a>, and <a class="el" href="classcsl_1_1Abs.html#a3b735634cb0181f048b6fd23dea5a614">csl::Abs</a>.</p>

</div>
</div>
<a id="a946d175d946da102c5f4cc91840703cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946d175d946da102c5f4cc91840703cb">&#9670;&nbsp;</a></span>getPermutations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::Abstract::getPermutations </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::vector of all possible permutations of an <b>Indicial</b> expression. The possible permutations are determined from the posible symmetries and anti-symmetries of the object. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector containing all possible permutations of the tensor. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#aa0f1ab4f63aa28f3c759a666fb15636a">csl::TensorElement</a>.</p>

</div>
</div>
<a id="ade540a127da7304f2b7282f4dcaffc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade540a127da7304f2b7282f4dcaffc7f">&#9670;&nbsp;</a></span>getPolynomialTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::getPolynomialTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>t_variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the polynomial term corresponding to <b>*this</b> with the variable <b>t_variable</b> at order <b>order</b>. In particular, this function assumes that the checks have already been made with the function <a class="el" href="classcsl_1_1Abstract.html#acae10d5685ccec295fbd9be7996073cb" title="Determines if the expression is a mononomial term in expr, i.e. a term of the form C*expr^n with C in...">isPolynomial()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_variable</td><td><a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a> of the polynomial.  Order of <b>*this</b> in <b>t_variable</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same expression as (*this) with the term <b>t_variable^order</b> removed. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#a295d149cfcfa20527b12f3bc57e95811">csl::Pow</a>, <a class="el" href="classcsl_1_1Prod.html#ab552c778033130c31c476b2e1939e84e">csl::Prod</a>, <a class="el" href="classcsl_1_1AbstractElement.html#a028ecff66278c1e385280b761388b929">csl::AbstractElement</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a05d8a8cf5ba9ae9563c09b65bac10c2f">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a8ab79682cdff4c7d7b52c2e70ac23d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab79682cdff4c7d7b52c2e70ac23d85">&#9670;&nbsp;</a></span>getPrimaryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a> csl::Abstract::getPrimaryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>primary</b> <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (single number, scalar function with one argument, with multiple argumments, a <a class="el" href="classcsl_1_1Vector.html">Vector</a>, etc) in order to do special treatments or simplifications. </p><dl class="section return"><dt>Returns</dt><dd>type (a non memorized integer corresponding to the type of abstract) </dd></dl>

<p>Implemented in <a class="el" href="classcsl_1_1TensorElement.html#a1c246057031fbc18868bac66d13be37c">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Imaginary.html#a45d77fd51e45fade354f8ec14c303ef7">csl::Imaginary</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a1b6044133a95c411324d20afe460c55b">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1IntFactorial.html#a04137e9d1e68e26f6313264aad3504e5">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#abafb2415e1952440db4b16c6138d6313">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Variable.html#a1b67145a27e8b33488f3243a97ce2064">csl::Variable</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#aab050fd18460d4842d8972a990363b0c">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1Constant.html#a81c9c1235cc4b7a3d799a3581cbda675">csl::Constant</a>, <a class="el" href="classcsl_1_1AbstractField.html#a1889fe8e95ded9ee224fb11ce6ec3900">csl::AbstractField</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#afb6d645d2f0673a500eaf294ff822269">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1Arbitrary.html#a489b4b7b94c0880c843db0e4cfc249d4">csl::Arbitrary</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a18df1a5dbd7c9c75b1704fe958a55a5d">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1AbstractLiteral.html#aa41c4506afb800db5eca9232df00720a">csl::AbstractLiteral</a>, and <a class="el" href="classcsl_1_1AbstractNumerical.html#ab546a5a971f3547b7bbf2940465d70e9">csl::AbstractNumerical</a>.</p>

</div>
</div>
<a id="a07489d0569bc983718796d21c73f34b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07489d0569bc983718796d21c73f34b3">&#9670;&nbsp;</a></span>getProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getProduct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the product of all elements in the <b>Vectorial</b> object. </p>
<dl class="section return"><dt>Returns</dt><dd>The product of all elements. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a6f4f1f7c516ee3daceaf5044a40c04d1">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="aca85809fef9dddefa5f9e06c3b25215d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca85809fef9dddefa5f9e06c3b25215d">&#9670;&nbsp;</a></span>getProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="classcsl_1_1Equation.html">Equation</a> * &gt; &amp; csl::Abstract::getProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The properties of the object. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a8ab3f38235ce39d3d2f1361eba25fb3e">csl::TensorElement</a>, and <a class="el" href="classcsl_1_1AbstractLiteral.html#a5cb95b0a7a194bf185848831b6ebe09a">csl::AbstractLiteral</a>.</p>

</div>
</div>
<a id="a415f64fdddaae445014d5e052956f889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415f64fdddaae445014d5e052956f889">&#9670;&nbsp;</a></span>getRealPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::getRealPart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Evaluates</b> the <b>real part</b> of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>The real part of the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1DiracDelta.html#af86344bc4071f901591cc1b50b915257">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Tanh.html#a64eca21f5e81ff0a85e9d2bbd919edcd">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#a5888952203e8271368e1aa19681afac4">csl::Sinh</a>, <a class="el" href="classcsl_1_1Cosh.html#a3d88db8dd64a46ef1cc70b1a0d19bca3">csl::Cosh</a>, <a class="el" href="classcsl_1_1ASin.html#ac0f8218b321a2294612e25d3e57c2318">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#a16301f8ed54cac63ac5389fc179f24d6">csl::ACos</a>, <a class="el" href="classcsl_1_1Tan.html#a89fd2f3ff51edc27812a0440189da5cc">csl::Tan</a>, <a class="el" href="classcsl_1_1Complex.html#a0a71859b7fdc28a6cd36290823282746">csl::Complex</a>, <a class="el" href="classcsl_1_1Imaginary.html#a3f78df436661ecce2ebfdd97324435c7">csl::Imaginary</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a4740c75c01e1d8aeb7db075fc5377789">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Sin.html#a35ffd397f83edf315fd120c96f44063a">csl::Sin</a>, <a class="el" href="classcsl_1_1Prod.html#a74b08ed837b9be3299e99b5b355cb4d4">csl::Prod</a>, <a class="el" href="classcsl_1_1Cos.html#addc14896700e9950baee3374a09b558d">csl::Cos</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#abccb4ba9f313edd3a3939c317afbc14e">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Log.html#ab37426baaea4c8e148ee683b488d0fb2">csl::Log</a>, <a class="el" href="classcsl_1_1Exp.html#a3e803100efb959d15e40b0e69aa9a369">csl::Exp</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#ab99d86f5bed81171962f0cf99415bfba">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#ab1d0e4f2b4d063838158829972c2160a">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1Sum.html#a340d0daf8560d7d9ec73a30a0e5b4fce">csl::Sum</a>, <a class="el" href="classcsl_1_1Complexified.html#a5de9b50162c5af5177a928e855e6b71b">csl::Complexified</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#acd32aa346383a68ef69a48b56669deff">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a5b77f008f4b95030641224877004f06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b77f008f4b95030641224877004f06c">&#9670;&nbsp;</a></span>getRegularExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getRegularExpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a regular expression from the polynomial, that is a sum where the different powers of the variable appear explicitely. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classcsl_1_1Sum.html" title="Handles a sum, function of multiple arguments. ">Sum</a> expression equal to the polynomial. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Polynomial.html#a6bc25a8b8e8da0cebdead8cc869e2134">csl::Polynomial</a>.</p>

</div>
</div>
<a id="a625efe55a17b97a1c0f085bdbf3a962a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625efe55a17b97a1c0f085bdbf3a962a">&#9670;&nbsp;</a></span>getShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; csl::Abstract::getShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the shape of the tensor in the form of a std::vector of integers. </p>
<dl class="section return"><dt>Returns</dt><dd><b>shape</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a8cee385d5b699162c8a400e4b44ed7d7">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="aa83df1d9dc202457113e5b38bd694fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83df1d9dc202457113e5b38bd694fae">&#9670;&nbsp;</a></span>getSign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::getSign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The <b>sign</b> for a <a class="el" href="classcsl_1_1Commutator.html" title="Object that represents a commutator or an anti-commutator, thus is derived from AbstractDuoFunc that ...">Commutator</a> type expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Commutator.html#abac8376052445d0359e4919f781f185d">csl::Commutator</a>.</p>

</div>
</div>
<a id="a7dcdc11b64c8c515933882168d0792ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcdc11b64c8c515933882168d0792ef">&#9670;&nbsp;</a></span>getSubVectorial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getSubVectorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iExcept</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iExcept</td><td>Element to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of *this excluding iExcept. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Vector.html#a8a948bfe3dad300352a8bde32679cb82">csl::Vector</a>.</p>

</div>
</div>
<a id="a413c50b2663f57d38c1d3ec3cfeaa3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413c50b2663f57d38c1d3ec3cfeaa3ce">&#9670;&nbsp;</a></span>getSubVectorial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getSubVectorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iExcept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jExcept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to pick a part of a Vectorial expression, excluding the [iExcept^{th},jExcept^{th}] element (useful for matrices). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iExcept</td><td>Element of the first axis to ignore. </td></tr>
    <tr><td class="paramname">jExcept</td><td>Element of the second axis to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of *this excluding iExcept. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Matrix.html#a1304350a5c07d93607309144d7a58b9f">csl::Matrix</a>.</p>

</div>
</div>
<a id="a0f88bae88e30b37cc3a4d4c7a476a992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f88bae88e30b37cc3a4d4c7a476a992">&#9670;&nbsp;</a></span>getSubVectorial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getSubVectorial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>exceptions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to pick a part of a Vectorial expression, excluding the iExcept^{th} element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iExcept</td><td>Element to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of *this excluding iExcept. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a002b8834bc010144ab0666c6697a5d7b">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="aeaf8154e39ff211b12e6382e675ccaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf8154e39ff211b12e6382e675ccaad">&#9670;&nbsp;</a></span>getSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getSum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the sum of all elements in the <b>Vectorial</b> object. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#aa9d43ea7296950633aa2ac848173cb51">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a1d36e7a5acc50766d5cd3f6d59df978d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d36e7a5acc50766d5cd3f6d59df978d">&#9670;&nbsp;</a></span>getTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::getTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the same expression as *this but amputated of its numerical factor. Example: (4*cos(x) -&gt; cos(x)). </p>
<dl class="section return"><dt>Returns</dt><dd>The term without numerical factor corresponding to <b>*this</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#a71c50f5ed80151b5d75afe6e14164d78">csl::Pow</a>, <a class="el" href="classcsl_1_1Prod.html#a428ffb91c3529b4835d6bfa6289765d8">csl::Prod</a>, <a class="el" href="classcsl_1_1Sum.html#aa265b9928bffd0aefe456d9dbe3637b8">csl::Sum</a>, <a class="el" href="classcsl_1_1AbstractNumerical.html#a092aae72532fd13bcc79392bd18ebfad">csl::AbstractNumerical</a>, and <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#a58c627e31c2a42adec4caf39030123aa">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="aa781456c3f801b37ce169c83514c51c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa781456c3f801b37ce169c83514c51c1">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a> csl::Abstract::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <b>type</b> of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<p>In the program this function is very often called. It allows different functions to know what type of expr they are manipulating (cos, product, number, etc) in order to do special treatments or simplifications. </p><dl class="section return"><dt>Returns</dt><dd>type (a non memorized integer corresponding to the type of abstract) </dd></dl>

<p>Implemented in <a class="el" href="classcsl_1_1DiracDelta.html#afde4d766b81d980647c55bda65ed519a">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Factorial.html#ac31a3e15b4bf0d7604bbdadd2080cc7f">csl::Factorial</a>, <a class="el" href="classcsl_1_1ATanh.html#adb3c6afec3dde358d4afc272fe3e6177">csl::ATanh</a>, <a class="el" href="classcsl_1_1ASinh.html#a8864eabb24d35309797271892591a61f">csl::ASinh</a>, <a class="el" href="classcsl_1_1ACosh.html#a1cd22dc7959d90a17fa747c05f1ac70a">csl::ACosh</a>, <a class="el" href="classcsl_1_1Tanh.html#a4a30d37ea900d3ce7ac37016bf669bd8">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#a482b3aa41cdfda7b21a08914963e9ea4">csl::Sinh</a>, <a class="el" href="classcsl_1_1Cosh.html#a49c09e3519a2307ef7c8713c643249ef">csl::Cosh</a>, <a class="el" href="classcsl_1_1TensorElement.html#a7b99f83fdff13fb508ea8e671d4dc834">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Angle.html#a2a0a138a9196c8c5f195a822f7a8a982">csl::Angle</a>, <a class="el" href="classcsl_1_1Integral.html#af4eedf08f912f9fbb576a01778eecaea">csl::Integral</a>, <a class="el" href="classcsl_1_1ATan.html#aef622a35036fcdd32527b881dc14e559">csl::ATan</a>, <a class="el" href="classcsl_1_1Derivative.html#afede83f7ca9724579f293d4289857d00">csl::Derivative</a>, <a class="el" href="classcsl_1_1ASin.html#aff7945ce6a7782ffc619ebcef75ef15f">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#a6533f24c81b914bd04f440e19cbb3a16">csl::ACos</a>, <a class="el" href="classcsl_1_1Pow.html#a8d7c1cdb87061dd7aa472ed9fe344a8b">csl::Pow</a>, <a class="el" href="classcsl_1_1Tan.html#a13e3eefa59b9a66427401b7a9693cb55">csl::Tan</a>, <a class="el" href="classcsl_1_1Imaginary.html#add1fe835290daf5c85d3850931351fef">csl::Imaginary</a>, <a class="el" href="classcsl_1_1Complex.html#ab203dc18378296c2b7d484773bec8746">csl::Complex</a>, <a class="el" href="classcsl_1_1Sin.html#a9f090098e2afc33ef5ce79391a207164">csl::Sin</a>, <a class="el" href="classcsl_1_1IntFactorial.html#ac9dab3ccc2491163dec9d020078fb281">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a77d642a8a42845ad66da5faa78cb3c27">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Prod.html#af0bd5312033ca6006d54e117503cc52b">csl::Prod</a>, <a class="el" href="classcsl_1_1HighDTensor.html#a0434d931a5d7533c32b7b4dc359c24e1">csl::HighDTensor</a>, <a class="el" href="classcsl_1_1Cos.html#a1fb5b606bba498a4ae74ea3ea6f669a3">csl::Cos</a>, <a class="el" href="classcsl_1_1IntFraction.html#abebe0ae65269c3fdddc7759008cc488d">csl::IntFraction</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a16ff4a3a49daf68786abbe407d1d5b8c">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1VectorIntegral.html#a514f7d0f5a9cff6c43d786717a030ad7">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1Matrix.html#ad51abe5758a67621ef124901192dd7a2">csl::Matrix</a>, <a class="el" href="classcsl_1_1Log.html#a87bd2f7fce0e7a74fdfcbd438553d4c7">csl::Log</a>, <a class="el" href="classcsl_1_1Polynomial.html#aaba60af7af69c8f95c2a52c9f3669cdd">csl::Polynomial</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a96910b875bda50dd7111e0f03477e36d">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Variable.html#acbc90bf0cbc0c78553b26fbfa7eb207a">csl::Variable</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#ab78b88ff1b49707ee98aee3211214044">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1Vector.html#a2b3aef310427653b07c7963a606faca8">csl::Vector</a>, <a class="el" href="classcsl_1_1Float.html#a23bf3dff3c0506d854366653bb9a177d">csl::Float</a>, <a class="el" href="classcsl_1_1ScalarIntegral.html#af090ec91b6cf2512df62e86d9b7b032a">csl::ScalarIntegral</a>, <a class="el" href="classcsl_1_1Exp.html#a6e36f13b9963e395c6d9ce5f58fbbaa1">csl::Exp</a>, <a class="el" href="classcsl_1_1ScalarField.html#adaab43729495323a7e41e415f0741b0e">csl::ScalarField</a>, <a class="el" href="classcsl_1_1Commutator.html#adac744ad959f7f67f5274f6725efd2b6">csl::Commutator</a>, <a class="el" href="classcsl_1_1Constant.html#afa00a556bebd39436c680106e79e5d96">csl::Constant</a>, <a class="el" href="classcsl_1_1Integer.html#a93751bbb2c3673de15a6a4f7f6f138ff">csl::Integer</a>, <a class="el" href="classcsl_1_1ImaginaryPart.html#a4644adb36c50f172991f587ab0eef89e">csl::ImaginaryPart</a>, <a class="el" href="classcsl_1_1Arbitrary.html#ad803441e87d253727977a2731de05e3e">csl::Arbitrary</a>, <a class="el" href="classcsl_1_1NumericalEval.html#ab3489982397c48397060bf0cf9bd9dd9">csl::NumericalEval</a>, <a class="el" href="classcsl_1_1Sum.html#afdde4c81bf81217accd1b02b8e2b4dbf">csl::Sum</a>, <a class="el" href="classcsl_1_1Abs.html#aec650f01292bf5d1381d587e489a4810">csl::Abs</a>, <a class="el" href="classcsl_1_1RealPart.html#a10f26df41d893a03dd72b734469b7bf3">csl::RealPart</a>, and <a class="el" href="classcsl_1_1Scalar.html#a9af394275ef7969c8cabc31417fa235d">csl::Scalar</a>.</p>

</div>
</div>
<a id="a78f98ba06476e464e3fd2fce0d1f8243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f98ba06476e464e3fd2fce0d1f8243">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double csl::Abstract::getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the expression, if it has one <b>explicitely</b>. In particular, it will work only on Numbers and valued Literals, not on functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IntFactorial.html#a579d7c365479e561e598195e10da65f9">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1Variable.html#aed2e30529caec691269a11608b678e41">csl::Variable</a>, <a class="el" href="classcsl_1_1Constant.html#a96386d249c7171141d18c9b48cfa5a33">csl::Constant</a>, and <a class="el" href="classcsl_1_1NumericalEval.html#a9d8cd636438262d7f35576afb9e7621a">csl::NumericalEval</a>.</p>

</div>
</div>
<a id="a628563238145f3a9acc331f1a89ce32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628563238145f3a9acc331f1a89ce32f">&#9670;&nbsp;</a></span>getValued()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::getValued </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the expression is valued, i.e. is a function of numbers and valued literals (a <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a> or <a class="el" href="classcsl_1_1Constant.html" title="Handle an object with a name and a value. ">Constant</a> is not valued by default). </p>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is valued. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Variable.html#ad0ba237abda5d2a01a50a36a5daf6248">csl::Variable</a>, and <a class="el" href="classcsl_1_1Constant.html#a8e05cf80cbeffe60e0e09bc9d15001bd">csl::Constant</a>.</p>

</div>
</div>
<a id="ae85f810bbadbc792210c958e8f1b2ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85f810bbadbc792210c958e8f1b2ffb">&#9670;&nbsp;</a></span>getVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the variable that defines certain types of expressions. </p>
<dl class="section return"><dt>Returns</dt><dd><b>variable</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Integral.html#a0a44c0ebf7c356c5ee7ac288b471edb9">csl::Integral</a>, <a class="el" href="classcsl_1_1Derivative.html#a257f22195ee64163e7ff5ee99b6ecdc1">csl::Derivative</a>, <a class="el" href="classcsl_1_1VectorIntegral.html#a0bdc27a5f2a2533af9aaf96f4582ed07">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1Polynomial.html#ad633f5e1ef2f0d4984bb268b65ebafec">csl::Polynomial</a>, and <a class="el" href="classcsl_1_1ScalarIntegral.html#a330a8f285ec3b13b75cd444d88f1fd67">csl::ScalarIntegral</a>.</p>

</div>
</div>
<a id="ac83c44ae1e5315a38083bdb7acd8f3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83c44ae1e5315a38083bdb7acd8f3fa">&#9670;&nbsp;</a></span>getVectorArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const csl::vector_expr &amp; csl::Abstract::getVectorArgument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to get the entire std::vector of arguments of the expression. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must not be called for building blocks, one must check first that the expression has arguments. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The std::vector of argument. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a5e910beb3bdf8459306fe0cda78c1c76">csl::AbstractMultiFunc</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#ad91b47a309a8fc9c5ed9e4b827d84155">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a0188b049736016c970a2513ed9f6931f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0188b049736016c970a2513ed9f6931f">&#9670;&nbsp;</a></span>getVectorialModulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::getVectorialModulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Vectorial modulus of the <b>Vectorial</b> object, that is defined here as the squared root of the sum of element squared. Example: {A_{11}^2+A_{12}^2+}. </p>
<dl class="section return"><dt>Returns</dt><dd>The vectorial modulus of the expression. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a8f4326ec0f618785cf0e9d84b448cdd6">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="aa31e08c251d96b8ea8ec8d385895c1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31e08c251d96b8ea8ec8d385895c1ff">&#9670;&nbsp;</a></span>hasContractionProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::hasContractionProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells (for an Indicial type) if there is a special contraction property with <b>B</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>Expression with which we test if there is a special contraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if there is a contraction. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a511992d33dc54c1fb8d0c4c17afa5f8c">csl::TensorElement</a>.</p>

</div>
</div>
<a id="a5437e7f685edf8549e6d3b34572343f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5437e7f685edf8549e6d3b34572343f8">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>side</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an expression in a sum or a product. </p>
<p>Allows to insert an element in a sum or product without comparing all existing terms. This saves time when inserting element by element. The <b>side</b> parameter allows to insert to the left (side = 0) or to the right (side = 1) in products (useful when considering non commutating expressions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to insert. </td></tr>
    <tr><td class="paramname">side</td><td>Side of insertion for <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a> expressions. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Prod.html#ae065e3860edfd408a1cdef2bfb259b2e">csl::Prod</a>, and <a class="el" href="classcsl_1_1Sum.html#a8967f1bfbae1e49e21bd5f79939b2a63">csl::Sum</a>.</p>

</div>
</div>
<a id="a1b68943aa7ecf60a63af0f2f368eef8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b68943aa7ecf60a63af0f2f368eef8f">&#9670;&nbsp;</a></span>inverseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::inverseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the inverse of a 2D square matrix. The applied method is: A^{-1} = 1/det(A)*Com(A)^T. </p>
<dl class="section return"><dt>Returns</dt><dd>A^{-1} for a matrix (2D) A if det(A) != 0. </dd>
<dd>
0 else </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Matrix.html#accd49f13248f58c2d65edda3bd6d626e">csl::Matrix</a>.</p>

</div>
</div>
<a id="a9347e75b0cd0b75e0f0a38db93b29d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9347e75b0cd0b75e0f0a38db93b29d83">&#9670;&nbsp;</a></span>isAnOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::isAnOperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the expression is an operator (like a derivetive operator). </p>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is an <a class="el" href="classcsl_1_1Operator.html" title="Linear operator O(a*X+b*Y) = a*O(X) + b*O(Y) ">Operator</a>. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="ad74c068f1da78856321932b6b6ae17dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74c068f1da78856321932b6b6ae17dc">&#9670;&nbsp;</a></span>isBuildingBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::isBuildingBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the expression is a Building Block or not. </p>
<p>Building blocks are derived classes that cannot contain further expressions, i.e. expressions that are the leafs of the recursive tree reprensent mathematical expressions: numerical or pure literal objects (variable, constant etc). </p><dl class="section return"><dt>Returns</dt><dd><b>True</b> if <em>*this</em> is a Building Block. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractBuildingBlock.html#aee083330a4490359012cf0e656758a44">csl::AbstractBuildingBlock</a>.</p>

</div>
</div>
<a id="a464f4f0613db9b4b0a4efe26a3a03d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464f4f0613db9b4b0a4efe26a3a03d60">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells for a <a class="el" href="classcsl_1_1Derivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or an <a class="el" href="classcsl_1_1Integral.html">Integral</a> if the argument is empty i.e. if the object must apply on the next argument encountered on the right. </p>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the <a class="el" href="classcsl_1_1Derivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> or <a class="el" href="classcsl_1_1Integral.html">Integral</a> awaits an argument. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a216b7bd3930fbf047e5bf8f69e9b964c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216b7bd3930fbf047e5bf8f69e9b964c">&#9670;&nbsp;</a></span>isIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::isIndexed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is indexed. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IProd.html#a046bd2f7ea7fb90fdf1dadad1a69af64">csl::IProd</a>, <a class="el" href="classcsl_1_1ISum.html#a1b7f9344411c6dbf4e132798833c6a68">csl::ISum</a>, <a class="el" href="classcsl_1_1TensorElement.html#acc36470e69d6edf43f6dd7b6db0365d2">csl::TensorElement</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#aee96fe96e6cf30e1022ee8f489884aa5">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Prod.html#acb1ea1810e83874623d07f370efde5c2">csl::Prod</a>, <a class="el" href="classcsl_1_1VectorIntegral.html#ab3961d7313002bd6e4d0c342bd2cd9a1">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a3c528c48d0b95db2e506f1d6959c5e67">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1Polynomial.html#a83502630a7e4016e818c2f8332a68594">csl::Polynomial</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#a9bc54de57d7301838f673c014ed9d79f">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a25e37d9d40927ef216a5b10958fa83ba">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1Sum.html#ad9ce7a5183d105402cdafab290b93c91">csl::Sum</a>, and <a class="el" href="classcsl_1_1Scalar.html#a158c8d90a3055c33e2b759c419cf2291">csl::Scalar</a>.</p>

</div>
</div>
<a id="a9a014bfd266b5f8471f23580e271979b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a014bfd266b5f8471f23580e271979b">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::isInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if the expression is an integer. Either an <a class="el" href="classcsl_1_1Integer.html" title="Handle numbers in expr. ">Integer</a> object directly, or a <a class="el" href="classcsl_1_1Float.html" title="Handle numbers in expr. ">Float</a> that has an integer value. </p>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <em>*this</em> is an <a class="el" href="classcsl_1_1Integer.html" title="Handle numbers in expr. ">Integer</a> or a <a class="el" href="classcsl_1_1Float.html" title="Handle numbers in expr. ">Float</a> with integer value. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Float.html#a2588061b9db6b5af2253bc181b859ef8">csl::Float</a>, and <a class="el" href="classcsl_1_1Integer.html#ac5571ab9be29c389391e69d8794b93a8">csl::Integer</a>.</p>

</div>
</div>
<a id="acae10d5685ccec295fbd9be7996073cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae10d5685ccec295fbd9be7996073cb">&#9670;&nbsp;</a></span>isPolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::isPolynomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the expression is a mononomial term in <b>expr</b>, i.e. a term of the form C*expr^n with C independent of expr, n integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a> of the supposed mononomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The order of the exponent if there is one (n in the example). </dd>
<dd>
-1 else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#a52d9ee469cf861e08a58588ce3edf1c4">csl::Pow</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a8014e107c584b6450d3cc1ce78e154ca">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1Prod.html#ad52e8f95508d38377324e9ef8fb4c28d">csl::Prod</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a424f5c3e08f3548d1be123b599eaac2f">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a699c366fc3c292e8a70941e1c4ee5b0c">csl::AbstractFunc</a>, and <a class="el" href="classcsl_1_1AbstractElement.html#a9f3e30eeaace6c5c21cda6895daa2de9">csl::AbstractElement</a>.</p>

</div>
</div>
<a id="ab79c1d8df9e6b1a3eca66958f7dc489d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79c1d8df9e6b1a3eca66958f7dc489d">&#9670;&nbsp;</a></span>matchShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::matchShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In the case of a vectorial-type expression, this function checks if the shape of expr matches itself. </p>
<p>If <b>exact</b> is true, the function search an exact match i.e. either the two shapes are exactly equal or one of the two objects is a scalar. If <b>exact</b> is false, this function only search for a possible dot product between the two expressions, and see if the last axis of <b>*this</b> matches the first of <b>expr</b> (or if one of the two objects is scalar also). Then, a product  _k (*this)[i,j,...,k]*expr[k,l,m,...] is possible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression of which we compare the shape. </td></tr>
    <tr><td class="paramname">exact</td><td>Boolean than specifies if we need an exact match or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two shapes correspond. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#ab24d4b6eae7dbe9783aabf2bfcb7a224">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a4f5ed458ba62f5b4cf61a9e1f8568af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5ed458ba62f5b4cf61a9e1f8568af1">&#9670;&nbsp;</a></span>multiplication_own()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::multiplication_own </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>side</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains implementation of special multiplication for Numerical- and Vectorial-types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Right operrand of the product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two operands. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Complex.html#a79889fc60628f60564ed7a60b1fad1a3">csl::Complex</a>, <a class="el" href="classcsl_1_1IntFraction.html#a084df9668bd846370585d44ba07d75a0">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Polynomial.html#a83e31e00d46a46aaed0789dfc8170a11">csl::Polynomial</a>, <a class="el" href="classcsl_1_1Float.html#a0acfdd639afdbbb6f904a2cd74aaac31">csl::Float</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a81eebf482c8b342b75aaec063533790c">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1Integer.html#a69ec91334a0491aadfebc431d2174343">csl::Integer</a>, and <a class="el" href="classcsl_1_1NumericalEval.html#a647a0c6ac0967d08b8d657d2a6d946cb">csl::NumericalEval</a>.</p>

</div>
</div>
<a id="af5b62a6308638064c42da80e9cc2cb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b62a6308638064c42da80e9cc2cb7e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator!= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if the expression is valued and is equal to t_value. </dd>
<dd>
<b>True</b> else. </dd></dl>

</div>
</div>
<a id="af4fd1b57df371dac7ccfd5a909620e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fd1b57df371dac7ccfd5a909620e49">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator!= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if the expression is valued and is equal to t_value. </dd>
<dd>
<b>True</b> else. </dd></dl>

</div>
</div>
<a id="ac99a619abde7e4c58f39e14d4d20fcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99a619abde7e4c58f39e14d4d20fcf5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two Abstracts are the same (or have the same name). </dd>
<dd>
True else. </dd></dl>

</div>
</div>
<a id="a5c1ba8dce7fbc19eb98807bd15a279c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1ba8dce7fbc19eb98807bd15a279c9">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool csl::Abstract::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if <b>expr</b> is simpler or equivalent. </dd>
<dd>
<b>True</b> else. </dd></dl>

<p>Implemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#ad4be44fbde5ebd97065a575992d498c2">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a2d20154a943a0a723791d0a6223382fa">csl::AbstractDuoFunc</a>, and <a class="el" href="classcsl_1_1Scalar.html#a3aa54f5e552065ac95c21e67e4c2cfe3">csl::Scalar</a>.</p>

</div>
</div>
<a id="a6e19587260a07dba65cf2a985e05516b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e19587260a07dba65cf2a985e05516b">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if <b>expr</b> is simpler or equivalent. </dd>
<dd>
<b>True</b> else. </dd></dl>

</div>
</div>
<a id="afbcac6df2fd7ac11f336189cf215124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcac6df2fd7ac11f336189cf215124b">&#9670;&nbsp;</a></span>operator<=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>False</b> if <b>expr</b> is simpler. </dd>
<dd>
<b>True</b> else. </dd></dl>

</div>
</div>
<a id="a59ff2950fc8ca319f87a730450f14545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ff2950fc8ca319f87a730450f14545">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::operator= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to the <a class="el" href="classcsl_1_1Abstract.html#aaf7f0692cb84ca861a5b3b641bea518b" title="Sets the value if there is one (for Numerical and Literal valued). ">setValue()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_value</td><td>The new value of the expression. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IntFraction.html#a0747a5cb5fed3a0f7d5bb9af97e9c698">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Variable.html#abf8caba816e7baa5bcea4961187bd0c6">csl::Variable</a>, <a class="el" href="classcsl_1_1Float.html#a0377863cba883d89532f1a4132880c95">csl::Float</a>, and <a class="el" href="classcsl_1_1Constant.html#a6cef630b0f3804631f60b6ed22bd3ccc">csl::Constant</a>.</p>

</div>
</div>
<a id="a8334e14cd5789168b037d3888ed60edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8334e14cd5789168b037d3888ed60edd">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator== </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is valued and is equal to t_value. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a12d929e34039e817e464abc560bd4a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d929e34039e817e464abc560bd4a9d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator== </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is valued and is equal to t_value. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a3775f3088e784cc924cb7d26e118660e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3775f3088e784cc924cb7d26e118660e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool csl::Abstract::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Compares</b> the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> with another. </p>
<p>Here if two Abstracts have the same name, the function will return <b>true</b> even if they are <b>not</b> <b>mathematically</b> <b>equal</b>. So beware not to name different things the same way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the two Abstracts are the same (or have the same name). </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Implemented in <a class="el" href="classcsl_1_1DiracDelta.html#aa66032c002b1c5d95bb4499093fa19cc">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1IProd.html#af45bd102ad6a062167330ab8715daf78">csl::IProd</a>, <a class="el" href="classcsl_1_1ISum.html#ad11402825b61d8997ce188a9abb30d6b">csl::ISum</a>, <a class="el" href="classcsl_1_1TensorElement.html#a6ada509cc19d2040553f8f40621914db">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Angle.html#a92d43b635f0e38a6c1bc57875cf7341d">csl::Angle</a>, <a class="el" href="classcsl_1_1Integral.html#a4e94f3a5f8d5945d04bc23e3258bc413">csl::Integral</a>, <a class="el" href="classcsl_1_1Derivative.html#a13a0500ee86e1ba0f316d6a4d5f4d1ae">csl::Derivative</a>, <a class="el" href="classcsl_1_1Pow.html#ab241ff256f05031465b1d7c959b4056f">csl::Pow</a>, <a class="el" href="classcsl_1_1Imaginary.html#aa98d68b8591062b56a67452e4d84dd2b">csl::Imaginary</a>, <a class="el" href="classcsl_1_1Complex.html#aa13ebbff936c3fac16bdf2fc9eea1547">csl::Complex</a>, <a class="el" href="classcsl_1_1Prod.html#a1a2c0f67a8aa5798dd9226d721237a8a">csl::Prod</a>, <a class="el" href="classcsl_1_1IntFactorial.html#a0df76f746b29d7025b7917cae22179e7">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a380f7ce153c1b608c232e86f79bdcbd0">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1IntFraction.html#ad0e5efc8234d94656457b21ce95b6946">csl::IntFraction</a>, <a class="el" href="classcsl_1_1Variable.html#abb165be8425c313e0532831604e11d5f">csl::Variable</a>, <a class="el" href="classcsl_1_1VectorIntegral.html#a2e912283405785f512234ada336ca5dd">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1Polynomial.html#a6ee9ab3e7acf085e35349942cb6c9fc2">csl::Polynomial</a>, <a class="el" href="classcsl_1_1Float.html#a76dda7f710c690c2a950d2279c6eae3e">csl::Float</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#af7cde5cfd23cb3b4ca4ddbdbcf717db9">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1ScalarIntegral.html#a86a7f329d187d9abddb819dacf61d5e3">csl::ScalarIntegral</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a45bc5fb9f24b918a685eef9742a4c046">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1AbstractFunc.html#a7ccf43edff01ef8c6500b5117ac42213">csl::AbstractFunc</a>, <a class="el" href="classcsl_1_1Constant.html#a3a9305425d1eeb5c684f9c91b97865ac">csl::Constant</a>, <a class="el" href="classcsl_1_1Sum.html#ae8309f4d05302f47272a5e2ba0e6507c">csl::Sum</a>, <a class="el" href="classcsl_1_1Integer.html#a000e1bcdac9556d30acbd0a3059308cd">csl::Integer</a>, <a class="el" href="classcsl_1_1ScalarField.html#a1d521557312048792795a78b36aa7716">csl::ScalarField</a>, <a class="el" href="classcsl_1_1Commutator.html#ab26b56f71268855477174401069842d1">csl::Commutator</a>, <a class="el" href="classcsl_1_1ImaginaryPart.html#a52a90d231dbb0518eebb65e5f21e24eb">csl::ImaginaryPart</a>, <a class="el" href="classcsl_1_1NumericalEval.html#a71b1d33d6bdddc3dbd31452f326f01ff">csl::NumericalEval</a>, <a class="el" href="classcsl_1_1Complexified.html#a10b02cb2da960264c19926a76a859488">csl::Complexified</a>, <a class="el" href="classcsl_1_1Arbitrary.html#a3bd3172760cb664c0c49475d26079d06">csl::Arbitrary</a>, <a class="el" href="classcsl_1_1RealPart.html#adac617913cdfa2354a085002f443f123">csl::RealPart</a>, and <a class="el" href="classcsl_1_1Scalar.html#a918123c8f35ddf429e6434487a123936">csl::Scalar</a>.</p>

</div>
</div>
<a id="a485c6f3e10db539a70416cd0766b117d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485c6f3e10db539a70416cd0766b117d">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is simpler. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a4c8883df19d7538b68fa96aadac9dfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8883df19d7538b68fa96aadac9dfa9">&#9670;&nbsp;</a></span>operator>=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Abstract::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the simplicity of the expression to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><b>Expression</b> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>expr</b> is simpler or equivalent. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="aa8331053065d1be2da89e70c45d24863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8331053065d1be2da89e70c45d24863">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const  &amp; csl::Abstract::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator for multi-argument expressions, equivalent to the function <a class="el" href="classcsl_1_1Abstract.html#ac33a42309d629d47bfdbede4e152414e">getArgument()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iArg</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> of the argument to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>argument</b>[iArg]. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a26979a899fab4621102645d0f8366457">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a2e9000986cc55b7016cc56513f058f69">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#aaa1bbff7462d592af2ad699c02296107">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a303d252e82b4e28ec9df8a5a971acf52">csl::AbstractVectorial</a>, and <a class="el" href="classcsl_1_1AbstractFunc.html#af3afc58a715c978290e4860101fb3c27">csl::AbstractFunc</a>.</p>

</div>
</div>
<a id="a560aa9993d506551c54a8c02d1445814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560aa9993d506551c54a8c02d1445814">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp; csl::Abstract::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator for multi-argument expressions, returns a reference so this function is not const. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iArg</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> of the argument to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <b>argument</b>[iArg]. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#ae4922013ae4c2b23e6fab8bc9056ab42">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#aa2934b8a3734feac07dec2abc1e14e5a">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#a485adbc87cb3b4739eb468cfd09e7b31">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#afd91a1187f15759c61d5a9460f88d3dc">csl::AbstractVectorial</a>, and <a class="el" href="classcsl_1_1AbstractFunc.html#ab6a82539b4c61521f13b39bf1b230e68">csl::AbstractFunc</a>.</p>

</div>
</div>
<a id="abe9aceabbc0a99642e84c9025dbdc767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9aceabbc0a99642e84c9025dbdc767">&#9670;&nbsp;</a></span>permut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int csl::Abstract::permut </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to permut indices at place <b>i1</b> and <b>i2</b>. If those two indices have a symmetry property, indices are swaped and the symmetry is returned. Else the fnuction does nothing and returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1</td><td>Position of the first index. </td></tr>
    <tr><td class="paramname">i2</td><td>Position of the second index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the permutation **(i1,i2) is symmetric**. </dd>
<dd>
-1 if the permutation **(i1,i2) is anti-symmetric**. </dd>
<dd>
0 else (and do not permut the two indices). </dd></dl>

</div>
</div>
<a id="a9995ebe97bf73c098ee1dc18b7837660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9995ebe97bf73c098ee1dc18b7837660">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void csl::Abstract::print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lib</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays the abstract in standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classcsl_1_1DiracDelta.html#af94ecd827205afbb52baf8e09804d77e">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Factorial.html#a64af7090e03e5ca6a3bfb4caa17e293f">csl::Factorial</a>, <a class="el" href="classcsl_1_1ATanh.html#a1d61d06a886ce91b50efc7032a2c15cf">csl::ATanh</a>, <a class="el" href="classcsl_1_1ASinh.html#ab1d1e181dac86aab9176972f87687968">csl::ASinh</a>, <a class="el" href="classcsl_1_1ACosh.html#ab29b701cebea72034ed5e0955f1fe645">csl::ACosh</a>, <a class="el" href="classcsl_1_1Tanh.html#a4ef6f84e7087d800055cc6cce91fc4c4">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#ad91f8954e8fe6cfaec32f6ce0b7f85d2">csl::Sinh</a>, <a class="el" href="classcsl_1_1TensorElement.html#a94e94f9e6ad8f67fafb25268c64512fa">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Cosh.html#a7ef65dbd90392bfc0cee9ef9e3648420">csl::Cosh</a>, <a class="el" href="classcsl_1_1Angle.html#aa49994f76e8704add77b07fd88299114">csl::Angle</a>, <a class="el" href="classcsl_1_1Integral.html#a670e6d4b8d8a1fa5ac18c3689f1c8063">csl::Integral</a>, <a class="el" href="classcsl_1_1ATan.html#a9c6535ee0a1aff0872fe3451434e6e08">csl::ATan</a>, <a class="el" href="classcsl_1_1Derivative.html#a3209c6131d4c43845c440c9e87dad139">csl::Derivative</a>, <a class="el" href="classcsl_1_1ASin.html#a4c8814708544fe79ec0f5eef90a21100">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#a97b25565af784516778f12d41425df6f">csl::ACos</a>, <a class="el" href="classcsl_1_1Pow.html#a1041778380cd5f11cab240ebe1f0c2c5">csl::Pow</a>, <a class="el" href="classcsl_1_1Tan.html#a92c165a930d21557c88e70a563056ffe">csl::Tan</a>, <a class="el" href="classcsl_1_1Imaginary.html#a58f10fc518606a74b6c9ccc03ee15107">csl::Imaginary</a>, <a class="el" href="classcsl_1_1Complex.html#a9ca8d319ae3d680e5e6a263201aef13a">csl::Complex</a>, <a class="el" href="classcsl_1_1Sin.html#a9cd53e515b5d5dc2b25f4f3b1cb9e4e9">csl::Sin</a>, <a class="el" href="classcsl_1_1Prod.html#a498ed03c404715f0eb453534fd3631bf">csl::Prod</a>, <a class="el" href="classcsl_1_1IntFactorial.html#ac5a73d93f3ba00f9fe39d8830f6005b0">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1Cos.html#aacd0ba99785a8f74b324b2be02273796">csl::Cos</a>, <a class="el" href="classcsl_1_1IntFraction.html#a4686ddae26788c64cb05cf7ea42c5c7c">csl::IntFraction</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#a458a8098137ea92aaa5a8b5f4abd46a7">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1VectorIntegral.html#acce90d1508abeedd8a2ba2e73f021a87">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1Variable.html#ae786baa78518f9866d05bac90e489cfa">csl::Variable</a>, <a class="el" href="classcsl_1_1Log.html#a73dc80010b6b5d7560f97c4cd28d366a">csl::Log</a>, <a class="el" href="classcsl_1_1Polynomial.html#a9ad652da762aca74e4af477369d649d9">csl::Polynomial</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#a3e1469844675af273bdfcc7583e48e55">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1Float.html#ab9425c44005fa5100a307450bc2f6453">csl::Float</a>, <a class="el" href="classcsl_1_1ScalarIntegral.html#a511a5c21c742995d8c232c3bf72e3007">csl::ScalarIntegral</a>, <a class="el" href="classcsl_1_1Exp.html#a58e9bd39c7a38463f6acf71bad61008e">csl::Exp</a>, <a class="el" href="classcsl_1_1Constant.html#aa80722a9278f36b2e79564d7734fae07">csl::Constant</a>, <a class="el" href="classcsl_1_1ScalarField.html#aef4e56ce4d9fbb5b48c853ad492bb7d3">csl::ScalarField</a>, <a class="el" href="classcsl_1_1Integer.html#a05a5612ebd391c5ea2e5504dda29da19">csl::Integer</a>, <a class="el" href="classcsl_1_1Commutator.html#a79c86d72e74c3a71d2ee9479be902cc6">csl::Commutator</a>, <a class="el" href="classcsl_1_1ImaginaryPart.html#ae945afbc9444756a3d4dcbd64fbf265c">csl::ImaginaryPart</a>, <a class="el" href="classcsl_1_1Sum.html#a1ed27fa96664bb2d126e41b866e04a5b">csl::Sum</a>, <a class="el" href="classcsl_1_1Arbitrary.html#ab6dc1ef54886161289ec58a1e8cee3b5">csl::Arbitrary</a>, <a class="el" href="classcsl_1_1NumericalEval.html#a319b1bbb10e2631c307762cc1cbeaa97">csl::NumericalEval</a>, <a class="el" href="classcsl_1_1Abs.html#a841cd69af4907c4bbe1a012793c886ef">csl::Abs</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#ab8d1a1ea8be417dcaffe59a250392695">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1RealPart.html#aab6d9064875ebf4b0f16d4b1b2ba97d5">csl::RealPart</a>, and <a class="el" href="classcsl_1_1Scalar.html#a6075474d28f4cee453110bb8ff68c9e7">csl::Scalar</a>.</p>

</div>
</div>
<a id="a89e45ffc7b65f92e77e592f76f70934c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e45ffc7b65f92e77e592f76f70934c">&#9670;&nbsp;</a></span>printExplicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::printExplicit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays explicitely the expression, with types of each component. This function is only used for debug. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Mode of printing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa067d4a97135bfe2052a7e21c28f75be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa067d4a97135bfe2052a7e21c28f75be">&#9670;&nbsp;</a></span>printLaTeX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string csl::Abstract::printLaTeX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a LaTeX output for the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Tells if the <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> is printed alone (default) or in another expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string corresponding to the LaTeX output. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1DiracDelta.html#aa3b109eb3dc25e8084df99b1f77fada4">csl::DiracDelta</a>, <a class="el" href="classcsl_1_1Factorial.html#a0f94e896bd5032efea33a4faae931980">csl::Factorial</a>, <a class="el" href="classcsl_1_1ATanh.html#adb8ee7249faa4bf5c723e0f8c998ea02">csl::ATanh</a>, <a class="el" href="classcsl_1_1ASinh.html#a470c061e6a77cedcf9f57bd01a53e1dc">csl::ASinh</a>, <a class="el" href="classcsl_1_1ACosh.html#aca6f5306a978ba8589f2757c0599473a">csl::ACosh</a>, <a class="el" href="classcsl_1_1Tanh.html#a9ec76b9e7d1c85e6a20f100a3c1e975f">csl::Tanh</a>, <a class="el" href="classcsl_1_1Sinh.html#a1cfab0be84d64aa34ba65ffdc8303937">csl::Sinh</a>, <a class="el" href="classcsl_1_1TensorElement.html#a5e4794abc02ba5d8f80f76f64e9cab9c">csl::TensorElement</a>, <a class="el" href="classcsl_1_1Cosh.html#a4f968c087cdf5402e49b67ea3ac5bf19">csl::Cosh</a>, <a class="el" href="classcsl_1_1Angle.html#a51993a606446fead779049e3581905f8">csl::Angle</a>, <a class="el" href="classcsl_1_1Integral.html#a6c9ccd94f57b8319977903d7fb0b86e6">csl::Integral</a>, <a class="el" href="classcsl_1_1ATan.html#a851f824336d8fd176d2cc9264bfd8fcf">csl::ATan</a>, <a class="el" href="classcsl_1_1Derivative.html#a8beb96c8fb56648031f7df13194f8eaf">csl::Derivative</a>, <a class="el" href="classcsl_1_1ASin.html#ae9ef3ca87aa148c1bdcdb4d62ae9f2dd">csl::ASin</a>, <a class="el" href="classcsl_1_1ACos.html#acd36159ea83e46fe2ca50a3ada149bd5">csl::ACos</a>, <a class="el" href="classcsl_1_1Pow.html#aff8a636e76fdb85a66a389c312ca5729">csl::Pow</a>, <a class="el" href="classcsl_1_1Tan.html#a69fc6716a19363bc3379d64faad91f28">csl::Tan</a>, <a class="el" href="classcsl_1_1Imaginary.html#a78ac0adf5aa6b8c4a159295ca8dd2fbb">csl::Imaginary</a>, <a class="el" href="classcsl_1_1Complex.html#a8405fa57577ecae2935fa40b703db69b">csl::Complex</a>, <a class="el" href="classcsl_1_1Sin.html#ab26f459fab68d5b382ff9a4be70b9c2d">csl::Sin</a>, <a class="el" href="classcsl_1_1Prod.html#a3bcfa6d3a4b9a8d1ab4255f01fe7edfd">csl::Prod</a>, <a class="el" href="classcsl_1_1IntFactorial.html#ab1a3293c37e9e099f6c2e1ec977612ec">csl::IntFactorial</a>, <a class="el" href="classcsl_1_1Cos.html#a0004c95693419ba41ad203caf20a7f64">csl::Cos</a>, <a class="el" href="classcsl_1_1IntFraction.html#af5517b79f442b4fdc42116e717098cfe">csl::IntFraction</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#aa3b01cb3bd1dcef5901cc82ec29c66b3">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1VectorIntegral.html#a8d48fe368eea528433f18e5d8eb7c3a8">csl::VectorIntegral</a>, <a class="el" href="classcsl_1_1Variable.html#a595fc7eb8f15fe01c80903a7fea41890">csl::Variable</a>, <a class="el" href="classcsl_1_1Log.html#adb9494e204b723c0401b679cde2b36e3">csl::Log</a>, <a class="el" href="classcsl_1_1Polynomial.html#af1a0a4d8e8fb9358c90da3ce04d078d1">csl::Polynomial</a>, <a class="el" href="classcsl_1_1TensorFieldElement.html#ac36fad3d18e46c353b4d961867d257cf">csl::TensorFieldElement</a>, <a class="el" href="classcsl_1_1Float.html#a19efbc737f9188703d55730839b744c0">csl::Float</a>, <a class="el" href="classcsl_1_1ScalarIntegral.html#a6b5309cffd01f21e5485a61b5bb351f3">csl::ScalarIntegral</a>, <a class="el" href="classcsl_1_1Exp.html#a4bf08517c64b660eb82cf2922e893cfc">csl::Exp</a>, <a class="el" href="classcsl_1_1Constant.html#a606d0d84686fe39def7bfed9bacd5817">csl::Constant</a>, <a class="el" href="classcsl_1_1ScalarField.html#a228095f931ff4c3e48c978c9dca6f4cd">csl::ScalarField</a>, <a class="el" href="classcsl_1_1Integer.html#ab775bd9a73cd2a9c410e1fdc02c8b9b9">csl::Integer</a>, <a class="el" href="classcsl_1_1Commutator.html#a1f359f9d2379cabeec2522b6bbbd034a">csl::Commutator</a>, <a class="el" href="classcsl_1_1Sum.html#a98d6f1d250495606344f29e78ba47ee0">csl::Sum</a>, <a class="el" href="classcsl_1_1ImaginaryPart.html#af9c1420abf4c1060ce30061b75323899">csl::ImaginaryPart</a>, <a class="el" href="classcsl_1_1Arbitrary.html#a2275ec73b2842df28cb80bd59bbf958d">csl::Arbitrary</a>, <a class="el" href="classcsl_1_1NumericalEval.html#a0b1b4b45111ecfda5e0cdd08202ac601">csl::NumericalEval</a>, <a class="el" href="classcsl_1_1Abs.html#a4dcecd9b1e1dbca2386e4af8dd663ba5">csl::Abs</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#a8a568746d53548b8621fda445258e830">csl::AbstractVectorial</a>, <a class="el" href="classcsl_1_1RealPart.html#a44828a44f3945f853c2b94e4b1e31820">csl::RealPart</a>, and <a class="el" href="classcsl_1_1Scalar.html#a012a940130fea1d453f9772c61184304">csl::Scalar</a>.</p>

</div>
</div>
<a id="a70d31d945e2012d108dfc3ce3eb48161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d31d945e2012d108dfc3ce3eb48161">&#9670;&nbsp;</a></span>removeProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::removeProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a property to the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>Property to remove from <b>props</b>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#aa74f724e7aa9bdf2778767aca7eba51b">csl::TensorElement</a>, and <a class="el" href="classcsl_1_1AbstractLiteral.html#a1d206426eee6f4af5204b791e58eb5f4">csl::AbstractLiteral</a>.</p>

</div>
</div>
<a id="acc0eb077e25c9a67d15269cf8d5f0511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0eb077e25c9a67d15269cf8d5f0511">&#9670;&nbsp;</a></span>replaceIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::replaceIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>indexToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>newIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refresh</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For indicial expressions, this function searches <b>indexToContract</b> and replaces it with newIndex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexToContract</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> that is newly contracted. </td></tr>
    <tr><td class="paramname">newIndex</td><td>Dummy new index that replaces <b>indexToContract</b> in the expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the index has been found. </dd>
<dd>
<b>False</b> else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IProd.html#a8f32fd847835d145cc8b4ff062d03c7d">csl::IProd</a>, <a class="el" href="classcsl_1_1ISum.html#ad3f536e97dbf9f257fc08d6a1ad1d597">csl::ISum</a>, <a class="el" href="classcsl_1_1TensorElement.html#a02fe69a766b8eade9d5de6cbea8054a6">csl::TensorElement</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a636313fd58465a56d3b41cb74f9ffaff">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#ae304eceb527459e79e9cc635350b1a70">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#aeaa65642df3b0311a2f0056335011ab9">csl::AbstractDuoFunc</a>, and <a class="el" href="classcsl_1_1AbstractFunc.html#a0714debb1e4fe6d8b6bf1b915771b30c">csl::AbstractFunc</a>.</p>

</div>
</div>
<a id="aab2d2ac186b56d17d2cc0a105e145b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2d2ac186b56d17d2cc0a105e145b11">&#9670;&nbsp;</a></span>setArgument() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::setArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iArg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the argument at position <b>iArg</b> (default=0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression that replaces the argument. </td></tr>
    <tr><td class="paramname">iArg</td><td>the position of the argument to change. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IProd.html#a9c6895c9d37d17614f54e3baeec96585">csl::IProd</a>, <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a6cf9bbbcd0b0b3f75121f1c0a5cf4d57">csl::AbstractMultiFunc</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#adce6c89ecb493c05627b42f036e49b5b">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractDuoFunc.html#ab9ed03e7424e97a17464fb76e14bb213">csl::AbstractDuoFunc</a>, <a class="el" href="classcsl_1_1AbstractVectorial.html#ae67f1daf87e45e15b82dd2827f6ba55f">csl::AbstractVectorial</a>, and <a class="el" href="classcsl_1_1AbstractFunc.html#a701d14b482a47a85c6cd5266118604cb">csl::AbstractFunc</a>.</p>

</div>
</div>
<a id="ae7907d6983f47d261748870b497f6aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7907d6983f47d261748870b497f6aa8">&#9670;&nbsp;</a></span>setArgument() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void csl::Abstract::setArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the argument at position <b>{i</b>,j,...} for multi-dimensions expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression that replaces the argument. </td></tr>
    <tr><td class="paramname">indices</td><td>An std::vector containing the series of indices corresponding to the argument to replace. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a47a8b2fbd9233c706cb5fcf05f96bc7f">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a7bb29d316b8f64652cef472a6c23f001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb29d316b8f64652cef472a6c23f001">&#9670;&nbsp;</a></span>setCommutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::setCommutable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t_commutable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the abstract to commute or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_commutable</td><td>Must be <b>true</b> if the abstract can commute. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Variable.html#ac51328102c02c7f24ace7742db02537c">csl::Variable</a>, <a class="el" href="classcsl_1_1Constant.html#ad3f5b9cfa86f3c63c75fc48669c80c03">csl::Constant</a>, and <a class="el" href="classcsl_1_1AbstractElement.html#ab8f5f04326a3320b48a315ec5cee60d9">csl::AbstractElement</a>.</p>

</div>
</div>
<a id="a70f946f9c59df045ef7416320ade89c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f946f9c59df045ef7416320ade89c7">&#9670;&nbsp;</a></span>setIndexStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::setIndexStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>t_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the index structure of the object, that must be an <b>Indicial</b> expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_index</td><td>A std::vector of <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> which takes the place of the structure index. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1TensorElement.html#a387f69126ae40d711755945ef023de92">csl::TensorElement</a>, and <a class="el" href="classcsl_1_1TDerivativeElement.html#ae976c5be78ef54ca485001a9807d75bc">csl::TDerivativeElement</a>.</p>

</div>
</div>
<a id="a867135c96776248add60018f4aa7a578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867135c96776248add60018f4aa7a578">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>t_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the name of the abstract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_name</td><td>Replaces name. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Variable.html#a48c1ccf9f8ff0fa0b533f7e986340b85">csl::Variable</a>, <a class="el" href="classcsl_1_1Constant.html#aa1d8e4b670f8bf97a1253a9056178248">csl::Constant</a>, and <a class="el" href="classcsl_1_1AbstractElement.html#aed5a0c9faec5b41fb1feb52764c4237f">csl::AbstractElement</a>.</p>

</div>
</div>
<a id="a70df7be4486affa8dc891e3f25bf499f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70df7be4486affa8dc891e3f25bf499f">&#9670;&nbsp;</a></span>setOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::setOperand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the operand of an operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>New operand. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Integral.html#af49dcf27651f1e5e149093da246dae8f">csl::Integral</a>, <a class="el" href="classcsl_1_1Derivative.html#aef758e6375f3faf33875d9a1228cec44">csl::Derivative</a>, <a class="el" href="classcsl_1_1TDerivativeElement.html#ab78ef96e45ffe45a9fd18b315ad73db9">csl::TDerivativeElement</a>, <a class="el" href="classcsl_1_1AbstractIntegral.html#a65250576bfa5547fe8eb17c37e0d3ed7">csl::AbstractIntegral</a>, <a class="el" href="classcsl_1_1ImaginaryPart.html#a6e749b2756439d060e103585a11af231">csl::ImaginaryPart</a>, and <a class="el" href="classcsl_1_1RealPart.html#a3e065209200a53a0a5d13d4731298832">csl::RealPart</a>.</p>

</div>
</div>
<a id="ae7b8a14fc746ed72e4d5abd63373c5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b8a14fc746ed72e4d5abd63373c5ba">&#9670;&nbsp;</a></span>setOperandPrivate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::setOperandPrivate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leaveEmpty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the operand of an operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operand</td><td>New operand. </td></tr>
    <tr><td class="paramname">leaveEmpty</td><td>Boolean that tells if the operator must stay empty (if true, then it will again apply later) or not (if false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83fee8ed28079bcac107455d58be9d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fee8ed28079bcac107455d58be9d5d">&#9670;&nbsp;</a></span>setVectorArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csl::Abstract::setVectorArgument </td>
          <td>(</td>
          <td class="paramtype">const csl::vector_expr &amp;&#160;</td>
          <td class="paramname"><em>t_argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaced the entire std::vector of argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_argument</td><td>std::vector of expressions to copy. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractMultiFunc.html#a8e6df749f2e0afdbe8ae0993235dda54">csl::AbstractMultiFunc</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#a2d072812c1918ec0097729d353003198">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a4eeedaeaa39e75facf1060dce7c57a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eeedaeaa39e75facf1060dce7c57a8f">&#9670;&nbsp;</a></span>suppressExponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; csl::Abstract::suppressExponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the expression where the factor <b>factor^exponent</b> has been suppressed. </p>
<p>This function works the same manner as <a class="el" href="classcsl_1_1Abstract.html#ac513c930caa9939c2b9557f36a34ee69" title="Fills in a vector the exponents corresponding to some factors for the expression. ...">getExponents()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Factor to suppress. </td></tr>
    <tr><td class="paramname">exponent</td><td>Exponent of the factor to suppress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified expression if the factor has been found. </dd>
<dd>
std::nullopt else.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may replace in the future the functions <a class="el" href="classcsl_1_1Abstract.html#a27ad666bf7d533607da9675b0c645ee9" title="Check if expr can factor *this. ">askTerm()</a> and <a class="el" href="classcsl_1_1Abstract.html#a43520e1d6d5fdad9b50f77c6e027f928" title="Remove a factor from an expr, that must have been determined before. ">suppressTerm()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Pow.html#a3f66770914a5aeb7b83cbfa5f1b9eca6">csl::Pow</a>, and <a class="el" href="classcsl_1_1Prod.html#a3b491384c2717ae8b618d91dd8db39f1">csl::Prod</a>.</p>

</div>
</div>
<a id="a43520e1d6d5fdad9b50f77c6e027f928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43520e1d6d5fdad9b50f77c6e027f928">&#9670;&nbsp;</a></span>suppressTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::suppressTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a factor from an expr, that must have been determined before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Expression to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expr in which <b>factor</b> has been removed </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1IProd.html#aca4461b782859509b8a9a1deb3846bc3">csl::IProd</a>, <a class="el" href="classcsl_1_1Integral.html#a0c07c13fb5d171702866ce1a7418b166">csl::Integral</a>, <a class="el" href="classcsl_1_1Pow.html#a4c86c0033639557a339816bf9a80a9a7">csl::Pow</a>, <a class="el" href="classcsl_1_1Prod.html#ad278cc42d80c2429fc3f6cd2abe38b33">csl::Prod</a>, <a class="el" href="classcsl_1_1Sum.html#a37d045772a3fbedf76bf72588ee2e212">csl::Sum</a>, and <a class="el" href="classcsl_1_1AbstractIntegral.html#ac5fa23e3bd78501937629e10d1938ea5">csl::AbstractIntegral</a>.</p>

</div>
</div>
<a id="a4faf1ffd8cb3b6c721e128980c0303d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faf1ffd8cb3b6c721e128980c0303d8">&#9670;&nbsp;</a></span>symmetrise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::symmetrise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the symmetrization of a 2D matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>1/2*(A + A^T) for a matrix (2D) A. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Matrix.html#ac6c4ce8256eff3054bba06339ddc8525">csl::Matrix</a>, and <a class="el" href="classcsl_1_1AbstractVectorial.html#a690f2f1b0748bbd81213335c47535113">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a7b83c6a13716688f45b02e6291d39aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b83c6a13716688f45b02e6291d39aba">&#9670;&nbsp;</a></span>tensordot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::tensordot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tensordot of two <b>Vectorial</b> expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The right operand of the tensordot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor dot of <b>*this</b> and <b>expr</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a0e4336f06daf87990d127a4b755c121c">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a9a86d21f5c5f65eb7e524a8f8002c0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a86d21f5c5f65eb7e524a8f8002c0e7">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><em>i A</em>{ii} for a square matrix A. </dd>
<dd>
A for a scalar A. </dd>
<dd>
0 else. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Matrix.html#a9b6a6fbd8faebb39f785654de2953bc1">csl::Matrix</a>.</p>

</div>
</div>
<a id="aacab43e551e9259a39a79378373ce49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacab43e551e9259a39a79378373ce49c">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::trace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the trace over the axis <b>axis1</b> and <b>axis2</b> of a tensor. <b>axis1</b> and <b>axis2</b> can be the same, in which case the trace just corresponds to the sum over this particular axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis1</td><td>First axis to contract. </td></tr>
    <tr><td class="paramname">axis2</td><td>Second axis to contract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the trace over axis <b>axis1</b> and <b>axis2</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1AbstractVectorial.html#a9a79c1dcc4d4ee22c8662ffcc11e5378">csl::AbstractVectorial</a>.</p>

</div>
</div>
<a id="a1e97712696e5c40b28bc1e35987fea94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e97712696e5c40b28bc1e35987fea94">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Abstract::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the transpose of a 2D matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A^T for a matrix (2D) A. </dd></dl>

<p>Reimplemented in <a class="el" href="classcsl_1_1Matrix.html#a5fe3058c93a9dfe149f742c9b601a9b4">csl::Matrix</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="abstract_8h_source.html">abstract.h</a></li>
<li>src/abstract.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
