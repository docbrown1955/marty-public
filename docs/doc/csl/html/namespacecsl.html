<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSL: csl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image.png" href="../../../logo-marty.png"/>
<link href="style_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
      <a href="https://marty.in2p3.fr"><img alt="Logo" src="Logo1.svg" height=100px/></a></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">
       Documentation of <i><b>CSL</b></i>
   </div>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">csl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for csl library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abbrev.html">Abbrev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abbreviation.html">Abbreviation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abs.html">Abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the abs function.  <a href="classcsl_1_1Abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Abstract.html">Abstract</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Root</b> class of the inheritance tree of abstracts.  <a href="classcsl_1_1Abstract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractBuildingBlock.html">AbstractBuildingBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> class from which derive all building blocks of exprs, i.e. objects not function of further exprs: the leafs of the recursive tree.  <a href="classcsl_1_1AbstractBuildingBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractDuoFunc.html">AbstractDuoFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle functions of <b>multiple</b> arguments. In the case of the call of a simplification function, if recursive, the function will be first applied on all the <b>arguments</b>, then to the function itself.  <a href="classcsl_1_1AbstractDuoFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractElement.html">AbstractElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all elements. Objects that are constructed by a parent (see <a class="el" href="classcsl_1_1AbstractParent.html" title="Base class for all parents (indicial, fields etc). All parents derive from this class. ">AbstractParent</a>) when the user give it what is needed to create the element (indices, space-time point etc).  <a href="classcsl_1_1AbstractElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractField.html">AbstractField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractFunc.html">AbstractFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <b>scalar functions of one argument.</b>  <a href="classcsl_1_1AbstractFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractIntegral.html">AbstractIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractLiteral.html">AbstractLiteral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> class from which derive literal building blocks: <a class="el" href="classcsl_1_1Constant.html" title="Handle an object with a name and a value. ">Constant</a>, <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a>, <a class="el" href="classcsl_1_1Imaginary.html" title="Numerical representation of i. ">Imaginary</a> and <a class="el" href="classcsl_1_1IntFactorial.html" title="Handles factorial of a Number. ">IntFactorial</a>.  <a href="classcsl_1_1AbstractLiteral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractMultiFunc.html">AbstractMultiFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle functions of <b>multiple</b> arguments. In the case of the call of a simplification function, if recursive, the function will be first applied on all the <b>arguments</b>, then to the function itself.  <a href="classcsl_1_1AbstractMultiFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractNumerical.html">AbstractNumerical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> class from which derive numerical types, i.e. <a class="el" href="classcsl_1_1Float.html" title="Handle numbers in expr. ">Float</a>, <a class="el" href="classcsl_1_1Integer.html" title="Handle numbers in expr. ">Integer</a>, <a class="el" href="classcsl_1_1IntFraction.html" title="Handles fractions of Number. ">IntFraction</a>.  <a href="classcsl_1_1AbstractNumerical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all parents (indicial, fields etc). All parents derive from this class.  <a href="classcsl_1_1AbstractParent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1AbstractVectorial.html">AbstractVectorial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ACos.html">ACos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the acos function.  <a href="classcsl_1_1ACos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ACosh.html">ACosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the acosh function.  <a href="classcsl_1_1ACosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Angle.html">Angle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a angle of 2 arguments.  <a href="classcsl_1_1Angle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Arbitrary.html">Arbitrary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Arbitrary.html" title="Arbitrary object that can enter mathematical expressions. ">Arbitrary</a> object that can enter mathematical expressions.  <a href="classcsl_1_1Arbitrary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ASin.html">ASin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the asin function.  <a href="classcsl_1_1ASin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ASinh.html">ASinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the asinh function.  <a href="classcsl_1_1ASinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ATan.html">ATan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the atan function.  <a href="classcsl_1_1ATan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ATanh.html">ATanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the atanh function.  <a href="classcsl_1_1ATanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcsl_1_1canDecay.html">canDecay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Commutator.html">Commutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object that represents a commutator or an anti-commutator, thus is derived from <a class="el" href="classcsl_1_1AbstractDuoFunc.html" title="Handle functions of multiple arguments. In the case of the call of a simplification function...">AbstractDuoFunc</a> that handles two arguments -&gt; [A,B].  <a href="classcsl_1_1Commutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Comparator.html">Comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bunch of functions that allow to do comparisons with <a class="el" href="classcsl_1_1Arbitrary.html" title="Arbitrary object that can enter mathematical expressions. ">Arbitrary</a> expressions or expressions with dummy objects (summed indices or variables).  This is a static class, in the sense that all methods and attributes are static i.e. independant of any isntance of the class. There is then no <a class="el" href="classcsl_1_1Comparator.html" title="Bunch of functions that allow to do comparisons with Arbitrary expressions or expressions with dummy ...">Comparator</a> object constructed, the class just allows to centralize all variables and functions useful for those comparisons.  <a href="classcsl_1_1Comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Complex.html">Complex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Complexified.html">Complexified</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle an object with a <b>name</b> and a <b>value</b>.  <a href="classcsl_1_1Constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ConstantParent.html">ConstantParent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ContractionChain.html">ContractionChain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Cos.html">Cos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the cos function.  <a href="classcsl_1_1Cos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Cosh.html">Cosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the cosh function.  <a href="classcsl_1_1Cosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1DeltaParent.html">DeltaParent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> for a kronecker delta.  <a href="classcsl_1_1DeltaParent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Derivative.html">Derivative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the exponentiation of one <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another.  <a href="classcsl_1_1Derivative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Diagonalizer.html">Diagonalizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1DiracDelta.html">DiracDelta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1EpsilonParent.html">EpsilonParent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> for a kronecker delta.  <a href="classcsl_1_1EpsilonParent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Equation.html">Equation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Exp.html">Exp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the exponential function.  <a href="classcsl_1_1Exp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcsl_1_1ExpansionChain.html">ExpansionChain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression type/.  <a href="classcsl_1_1Expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Factorial.html">Factorial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the factorial function.  <a href="classcsl_1_1Factorial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1FieldParent.html">FieldParent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Float.html">Float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle numbers in expr.  <a href="classcsl_1_1Float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1float__sap.html">float_sap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1float__sap_3_010_01_4.html">float_sap&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1float__sap_3_011_01_4.html">float_sap&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1format.html">format</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Formatter.html">Formatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Functional.html">Functional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1HighDTensor.html">HighDTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Imaginary.html">Imaginary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical representation of <b>i</b>.  <a href="classcsl_1_1Imaginary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ImaginaryPart.html">ImaginaryPart</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Index.html">Index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> object that is used for indicial objects.  <a href="classcsl_1_1Index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1IndexedSymmetry.html">IndexedSymmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a std::vector of <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a>, to be used by an <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>.  <a href="classcsl_1_1IndexStructure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1IndexStructure__new.html">IndexStructure_new</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1IndexStructureView.html">IndexStructureView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1IndicialEquation.html">IndicialEquation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1InitSanitizer.html">InitSanitizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a value of a given to ensure that it initialized when used.  <a href="classcsl_1_1InitSanitizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1int__ap.html">int_ap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1int__ap_3_010_01_4.html">int_ap&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1int__ap_3_011_01_4.html">int_ap&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Integer.html">Integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle numbers in expr.  <a href="classcsl_1_1Integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Integral.html">Integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1IntFactorial.html">IntFactorial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles factorial of a Number.  <a href="classcsl_1_1IntFactorial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1IntFraction.html">IntFraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles <b>fractions</b> of Number.  <a href="classcsl_1_1IntFraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1IProd.html">IProd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a> object to handle <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a> objects in the product (apply contraction of indices etc).  <a href="classcsl_1_1IProd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ISum.html">ISum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a> object to handle <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a> objects in the product (apply contraction of indices etc).  <a href="classcsl_1_1ISum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1LibDependency.html">LibDependency</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1LibEval.html">LibEval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1LibEvalSession.html">LibEvalSession</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1LibFunction.html">LibFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcsl_1_1LibParameter.html">LibParameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1LibraryExpander.html">LibraryExpander</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1LibraryGenerator.html">LibraryGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1LibraryGroup.html">LibraryGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1linear__map.html">linear_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1LiteralParent.html">LiteralParent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Lock.html">Lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static class allowing to compress expressions given a boolean predicate.  <a href="classcsl_1_1Lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Log.html">Log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the logarithm function.  <a href="classcsl_1_1Log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1MetricParent.html">MetricParent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a> for a matric object (two indices symmetric etc). An object of type <a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> initializated with a metric will automatically have signed indices.  <a href="classcsl_1_1MetricParent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1MultiPermutation.html">MultiPermutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1NumericalEval.html">NumericalEval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ObjectPermutation.html">ObjectPermutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ObjectSymmetry.html">ObjectSymmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Operator.html">Operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear operator O(a*X+b*Y) = a*O(X) + b*O(Y)  <a href="classcsl_1_1Operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1OptionalCondition.html">OptionalCondition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Parent.html">Parent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Permutation.html">Permutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a std::vector of integers that represents the permutation of n indices, with a possible symmetry of an <a class="el" href="classcsl_1_1IndexStructure.html" title="Manages a std::vector of Index, to be used by an TensorElement. ">IndexStructure</a>.  <a href="classcsl_1_1Permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a polynomial, function of multiple arguments.  <a href="classcsl_1_1Polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Pow.html">Pow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the exponentiation of one <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> wrt another.  <a href="classcsl_1_1Pow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Prod.html">Prod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a product, function of multiple arguments.  <a href="classcsl_1_1Prod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ProgressBar.html">ProgressBar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1PropertyList.html">PropertyList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1PseudoIntegral.html">PseudoIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1RealPart.html">RealPart</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Scalar.html">Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ScalarField.html">ScalarField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ScalarFieldParent.html">ScalarFieldParent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ScalarIntegral.html">ScalarIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1ScopedProperty.html">ScopedProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1SelfContraction.html">SelfContraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small class that allows to handle contractions of indices between tensors.  <a href="classcsl_1_1SelfContraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sin.html">Sin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the sin function.  <a href="classcsl_1_1Sin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sinh.html">Sinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the sinh function.  <a href="classcsl_1_1Sinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Space.html">Space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Vector.html">Vector</a> space that has a name, a dimension, a delta tensor and possibly a non-trivial metric. If a metric is given, the indices in this space are signed, i.e. their up- or down- position matter in expressions.  <a href="classcsl_1_1Space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcsl_1_1Structure.html">Structure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Sum.html">Sum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a sum, function of multiple arguments.  <a href="classcsl_1_1Sum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Symmetry.html">Symmetry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the full symmetry properties of an <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>, i.e. a vector of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> objects, each giving a permutation of the indices and the sign of the permutation (if the permutation is symmetric or anti-symmetric).  <a href="classcsl_1_1Symmetry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Tan.html">Tan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the tan function.  <a href="classcsl_1_1Tan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Tanh.html">Tanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final specialization of <a class="el" href="classcsl_1_1AbstractFunc.html" title="Base class for scalar functions of one argument. ">AbstractFunc</a>, the tanh function.  <a href="classcsl_1_1Tanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TDerivative.html">TDerivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TDerivativeElement.html">TDerivativeElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TDerivativeParent.html">TDerivativeParent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Tensor.html">Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorElement.html">TensorElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> for Indicial tensor. Building block carrying indices, and respecting Einstein's summation convention.  <a href="classcsl_1_1TensorElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorField.html">TensorField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorFieldElement.html">TensorFieldElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorFieldParent.html">TensorFieldParent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TensorParent.html">TensorParent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Parent.html">Parent</a> of an indicial object, allows to generate them (<a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a>).  <a href="classcsl_1_1TensorParent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1TimeMonitor.html">TimeMonitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Timer.html">Timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle an object with a <b>name</b> and a <b>value</b>.  <a href="classcsl_1_1Variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1VariableParent.html">VariableParent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1Vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcsl_1_1VectorIntegral.html">VectorIntegral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac72ed6f0a56d753d724c4afdc38b66f5"><td class="memTemplParams" colspan="2"><a id="ac72ed6f0a56d753d724c4afdc38b66f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac72ed6f0a56d753d724c4afdc38b66f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allocator</b> = std::allocator&lt; T &gt;</td></tr>
<tr class="separator:ac72ed6f0a56d753d724c4afdc38b66f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac550b9d2b30e542c11a9604ccd46dcf1"><td class="memItemLeft" align="right" valign="top"><a id="ac550b9d2b30e542c11a9604ccd46dcf1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ExpanderEmitter</b> = std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const  &amp;)&gt;</td></tr>
<tr class="separator:ac550b9d2b30e542c11a9604ccd46dcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746177f57bc7e22d41d7d3b1e981d84"><td class="memItemLeft" align="right" valign="top"><a id="af746177f57bc7e22d41d7d3b1e981d84"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ExpanderReceiver</b> = std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const  &amp;, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const  &amp;)&gt;</td></tr>
<tr class="separator:af746177f57bc7e22d41d7d3b1e981d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa804192228c299d8b648e4dc194cb689"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aa804192228c299d8b648e4dc194cb689">replacementRule</a> = std::function&lt; std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt;(<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const  &amp;, bool)&gt;</td></tr>
<tr class="memdesc:aa804192228c299d8b648e4dc194cb689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement rule prototype.  <a href="#aa804192228c299d8b648e4dc194cb689">More...</a><br /></td></tr>
<tr class="separator:aa804192228c299d8b648e4dc194cb689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38970f7ca3e3f1b55a4f45bec29d2df"><td class="memItemLeft" align="right" valign="top"><a id="ac38970f7ca3e3f1b55a4f45bec29d2df"></a>
typedef const <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Expr_info</b></td></tr>
<tr class="separator:ac38970f7ca3e3f1b55a4f45bec29d2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb3e4e41be0151231def8d5c952951"><td class="memItemLeft" align="right" valign="top"><a id="aacdb3e4e41be0151231def8d5c952951"></a>
typedef <a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; const <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Expr_c</b></td></tr>
<tr class="separator:aacdb3e4e41be0151231def8d5c952951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440b1a9dde4e51a3c3e7a33d96df369c"><td class="memItemLeft" align="right" valign="top"><a id="a440b1a9dde4e51a3c3e7a33d96df369c"></a>
typedef std::unique_ptr&lt; <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>unique_Expr</b></td></tr>
<tr class="separator:a440b1a9dde4e51a3c3e7a33d96df369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49336789149088ae6010c23e67c53f95"><td class="memItemLeft" align="right" valign="top"><a id="a49336789149088ae6010c23e67c53f95"></a>
typedef std::unique_ptr&lt; const <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>unique_Expr_c</b></td></tr>
<tr class="separator:a49336789149088ae6010c23e67c53f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926bc4385ff492af398884ab534923b6"><td class="memItemLeft" align="right" valign="top"><a id="a926bc4385ff492af398884ab534923b6"></a>
typedef std::weak_ptr&lt; <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>weak_Expr</b></td></tr>
<tr class="separator:a926bc4385ff492af398884ab534923b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaff380aa34cc67e6e7ae404aa14905c"><td class="memItemLeft" align="right" valign="top"><a id="aaaff380aa34cc67e6e7ae404aa14905c"></a>
typedef std::weak_ptr&lt; const <a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>weak_Expr_c</b></td></tr>
<tr class="separator:aaaff380aa34cc67e6e7ae404aa14905c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ffcbfc49457813a3e4fdb2d7ffb165"><td class="memItemLeft" align="right" valign="top"><a id="a88ffcbfc49457813a3e4fdb2d7ffb165"></a>
typedef const <a class="el" href="classcsl_1_1AbstractParent.html">csl::AbstractParent</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Parent_info</b></td></tr>
<tr class="separator:a88ffcbfc49457813a3e4fdb2d7ffb165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067a17a493aeffd986aa5ea8ae85d575"><td class="memItemLeft" align="right" valign="top"><a id="a067a17a493aeffd986aa5ea8ae85d575"></a>
typedef const <a class="el" href="classcsl_1_1TensorParent.html">csl::TensorParent</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>IParent_info</b></td></tr>
<tr class="separator:a067a17a493aeffd986aa5ea8ae85d575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88b0b3d8010512d6fac1e522db74e74"><td class="memItemLeft" align="right" valign="top"><a id="ab88b0b3d8010512d6fac1e522db74e74"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vector_alloc</b> = std::allocator&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;</td></tr>
<tr class="separator:ab88b0b3d8010512d6fac1e522db74e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543abd0221d4fe08c31b5d532326937"><td class="memItemLeft" align="right" valign="top"><a id="aa543abd0221d4fe08c31b5d532326937"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vector_expr</b> = std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;</td></tr>
<tr class="separator:aa543abd0221d4fe08c31b5d532326937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799ce7f7ecf124e10a313878e3415a93"><td class="memItemLeft" align="right" valign="top"><a id="a799ce7f7ecf124e10a313878e3415a93"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FactorType</b> = std::pair&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>, std::vector&lt; size_t &gt; &gt;</td></tr>
<tr class="separator:a799ce7f7ecf124e10a313878e3415a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac073d773722f722712fc6196a0d7647e"><td class="memItemLeft" align="right" valign="top"><a id="ac073d773722f722712fc6196a0d7647e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator</td></tr>
<tr class="separator:ac073d773722f722712fc6196a0d7647e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a70046459ec0082db8cb97005c13c9a54"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">PrimaryType</a> { <br />
&#160;&#160;<b>Arbitrary</b> =-1, 
<a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54a5225763efc97aebd39e5a303fceb57ac">PrimaryType::Numerical</a>, 
<a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54ad7da1b76e5799f53a399b7a96ba67437">PrimaryType::Literal</a>, 
<a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54a78216444cbb3388cc8c2f64cc44c7cd5">PrimaryType::MultiFunction</a> =10, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54a8870e734b769add08821a829f6951853">PrimaryType::ScalarFunction</a> =20, 
<a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54a97a447e7de95e9e2940291e17bcc4e3a">PrimaryType::Vectorial</a> =50, 
<a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54a25e27f9899952c474587a6bee3ab9978">PrimaryType::Indicial</a> =60, 
<a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54a6f16a5f8ff5d75ab84c018adacdfcbb7">PrimaryType::Field</a> =70
<br />
 }<tr class="memdesc:a70046459ec0082db8cb97005c13c9a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores enumerations of types for Abstract objects.  <a href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a70046459ec0082db8cb97005c13c9a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace591865c69b6315c533a1a325777312"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">Type</a> { <br />
&#160;&#160;<b>InheritanceType</b> =-2, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a9080fd7a5f0af44b585bb21b62d8b283">Type::NoType</a> =-1, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312aa0faef0851b4294c06f2b94bb1cb2044">Type::Integer</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a22ae0e2b89e5e3d477f988cc36d3272b">Type::Float</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312aa9e4acf6d1d381d6875f480a5737b8b4">Type::IntFraction</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312aa79046cb7e9f609ba07c4ec22f14a862">Type::IntFactorial</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a10b4eb76294b70d7fd6df997ff06edb1">Type::Complex</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312ab87c58a6946efb3fd56cc53586d2fb78">Type::NumericalEval</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312af19f497d4c860d252cc1e055d0362ccc">Type::Imaginary</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312acb17869fe51048b5a5c4c6106551a255">Type::Constant</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a47c14840d8e15331fa420b9b2f757cd9">Type::Variable</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312acad39a154bffb61175f674d6eefaf6d0">Type::Exp</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312ace0be71e33226e4c1db2bcea5959f16b">Type::Log</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a29524358ad4c2579d7b08a21c990ce5e">Type::DiracDelta</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a1e34af023adeb7d5f484f8eb4b9826b6">Type::Abs</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312affca562be079b9e4e41ea9d6a86c582b">Type::Cos</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a0986d137604183312e6d3599578bc6cd">Type::Sin</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a1266b4e6f81e60733ec6c717e0181f60">Type::Tan</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a4371c3565b771b40c187487cc0190392">Type::Cosh</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a98ed804abf4edd1f3be3fa894fa8cc3d">Type::Sinh</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312acc132a41cab5676334f353a22a0aa5c5">Type::Tanh</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a1c3ca8e525c0e6a47cc8489cb3155365">Type::ACos</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a118d7e2878ba8789c8f86eee41c470b3">Type::ASin</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312af9be9640e98f6072e8e0eaf2b418efe2">Type::ATan</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a27cebb75cb5855484f7df7070b4cab73">Type::ACosh</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a6964cd88a53b2e4c358bcad0d9feac55">Type::ASinh</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a2286f4e717c6213c895da49a51aa5de7">Type::ATanh</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312af60357a8d17e45793298323f1b372a74">Type::Scalar</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312ac74cc04b1519df2caf5026e94c3e8bab">Type::RealPart</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312ac49d71b3e882559a62d9d17009728907">Type::ImaginaryPart</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a2ed2c32254f39662881b6eed72021250">Type::TensorElement</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a02e48a623b58c0b63bd2ad0e891c944e">Type::ScalarField</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a5a44d898396f28619971f227d438ef40">Type::TensorFieldElement</a>, 
<b>TDerivativeElement</b>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312af575ff69fb3dc1eeb3341d4a419cada2">Type::StandardDuo</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a607547b66dcd8e516cde5cc78739ae80">Type::StandardMult</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a8be6d3e955290ee50c00a4bc92aa7749">Type::Pow</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a362a33c23b08e4a32a4ec53fbb82cccd">Type::Prod</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312aa0ec87054b5e5b7847d0d8780a01a3d5">Type::Sum</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a24ecfbe376a82f09ad48bffc6b8d6a87">Type::Polynomial</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a70ae6e285cc14c8486e3cf5bec39d1fd">Type::Derivative</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312acc1e31375d9c49eb15a3302b96acc061">Type::Commutator</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a45f4ce6c3306644b1efe333f4f8d6929">Type::Angle</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a012b11265b94945f7a1390a07776e625">Type::Factorial</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a4ea94552a2bec56a29592359a1b6069e">Type::Integral</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312ad4d8fc83b4874f82d0b698683c6b9e22">Type::ScalarIntegral</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a7a5b7a2e7ef67739db0cf0cc4d3e5d60">Type::VectorIntegral</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a57dea6f5039281b7fee517fc43bf3110">Type::Vector</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312af53df0293e169f562bc1d9a20e1d2589">Type::Matrix</a>, 
<a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312a93ff2aa452bc6cbb7c3fe56cc7d196c5">Type::HighDTensor</a>
<br />
 }<tr class="memdesc:ace591865c69b6315c533a1a325777312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of the different types of Abstract (i.e. list of all possible specializations).  <a href="namespacecsl.html#ace591865c69b6315c533a1a325777312">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ace591865c69b6315c533a1a325777312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54d9e79dc6697a8eacc07c754b11c0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">ComplexProperty</a> { <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea10b4eb76294b70d7fd6df997ff06edb1">ComplexProperty::Complex</a>, 
<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1">ComplexProperty::Real</a>, 
<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0eaf19f497d4c860d252cc1e055d0362ccc">ComplexProperty::Imaginary</a>
 }<tr class="memdesc:ac54d9e79dc6697a8eacc07c754b11c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all possible complex properties of objects. Real, purely imaginary, or complex.  <a href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac54d9e79dc6697a8eacc07c754b11c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abd7b3dc67eefe314f598720f5b4b276e"><td class="memItemLeft" align="right" valign="top"><a id="abd7b3dc67eefe314f598720f5b4b276e"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand, bool explicitSum=false)</td></tr>
<tr class="separator:abd7b3dc67eefe314f598720f5b4b276e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31a673dcb1a5958b4592cf0ee498836"><td class="memItemLeft" align="right" valign="top"><a id="ae31a673dcb1a5958b4592cf0ee498836"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sum_s</b> (const csl::vector_expr &amp;operands, bool explicitSum=false)</td></tr>
<tr class="separator:ae31a673dcb1a5958b4592cf0ee498836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1186b8efe45b2ea34ffcf8e0de69238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aa1186b8efe45b2ea34ffcf8e0de69238">minus_</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand)</td></tr>
<tr class="memdesc:aa1186b8efe45b2ea34ffcf8e0de69238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <b>sum</b> of the two operands (with a minus sign), applying basic simplifications.  <a href="#aa1186b8efe45b2ea34ffcf8e0de69238">More...</a><br /></td></tr>
<tr class="separator:aa1186b8efe45b2ea34ffcf8e0de69238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a7809aa1495de26d449b25c5676215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae8a7809aa1495de26d449b25c5676215">prod_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand, bool explicitProd=0)</td></tr>
<tr class="memdesc:ae8a7809aa1495de26d449b25c5676215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <b>product</b> of the two operands, applying basic simplifications.  <a href="#ae8a7809aa1495de26d449b25c5676215">More...</a><br /></td></tr>
<tr class="separator:ae8a7809aa1495de26d449b25c5676215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9a2c8d0bab2f2157d4e10bad4b7e1a"><td class="memItemLeft" align="right" valign="top"><a id="a3d9a2c8d0bab2f2157d4e10bad4b7e1a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>prod_s</b> (const csl::vector_expr &amp;operands, bool explicitProd=false)</td></tr>
<tr class="separator:a3d9a2c8d0bab2f2157d4e10bad4b7e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8fb620d09d80258c0c3d0c2a72340a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#adb8fb620d09d80258c0c3d0c2a72340a">fraction_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand)</td></tr>
<tr class="memdesc:adb8fb620d09d80258c0c3d0c2a72340a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <b>fraction</b> of the two operands, applying basic simplifications.  <a href="#adb8fb620d09d80258c0c3d0c2a72340a">More...</a><br /></td></tr>
<tr class="separator:adb8fb620d09d80258c0c3d0c2a72340a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a4d5d0b5daeb571db05ae3bb2d36e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a39a4d5d0b5daeb571db05ae3bb2d36e4">pow_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand)</td></tr>
<tr class="memdesc:a39a4d5d0b5daeb571db05ae3bb2d36e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <b>exponentiation</b> of the two operands, applying basic simplifications.  <a href="#a39a4d5d0b5daeb571db05ae3bb2d36e4">More...</a><br /></td></tr>
<tr class="separator:a39a4d5d0b5daeb571db05ae3bb2d36e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd5919fd19e1d774cd53c7d1ec8ef00"><td class="memItemLeft" align="right" valign="top"><a id="a7bd5919fd19e1d774cd53c7d1ec8ef00"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pow_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, int value)</td></tr>
<tr class="separator:a7bd5919fd19e1d774cd53c7d1ec8ef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48410b0af6a4bd2dad87736d44686b6"><td class="memItemLeft" align="right" valign="top"><a id="ae48410b0af6a4bd2dad87736d44686b6"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand)</td></tr>
<tr class="separator:ae48410b0af6a4bd2dad87736d44686b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae875bd5d5e88ada247048fcae0038e28"><td class="memItemLeft" align="right" valign="top"><a id="ae875bd5d5e88ada247048fcae0038e28"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt_s</b> (int number)</td></tr>
<tr class="separator:ae875bd5d5e88ada247048fcae0038e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34118703c2961443732bb747369f30ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a34118703c2961443732bb747369f30ac">derivative_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand, int order=1)</td></tr>
<tr class="memdesc:a34118703c2961443732bb747369f30ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <b>derivative</b> of <b>leftOperand</b> wrt <em>rightOperand</em>, applying basic simplifications.  <a href="#a34118703c2961443732bb747369f30ac">More...</a><br /></td></tr>
<tr class="separator:a34118703c2961443732bb747369f30ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c2161a4b96c7320f872848dbbc45de"><td class="memItemLeft" align="right" valign="top"><a id="a16c2161a4b96c7320f872848dbbc45de"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>derivative_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand, int order, bool empty)</td></tr>
<tr class="separator:a16c2161a4b96c7320f872848dbbc45de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc24b8fdbab7510461f966c8e402ace"><td class="memItemLeft" align="right" valign="top"><a id="accc24b8fdbab7510461f966c8e402ace"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>derivative_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;variable, int order=1)</td></tr>
<tr class="separator:accc24b8fdbab7510461f966c8e402ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a24294df46f79dd1f36fc077da8290"><td class="memItemLeft" align="right" valign="top"><a id="a59a24294df46f79dd1f36fc077da8290"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>integral_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand)</td></tr>
<tr class="separator:a59a24294df46f79dd1f36fc077da8290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72374e371b9d4880ddbf0b2fa5e0f962"><td class="memItemLeft" align="right" valign="top"><a id="a72374e371b9d4880ddbf0b2fa5e0f962"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>integral_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand, bool empty)</td></tr>
<tr class="separator:a72374e371b9d4880ddbf0b2fa5e0f962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc352ce4f38d82849fd9fed8b92aa7e4"><td class="memItemLeft" align="right" valign="top"><a id="acc352ce4f38d82849fd9fed8b92aa7e4"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>integral_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftOperand, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightOperand, bool empty, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;t_inf, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;t_sup)</td></tr>
<tr class="separator:acc352ce4f38d82849fd9fed8b92aa7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2fdc50f210a980e17772cf6686ab60"><td class="memItemLeft" align="right" valign="top"><a id="adf2fdc50f210a980e17772cf6686ab60"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>integral_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;variable)</td></tr>
<tr class="separator:adf2fdc50f210a980e17772cf6686ab60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ed905708cee81a49d3bf327b7b5294"><td class="memItemLeft" align="right" valign="top"><a id="a30ed905708cee81a49d3bf327b7b5294"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>polynomial_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;t_variable)</td></tr>
<tr class="separator:a30ed905708cee81a49d3bf327b7b5294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756632091cff18581c956afa8b070a6d"><td class="memItemLeft" align="right" valign="top"><a id="a756632091cff18581c956afa8b070a6d"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>polynomial_s</b> (const csl::vector_expr &amp;operands, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;t_variable)</td></tr>
<tr class="separator:a756632091cff18581c956afa8b070a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4214d96bf84e933c268cf30c85ef5065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a4214d96bf84e933c268cf30c85ef5065">operator+</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a4214d96bf84e933c268cf30c85ef5065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut function that allows to use arithmetic operator + with <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> (== shared_ptr&lt;Abstract&gt;).  <a href="#a4214d96bf84e933c268cf30c85ef5065">More...</a><br /></td></tr>
<tr class="separator:a4214d96bf84e933c268cf30c85ef5065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03955fdcbb03fa6eee98de4da8d355"><td class="memItemLeft" align="right" valign="top"><a id="aeb03955fdcbb03fa6eee98de4da8d355"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a)</td></tr>
<tr class="separator:aeb03955fdcbb03fa6eee98de4da8d355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c85cf9cc27a2f9ea69c28fed0243a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a8c85cf9cc27a2f9ea69c28fed0243a66">operator-</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a8c85cf9cc27a2f9ea69c28fed0243a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut function that allows to use arithmetic operator - with <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> (== shared_ptr&lt;Abstract&gt;).  <a href="#a8c85cf9cc27a2f9ea69c28fed0243a66">More...</a><br /></td></tr>
<tr class="separator:a8c85cf9cc27a2f9ea69c28fed0243a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51da3cbce74c766bb1aff63488113698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a51da3cbce74c766bb1aff63488113698">operator*</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a51da3cbce74c766bb1aff63488113698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut function that allows to use arithmetic operator * with <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> (== shared_ptr&lt;Abstract&gt;).  <a href="#a51da3cbce74c766bb1aff63488113698">More...</a><br /></td></tr>
<tr class="separator:a51da3cbce74c766bb1aff63488113698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e84d94b9caf4662aa30a5c6aa36a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a75e84d94b9caf4662aa30a5c6aa36a63">operator/</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a75e84d94b9caf4662aa30a5c6aa36a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut function that allows to use arithmetic operator / with <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> (== shared_ptr&lt;Abstract&gt;).  <a href="#a75e84d94b9caf4662aa30a5c6aa36a63">More...</a><br /></td></tr>
<tr class="separator:a75e84d94b9caf4662aa30a5c6aa36a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102a325a2f82091b8289d13e0b493d6b"><td class="memItemLeft" align="right" valign="top"><a id="a102a325a2f82091b8289d13e0b493d6b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;fout, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;obj)</td></tr>
<tr class="separator:a102a325a2f82091b8289d13e0b493d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52343b89158d08dc27aa4851ba1662c"><td class="memItemLeft" align="right" valign="top"><a id="ac52343b89158d08dc27aa4851ba1662c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ac52343b89158d08dc27aa4851ba1662c">operator==</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:ac52343b89158d08dc27aa4851ba1662c"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classcsl_1_1Abstract.html#a8334e14cd5789168b037d3888ed60edd">Abstract::operator==()</a> <br /></td></tr>
<tr class="separator:ac52343b89158d08dc27aa4851ba1662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fc26b671ec2e0fa84ba12983ed9866"><td class="memItemLeft" align="right" valign="top"><a id="a73fc26b671ec2e0fa84ba12983ed9866"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a73fc26b671ec2e0fa84ba12983ed9866">operator!=</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a73fc26b671ec2e0fa84ba12983ed9866"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classcsl_1_1Abstract.html#af5b62a6308638064c42da80e9cc2cb7e">Abstract::operator!=()</a> <br /></td></tr>
<tr class="separator:a73fc26b671ec2e0fa84ba12983ed9866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64388fa8d8a566d1b1b565f888acfaa5"><td class="memItemLeft" align="right" valign="top"><a id="a64388fa8d8a566d1b1b565f888acfaa5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a64388fa8d8a566d1b1b565f888acfaa5">operator&gt;=</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a64388fa8d8a566d1b1b565f888acfaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classcsl_1_1Abstract.html#a4c8883df19d7538b68fa96aadac9dfa9" title="Compares the simplicity of the expression to another. ">Abstract::operator&gt;=()</a> <br /></td></tr>
<tr class="separator:a64388fa8d8a566d1b1b565f888acfaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612503ed45700a00e76eccfd796bfec1"><td class="memItemLeft" align="right" valign="top"><a id="a612503ed45700a00e76eccfd796bfec1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a612503ed45700a00e76eccfd796bfec1">operator&lt;=</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a612503ed45700a00e76eccfd796bfec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="namespacecsl.html#a612503ed45700a00e76eccfd796bfec1" title="see Abstract::operator&lt;=() ">Abstract::operator&lt;=()</a> <br /></td></tr>
<tr class="separator:a612503ed45700a00e76eccfd796bfec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcf5895808d59f7113b9c9dc28133ca"><td class="memItemLeft" align="right" valign="top"><a id="abdcf5895808d59f7113b9c9dc28133ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#abdcf5895808d59f7113b9c9dc28133ca">operator&gt;</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:abdcf5895808d59f7113b9c9dc28133ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classcsl_1_1Abstract.html#a485c6f3e10db539a70416cd0766b117d" title="Compares the simplicity of the expression to another. ">Abstract::operator&gt;()</a> <br /></td></tr>
<tr class="separator:abdcf5895808d59f7113b9c9dc28133ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe8e8ea5d3a9880c2d95741728f8d1"><td class="memItemLeft" align="right" valign="top"><a id="a6dbe8e8ea5d3a9880c2d95741728f8d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a6dbe8e8ea5d3a9880c2d95741728f8d1">operator&lt;</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a6dbe8e8ea5d3a9880c2d95741728f8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classcsl_1_1Abstract.html#a5c1ba8dce7fbc19eb98807bd15a279c9" title="Compares the simplicity of the expression to another. ">Abstract::operator&lt;()</a> <br /></td></tr>
<tr class="separator:a6dbe8e8ea5d3a9880c2d95741728f8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187485362620c294cc6cf77f797d07a7"><td class="memItemLeft" align="right" valign="top"><a id="a187485362620c294cc6cf77f797d07a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a187485362620c294cc6cf77f797d07a7">operator|=</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:a187485362620c294cc6cf77f797d07a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="namespacecsl.html#a187485362620c294cc6cf77f797d07a7" title="see Abstract::operator|=() ">Abstract::operator|=()</a> <br /></td></tr>
<tr class="separator:a187485362620c294cc6cf77f797d07a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae272e1c0cc44174b9734bf989f8abdc0"><td class="memItemLeft" align="right" valign="top"><a id="ae272e1c0cc44174b9734bf989f8abdc0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae272e1c0cc44174b9734bf989f8abdc0">operator &amp;=</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:ae272e1c0cc44174b9734bf989f8abdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">see Abstract::operator&amp;=() <br /></td></tr>
<tr class="separator:ae272e1c0cc44174b9734bf989f8abdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25492ddb894bb646ca12868bbd5e54d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae25492ddb894bb646ca12868bbd5e54d">FindLeaf</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;value, size_t depth=-1)</td></tr>
<tr class="memdesc:ae25492ddb894bb646ca12868bbd5e54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches and returns an expression in another.  <a href="#ae25492ddb894bb646ca12868bbd5e54d">More...</a><br /></td></tr>
<tr class="separator:ae25492ddb894bb646ca12868bbd5e54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16030249dd9a145214dad11c6c698c75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a16030249dd9a145214dad11c6c698c75">FindNode</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;node, size_t depth=-1)</td></tr>
<tr class="memdesc:a16030249dd9a145214dad11c6c698c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches and returns an expression in another.  <a href="#a16030249dd9a145214dad11c6c698c75">More...</a><br /></td></tr>
<tr class="separator:a16030249dd9a145214dad11c6c698c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27562270e1babd293920469862804ddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a27562270e1babd293920469862804ddf">FindIfLeaf</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, size_t depth=-1)</td></tr>
<tr class="memdesc:a27562270e1babd293920469862804ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches and returns an expression in another.  <a href="#a27562270e1babd293920469862804ddf">More...</a><br /></td></tr>
<tr class="separator:a27562270e1babd293920469862804ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b277cdb6f9d098af7640035563e5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#af08b277cdb6f9d098af7640035563e5d">FindIfNode</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, size_t depth=-1)</td></tr>
<tr class="memdesc:af08b277cdb6f9d098af7640035563e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches and returns an expression in another.  <a href="#af08b277cdb6f9d098af7640035563e5d">More...</a><br /></td></tr>
<tr class="separator:af08b277cdb6f9d098af7640035563e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c725982c603dc7243b94238c7399f17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a0c725982c603dc7243b94238c7399f17">AnyOfLeafs</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:a0c725982c603dc7243b94238c7399f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if any of the leafs of an expression respect a certain condition given by the user.  <a href="#a0c725982c603dc7243b94238c7399f17">More...</a><br /></td></tr>
<tr class="separator:a0c725982c603dc7243b94238c7399f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a2cd4c367b6cf036df7d37a4e9f100"><td class="memItemLeft" align="right" valign="top"><a id="a03a2cd4c367b6cf036df7d37a4e9f100"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AnyOfLeafs</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> init, std::function&lt; bool(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:a03a2cd4c367b6cf036df7d37a4e9f100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34e46d9db1bf2c52a11e16edb96aac9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ab34e46d9db1bf2c52a11e16edb96aac9">AllOfLeafs</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:ab34e46d9db1bf2c52a11e16edb96aac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if all of the leafs of an expression respect a certain condition given by the user.  <a href="#ab34e46d9db1bf2c52a11e16edb96aac9">More...</a><br /></td></tr>
<tr class="separator:ab34e46d9db1bf2c52a11e16edb96aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abf41f31ccb20d80806248755572aa2"><td class="memItemLeft" align="right" valign="top"><a id="a2abf41f31ccb20d80806248755572aa2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AllOfLeafs</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> init, std::function&lt; bool(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:a2abf41f31ccb20d80806248755572aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fb7f5bf59e525f167e3e5e1bea6ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aee4fb7f5bf59e525f167e3e5e1bea6ed">AnyOfNodes</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:aee4fb7f5bf59e525f167e3e5e1bea6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if any of the nodes of an expression respect a certain condition given by the user.  <a href="#aee4fb7f5bf59e525f167e3e5e1bea6ed">More...</a><br /></td></tr>
<tr class="separator:aee4fb7f5bf59e525f167e3e5e1bea6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83be4cbb3059d337eddcc13f707c727a"><td class="memItemLeft" align="right" valign="top"><a id="a83be4cbb3059d337eddcc13f707c727a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AnyOfNodes</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> init, std::function&lt; bool(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:a83be4cbb3059d337eddcc13f707c727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a09c25d95caf5531f593f5e8a92cc99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a2a09c25d95caf5531f593f5e8a92cc99">AllOfNodes</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:a2a09c25d95caf5531f593f5e8a92cc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if all of the nodes of an expression respect a certain condition given by the user.  <a href="#a2a09c25d95caf5531f593f5e8a92cc99">More...</a><br /></td></tr>
<tr class="separator:a2a09c25d95caf5531f593f5e8a92cc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde0e90e4c4a550132b89d7f80d697c"><td class="memItemLeft" align="right" valign="top"><a id="a3bde0e90e4c4a550132b89d7f80d697c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AllOfNodes</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> init, std::function&lt; bool(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:a3bde0e90e4c4a550132b89d7f80d697c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32d8a121c108b533a4e746a10d737ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ab32d8a121c108b533a4e746a10d737ba">VisitEachNode</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:ab32d8a121c108b533a4e746a10d737ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits all nodes of an expression, applying a function on it without modifying it.  <a href="#ab32d8a121c108b533a4e746a10d737ba">More...</a><br /></td></tr>
<tr class="separator:ab32d8a121c108b533a4e746a10d737ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb55178a1546dc71b733694f9b5dc57b"><td class="memItemLeft" align="right" valign="top"><a id="acb55178a1546dc71b733694f9b5dc57b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VisitEachNodeReversed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:acb55178a1546dc71b733694f9b5dc57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179203c55f9ad0e035d9e189c84856c9"><td class="memItemLeft" align="right" valign="top"><a id="a179203c55f9ad0e035d9e189c84856c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VisitEachNode</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> init, std::function&lt; void(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:a179203c55f9ad0e035d9e189c84856c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795b923fd042a73265a04f5fa551362b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a795b923fd042a73265a04f5fa551362b">VisitEachLeaf</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:a795b923fd042a73265a04f5fa551362b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits all leafs of an expression, applying a function on it without modifying it.  <a href="#a795b923fd042a73265a04f5fa551362b">More...</a><br /></td></tr>
<tr class="separator:a795b923fd042a73265a04f5fa551362b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7167d70d54cceabf9909a3307f5aaf8"><td class="memItemLeft" align="right" valign="top"><a id="ac7167d70d54cceabf9909a3307f5aaf8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VisitEachLeaf</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> init, std::function&lt; void(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:ac7167d70d54cceabf9909a3307f5aaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb7fdd6c18bd8a98bfa3674e4bebefb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#abfb7fdd6c18bd8a98bfa3674e4bebefb">VisitEachNodeCut</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:abfb7fdd6c18bd8a98bfa3674e4bebefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits all nodes of an expression, applying a function on it without modifying it. When the user function returns true on one node, the underlying branch (if there is) is not explored.  <a href="#abfb7fdd6c18bd8a98bfa3674e4bebefb">More...</a><br /></td></tr>
<tr class="separator:abfb7fdd6c18bd8a98bfa3674e4bebefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f08ba8bd4e51d6b4cb729f1e9a6ebc"><td class="memItemLeft" align="right" valign="top"><a id="a87f08ba8bd4e51d6b4cb729f1e9a6ebc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VisitEachNodeCut</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> init, std::function&lt; bool(<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:a87f08ba8bd4e51d6b4cb729f1e9a6ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab79a115fe13684aa9e8a242d694c2e"><td class="memItemLeft" align="right" valign="top"><a id="a2ab79a115fe13684aa9e8a242d694c2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isUnique</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a2ab79a115fe13684aa9e8a242d694c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b43fd79b22d4b6f70c7d3cdfbdfa72"><td class="memItemLeft" align="right" valign="top"><a id="a43b43fd79b22d4b6f70c7d3cdfbdfa72"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;search)</td></tr>
<tr class="separator:a43b43fd79b22d4b6f70c7d3cdfbdfa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098cbe648edc96f8f3ea4a51e2523355"><td class="memItemLeft" align="right" valign="top"><a id="a098cbe648edc96f8f3ea4a51e2523355"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>CountIf</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;)&gt; const &amp;f)</td></tr>
<tr class="separator:a098cbe648edc96f8f3ea4a51e2523355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdfd4deca9af45148ef80e0131fde7c"><td class="memItemLeft" align="right" valign="top"><a id="a2fdfd4deca9af45148ef80e0131fde7c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>CountNodes</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init)</td></tr>
<tr class="separator:a2fdfd4deca9af45148ef80e0131fde7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fbbfa111563d02abbe3b451e61d5d7"><td class="memItemLeft" align="right" valign="top"><a id="a48fbbfa111563d02abbe3b451e61d5d7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>CountLeafs</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init)</td></tr>
<tr class="separator:a48fbbfa111563d02abbe3b451e61d5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbe21d8979e1d4fa2e9242a34c397be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a8bbe21d8979e1d4fa2e9242a34c397be">ForEachNode</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:a8bbe21d8979e1d4fa2e9242a34c397be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user function on each node of an expression. The expression may be modified.  <a href="#a8bbe21d8979e1d4fa2e9242a34c397be">More...</a><br /></td></tr>
<tr class="separator:a8bbe21d8979e1d4fa2e9242a34c397be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffc009aac609d68939ab3c6e8b74e4d"><td class="memItemLeft" align="right" valign="top"><a id="a6ffc009aac609d68939ab3c6e8b74e4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ForEachNodeReversed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="separator:a6ffc009aac609d68939ab3c6e8b74e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74bfbc9faa2de7d49f5d37403795b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#af74bfbc9faa2de7d49f5d37403795b73">ForEachLeaf</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:af74bfbc9faa2de7d49f5d37403795b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user function on each leaf of an expression. The expression may be modified.  <a href="#af74bfbc9faa2de7d49f5d37403795b73">More...</a><br /></td></tr>
<tr class="separator:af74bfbc9faa2de7d49f5d37403795b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1844d0ef7e9f50ccd490096c4f1ff21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#af1844d0ef7e9f50ccd490096c4f1ff21">ForEachNodeCut</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:af1844d0ef7e9f50ccd490096c4f1ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user function on each node of an expression. The expression may be modified.  <a href="#af1844d0ef7e9f50ccd490096c4f1ff21">More...</a><br /></td></tr>
<tr class="separator:af1844d0ef7e9f50ccd490096c4f1ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe86be4e2295c35823a965faf12bb0c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#abe86be4e2295c35823a965faf12bb0c7">FirstOfNode</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f)</td></tr>
<tr class="memdesc:abe86be4e2295c35823a965faf12bb0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if any of the nodes of an expression respect a certain condition given by the user. The condition function may apply on the go on the expression found.  <a href="#abe86be4e2295c35823a965faf12bb0c7">More...</a><br /></td></tr>
<tr class="separator:abe86be4e2295c35823a965faf12bb0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f72de45510b266cb259a69d11cbf14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#af9f72de45510b266cb259a69d11cbf14">FirstOfLeaf</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f)</td></tr>
<tr class="memdesc:af9f72de45510b266cb259a69d11cbf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if any of the leafs of an expression respect a certain condition given by the user. The condition function may apply on the go on the expression found.  <a href="#af9f72de45510b266cb259a69d11cbf14">More...</a><br /></td></tr>
<tr class="separator:af9f72de45510b266cb259a69d11cbf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3c68b0e699dd64609a968ea0556b64"><td class="memItemLeft" align="right" valign="top"><a id="add3c68b0e699dd64609a968ea0556b64"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>VisitFirstOfNode</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f)</td></tr>
<tr class="separator:add3c68b0e699dd64609a968ea0556b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705f9b5d9ecdebdc35d89cf30fab41cb"><td class="memItemLeft" align="right" valign="top"><a id="a705f9b5d9ecdebdc35d89cf30fab41cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>VisitFirstOfLeaf</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f)</td></tr>
<tr class="separator:a705f9b5d9ecdebdc35d89cf30fab41cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0af68b54eefa2d567faed146678ad7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aba0af68b54eefa2d567faed146678ad7">Transform</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f, int depth=-1)</td></tr>
<tr class="memdesc:aba0af68b54eefa2d567faed146678ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a user function on each node of an expression. The expression may be modified. If it is, the expression is refreshed.  <a href="#aba0af68b54eefa2d567faed146678ad7">More...</a><br /></td></tr>
<tr class="separator:aba0af68b54eefa2d567faed146678ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a40797aed2b68368ac965b414d7b4bf"><td class="memTemplParams" colspan="2"><a id="a0a40797aed2b68368ac965b414d7b4bf"></a>
template&lt;class T , csl::allocator&lt; T &gt; &amp; pool, class ... Args&gt; </td></tr>
<tr class="memitem:a0a40797aed2b68368ac965b414d7b4bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shared</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a0a40797aed2b68368ac965b414d7b4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6f76494e3aaec92c325db107c2573b"><td class="memTemplParams" colspan="2"><a id="a5e6f76494e3aaec92c325db107c2573b"></a>
template&lt;class T , class ... Args&gt; </td></tr>
<tr class="memitem:a5e6f76494e3aaec92c325db107c2573b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_shared</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a5e6f76494e3aaec92c325db107c2573b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522b81a0fa7f75a9a3fc2c8ed87f77b0"><td class="memTemplParams" colspan="2"><a id="a522b81a0fa7f75a9a3fc2c8ed87f77b0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a522b81a0fa7f75a9a3fc2c8ed87f77b0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pointer_to_object</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a522b81a0fa7f75a9a3fc2c8ed87f77b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739a591a43bac317c4b608f4bd448c20"><td class="memTemplParams" colspan="2"><a id="a739a591a43bac317c4b608f4bd448c20"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a739a591a43bac317c4b608f4bd448c20"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pointer_to_object_ref</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a739a591a43bac317c4b608f4bd448c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586bbc506eb1cbb96b3c916fce1d763a"><td class="memTemplParams" colspan="2"><a id="a586bbc506eb1cbb96b3c916fce1d763a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a586bbc506eb1cbb96b3c916fce1d763a"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shared_to_raw_ptr</b> (const <a class="el" href="classstd_1_1shared__ptr.html">Expr_c</a> &amp;expr)</td></tr>
<tr class="separator:a586bbc506eb1cbb96b3c916fce1d763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c56f082158a750761820590c87182d"><td class="memTemplParams" colspan="2"><a id="ae8c56f082158a750761820590c87182d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8c56f082158a750761820590c87182d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>object_to_shared</b> (T &amp;csl_expr)</td></tr>
<tr class="separator:ae8c56f082158a750761820590c87182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15620d82e51a1ba2c082a0b17ed773d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a15620d82e51a1ba2c082a0b17ed773d0">Commutation</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;A, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;B, int sign=-1)</td></tr>
<tr class="memdesc:a15620d82e51a1ba2c082a0b17ed773d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of the (anit-)commutation of <b>A</b> and <b>B</b>. In most cases it returns CSL_0, and returns CSL_UNDEF else. Useful to test if two objects commute.  <a href="#a15620d82e51a1ba2c082a0b17ed773d0">More...</a><br /></td></tr>
<tr class="separator:a15620d82e51a1ba2c082a0b17ed773d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadbfda4c4ea42b3a8510a467b4a7b8d"><td class="memItemLeft" align="right" valign="top"><a id="adadbfda4c4ea42b3a8510a467b4a7b8d"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Commutation</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> A, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B, int sign=-1)</td></tr>
<tr class="separator:adadbfda4c4ea42b3a8510a467b4a7b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82c5a52247dd5ef84518d51deade500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ab82c5a52247dd5ef84518d51deade500">WeakCommutation</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;A, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;B, int sign=-1)</td></tr>
<tr class="memdesc:ab82c5a52247dd5ef84518d51deade500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of the (anit-)commutation of <b>A</b> and <b>B</b>. In most cases it returns CSL_0, and returns CSL_UNDEF else. Useful to test if two objects commute. In the special of this function, <b>A</b> is an object that is not commutable (attribute Abstract::commutable) and <b>B</b> is commutable.  <a href="#ab82c5a52247dd5ef84518d51deade500">More...</a><br /></td></tr>
<tr class="separator:ab82c5a52247dd5ef84518d51deade500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fc9dab5d4f335d30e3ad383fcf546a"><td class="memItemLeft" align="right" valign="top"><a id="af9fc9dab5d4f335d30e3ad383fcf546a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WeakCommutation</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> A, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> B, int sign=-1)</td></tr>
<tr class="separator:af9fc9dab5d4f335d30e3ad383fcf546a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa314ac9077b2d18a81fa954327ab7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#afa314ac9077b2d18a81fa954327ab7e0">commutator_</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;A, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;B, int t_sign=-1)</td></tr>
<tr class="memdesc:afa314ac9077b2d18a81fa954327ab7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to create a <a class="el" href="classcsl_1_1Commutator.html" title="Object that represents a commutator or an anti-commutator, thus is derived from AbstractDuoFunc that ...">Commutator</a> object of <b>A</b> and <b>B</b> of sign <b>sign</b>.  <a href="#afa314ac9077b2d18a81fa954327ab7e0">More...</a><br /></td></tr>
<tr class="separator:afa314ac9077b2d18a81fa954327ab7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca518d3d156e148b3068c5b798ba1482"><td class="memItemLeft" align="right" valign="top"><a id="aca518d3d156e148b3068c5b798ba1482"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>real_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:aca518d3d156e148b3068c5b798ba1482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79d8ae0341a0930abaa513affc9dde0"><td class="memItemLeft" align="right" valign="top"><a id="af79d8ae0341a0930abaa513affc9dde0"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>imaginary_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:af79d8ae0341a0930abaa513affc9dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11d004a0fbfd2cf7d41c1aebfbb5c1d"><td class="memItemLeft" align="right" valign="top"><a id="aa11d004a0fbfd2cf7d41c1aebfbb5c1d"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cconjugate_</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:aa11d004a0fbfd2cf7d41c1aebfbb5c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69cdb1c6ddfa666c766cd2edf66823e"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Comparator &gt; </td></tr>
<tr class="memitem:ae69cdb1c6ddfa666c766cd2edf66823e"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae69cdb1c6ddfa666c766cd2edf66823e">dichotomyFindIf</a> (Iterator first, Iterator last, <a class="el" href="classcsl_1_1Comparator.html">Comparator</a> &amp;&amp;f)</td></tr>
<tr class="memdesc:ae69cdb1c6ddfa666c766cd2edf66823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template dichotomy algorithm using a comparator.  <a href="#ae69cdb1c6ddfa666c766cd2edf66823e">More...</a><br /></td></tr>
<tr class="separator:ae69cdb1c6ddfa666c766cd2edf66823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68e55a1e260433cbafab69addbb53c4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ad68e55a1e260433cbafab69addbb53c4">operator&lt;&lt;</a> (std::ostream &amp;fout, <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a> type)</td></tr>
<tr class="memdesc:ad68e55a1e260433cbafab69addbb53c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the name of a given <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312" title="Enum of the different types of Abstract (i.e. list of all possible specializations). ">csl::Type</a> in order to be readable.  <a href="#ad68e55a1e260433cbafab69addbb53c4">More...</a><br /></td></tr>
<tr class="separator:ad68e55a1e260433cbafab69addbb53c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073cd06df1b6c4e0efb497d67d87e275"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a073cd06df1b6c4e0efb497d67d87e275">operator&lt;&lt;</a> (std::ostream &amp;fout, <a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a> primaryType)</td></tr>
<tr class="memdesc:a073cd06df1b6c4e0efb497d67d87e275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the name of a given <a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54" title="Stores enumerations of types for Abstract objects. ">csl::PrimaryType</a> in order to be readable.  <a href="#a073cd06df1b6c4e0efb497d67d87e275">More...</a><br /></td></tr>
<tr class="separator:a073cd06df1b6c4e0efb497d67d87e275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1979d6285c85c34fa77910ded6b0af"><td class="memItemLeft" align="right" valign="top"><a id="a7d1979d6285c85c34fa77910ded6b0af"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;fout, cslEquation::Type type)</td></tr>
<tr class="separator:a7d1979d6285c85c34fa77910ded6b0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68227f9e920a13e5c7e4160e96b5fee2"><td class="memItemLeft" align="right" valign="top"><a id="a68227f9e920a13e5c7e4160e96b5fee2"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>listBuildingBlocks</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a68227f9e920a13e5c7e4160e96b5fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b531bee2282789c44482b3b5e19188"><td class="memItemLeft" align="right" valign="top"><a id="ae7b531bee2282789c44482b3b5e19188"></a>
<a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>equation_</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftHandSide)</td></tr>
<tr class="separator:ae7b531bee2282789c44482b3b5e19188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3907c56af20ae32136c5cc822351744c"><td class="memItemLeft" align="right" valign="top"><a id="a3907c56af20ae32136c5cc822351744c"></a>
<a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>equation_</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;leftHandSide, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;rightHandSide)</td></tr>
<tr class="separator:a3907c56af20ae32136c5cc822351744c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba56b2d781a7338561e1b8d3276bc2de"><td class="memItemLeft" align="right" valign="top"><a id="aba56b2d781a7338561e1b8d3276bc2de"></a>
<a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>equation_</b> (const <a class="el" href="classcsl_1_1Equation.html">Equation</a> &amp;eq)</td></tr>
<tr class="separator:aba56b2d781a7338561e1b8d3276bc2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161c5a19b63bd1c37afb67f7d93adc2e"><td class="memItemLeft" align="right" valign="top"><a id="a161c5a19b63bd1c37afb67f7d93adc2e"></a>
<a class="el" href="classcsl_1_1Equation.html">Equation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>equation_</b> (<a class="el" href="classcsl_1_1Equation.html">Equation</a> *eq)</td></tr>
<tr class="separator:a161c5a19b63bd1c37afb67f7d93adc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8abdf8d030cb99598167b606155f71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c8abdf8d030cb99598167b606155f71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a9c8abdf8d030cb99598167b606155f71">callError</a> (<a class="el" href="error_8h.html#aa8b83bc17cf1d066a01fa3d6fb741db2">cslError::Error</a> error, const std::string &amp;caller, T spec)</td></tr>
<tr class="memdesc:a9c8abdf8d030cb99598167b606155f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays an error message depending on the error <b>error</b>, the name of the caller function <b>caller</b> and a possible specificity of the error <b>spec</b>. For example spec is the index for OutOfBound error. This function stops the program.  <a href="#a9c8abdf8d030cb99598167b606155f71">More...</a><br /></td></tr>
<tr class="separator:a9c8abdf8d030cb99598167b606155f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2833e46d2e34ebdbc616118fb05c6c8"><td class="memItemLeft" align="right" valign="top"><a id="af2833e46d2e34ebdbc616118fb05c6c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#af2833e46d2e34ebdbc616118fb05c6c8">callError</a> (<a class="el" href="error_8h.html#aa8b83bc17cf1d066a01fa3d6fb741db2">cslError::Error</a> error, const std::string &amp;caller)</td></tr>
<tr class="memdesc:af2833e46d2e34ebdbc616118fb05c6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="namespacecsl.html#a9c8abdf8d030cb99598167b606155f71" title="Displays an error message depending on the error error, the name of the caller function caller and a ...">callError(cslError::Error, const std::string&amp;,T)</a> with no spec. <br /></td></tr>
<tr class="separator:af2833e46d2e34ebdbc616118fb05c6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d537409ca487db900cc76d286441569"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d537409ca487db900cc76d286441569"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a8d537409ca487db900cc76d286441569">callWarning</a> (<a class="el" href="error_8h.html#a77055542ac61002c0db1fbd7e4413c84">cslError::Warning</a> warning, const std::string &amp;caller, T spec)</td></tr>
<tr class="memdesc:a8d537409ca487db900cc76d286441569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a warning message depending on the warning <b>warning</b>, the name of the caller function <b>caller</b> and a possible specificity of the warning <b>spec</b>. For example spec is the dimension for InvalidDimension error. This function does not stop the program.  <a href="#a8d537409ca487db900cc76d286441569">More...</a><br /></td></tr>
<tr class="separator:a8d537409ca487db900cc76d286441569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc55ac80542f4378b1d18a8cc311681"><td class="memItemLeft" align="right" valign="top"><a id="a1fc55ac80542f4378b1d18a8cc311681"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>matchBOnA</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;A, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;B)</td></tr>
<tr class="separator:a1fc55ac80542f4378b1d18a8cc311681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fe0bcd5da6dcbfb405c42d9aa5e15f"><td class="memItemLeft" align="right" valign="top"><a id="a03fe0bcd5da6dcbfb405c42d9aa5e15f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hardComparison</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;)</td></tr>
<tr class="separator:a03fe0bcd5da6dcbfb405c42d9aa5e15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb063f5989b1e49bda5582eb0ad4ca7b"><td class="memItemLeft" align="right" valign="top"><a id="afb063f5989b1e49bda5582eb0ad4ca7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hardOrdering</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;)</td></tr>
<tr class="separator:afb063f5989b1e49bda5582eb0ad4ca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431a7d395c7c1d152fa03892ad8289e1"><td class="memItemLeft" align="right" valign="top"><a id="a431a7d395c7c1d152fa03892ad8289e1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HardFactorImplementation</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;sum, bool applyRecursively=true)</td></tr>
<tr class="separator:a431a7d395c7c1d152fa03892ad8289e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c92123131d8e5fb5e17af2737862aa"><td class="memItemLeft" align="right" valign="top"><a id="af6c92123131d8e5fb5e17af2737862aa"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HardFactored</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init)</td></tr>
<tr class="separator:af6c92123131d8e5fb5e17af2737862aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab958cdded2d2629a922694b0ae6694a7"><td class="memItemLeft" align="right" valign="top"><a id="ab958cdded2d2629a922694b0ae6694a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HardFactor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init)</td></tr>
<tr class="separator:ab958cdded2d2629a922694b0ae6694a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3375a7f7f29dced30eb695bd11b2df"><td class="memItemLeft" align="right" valign="top"><a id="a6a3375a7f7f29dced30eb695bd11b2df"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepHardFactored</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init)</td></tr>
<tr class="separator:a6a3375a7f7f29dced30eb695bd11b2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad242ca3c0cdb63e3d5c495e3fb73b5d8"><td class="memItemLeft" align="right" valign="top"><a id="ad242ca3c0cdb63e3d5c495e3fb73b5d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepHardFactor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init)</td></tr>
<tr class="separator:ad242ca3c0cdb63e3d5c495e3fb73b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a1e87e4436c3df942585e9485222e8"><td class="memItemLeft" align="right" valign="top"><a id="ac2a1e87e4436c3df942585e9485222e8"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>integerToIndices</b> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:ac2a1e87e4436c3df942585e9485222e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7239c266a7391f8a652b83e65d927f4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a7239c266a7391f8a652b83e65d927f4a">operator!</a> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index)</td></tr>
<tr class="memdesc:a7239c266a7391f8a652b83e65d927f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator!, unary operator on <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> that change the free property of the <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a>.  <a href="#a7239c266a7391f8a652b83e65d927f4a">More...</a><br /></td></tr>
<tr class="separator:a7239c266a7391f8a652b83e65d927f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8258f8706933e1c10c973c721cd6151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae8258f8706933e1c10c973c721cd6151">operator+</a> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index)</td></tr>
<tr class="memdesc:ae8258f8706933e1c10c973c721cd6151"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator+, unary operator on <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> that returns a similar <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> with sign = 1 if the <a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> is signed, i.e. an <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> up.  <a href="#ae8258f8706933e1c10c973c721cd6151">More...</a><br /></td></tr>
<tr class="separator:ae8258f8706933e1c10c973c721cd6151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa060a7f29c77b51682733901c7a24d04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aa060a7f29c77b51682733901c7a24d04">operator-</a> (const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index)</td></tr>
<tr class="memdesc:aa060a7f29c77b51682733901c7a24d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator-, unary operator on <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> that returns a similar <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> with sign = 0 if the <a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> is signed, i.e. an <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> down.  <a href="#aa060a7f29c77b51682733901c7a24d04">More...</a><br /></td></tr>
<tr class="separator:aa060a7f29c77b51682733901c7a24d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad320dbb2a1c89bab6ccc90a65e776e3e"><td class="memItemLeft" align="right" valign="top"><a id="ad320dbb2a1c89bab6ccc90a65e776e3e"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>getAllPermutations</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:ad320dbb2a1c89bab6ccc90a65e776e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cee8efb7187b100a37dc857096e6da"><td class="memTemplParams" colspan="2"><a id="a38cee8efb7187b100a37dc857096e6da"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a38cee8efb7187b100a37dc857096e6da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classcsl_1_1TensorParent.html">TensorParent</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tensor_s</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a38cee8efb7187b100a37dc857096e6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356412161decac7e7591a45e21d5e8ad"><td class="memTemplParams" colspan="2"><a id="a356412161decac7e7591a45e21d5e8ad"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a356412161decac7e7591a45e21d5e8ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classcsl_1_1TensorParent.html">TensorParent</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tensor_s</b> (std::string const &amp;name, std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; const &amp;indices, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a356412161decac7e7591a45e21d5e8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c61455b984d412ce5d329cc2d83065"><td class="memTemplParams" colspan="2"><a id="aa3c61455b984d412ce5d329cc2d83065"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aa3c61455b984d412ce5d329cc2d83065"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tensorelement_s</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:aa3c61455b984d412ce5d329cc2d83065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f97f44b1543ac4151d41d6c4a89e20"><td class="memItemLeft" align="right" valign="top"><a id="a08f97f44b1543ac4151d41d6c4a89e20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIndicialTensor</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a08f97f44b1543ac4151d41d6c4a89e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8580c64c7331dd2ea20f976fb57c81"><td class="memItemLeft" align="right" valign="top"><a id="acd8580c64c7331dd2ea20f976fb57c81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIndicialTensor</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:acd8580c64c7331dd2ea20f976fb57c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17fb7de179f8643818e2eb85c4adda8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ab17fb7de179f8643818e2eb85c4adda8">nameTensor</a> (const std::string &amp;name, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;tensor, bool first=true)</td></tr>
<tr class="memdesc:ab17fb7de179f8643818e2eb85c4adda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an tensor with variables of the same name with the numbers correponding to their place in the tensor. Allows for example to name elements of a vector <img class="formulaInl" alt="$ V $" src="form_33.png"/>: <img class="formulaInl" alt="$ \left( V_0,V_1,V_2,V_3\right)$" src="form_34.png"/>.  <a href="#ab17fb7de179f8643818e2eb85c4adda8">More...</a><br /></td></tr>
<tr class="separator:ab17fb7de179f8643818e2eb85c4adda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0f20d9be8ac9b5c26fdcbbcc74dfaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aea0f20d9be8ac9b5c26fdcbbcc74dfaf">generateTensor</a> (const std::string &amp;name, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces)</td></tr>
<tr class="memdesc:aea0f20d9be8ac9b5c26fdcbbcc74dfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a tensor of name <b>name</b> that lives in a list of spaces, filled with variables given by <a class="el" href="namespacecsl.html#ab17fb7de179f8643818e2eb85c4adda8" title="Fills an tensor with variables of the same name with the numbers correponding to their place in the t...">nameTensor()</a>.  <a href="#aea0f20d9be8ac9b5c26fdcbbcc74dfaf">More...</a><br /></td></tr>
<tr class="separator:aea0f20d9be8ac9b5c26fdcbbcc74dfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b3631b21546c09b91f2babd823660f"><td class="memTemplParams" colspan="2"><a id="aa9b3631b21546c09b91f2babd823660f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa9b3631b21546c09b91f2babd823660f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetType</b> (T const &amp;expr)</td></tr>
<tr class="separator:aa9b3631b21546c09b91f2babd823660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3ff0e0c474bc013652a749e30491a0"><td class="memTemplParams" colspan="2"><a id="a8d3ff0e0c474bc013652a749e30491a0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8d3ff0e0c474bc013652a749e30491a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetPrimaryType</b> (T const &amp;expr)</td></tr>
<tr class="separator:a8d3ff0e0c474bc013652a749e30491a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341d589a60a69404eb57fab4633cacf3"><td class="memItemLeft" align="right" valign="top"><a id="a341d589a60a69404eb57fab4633cacf3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>Size</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a341d589a60a69404eb57fab4633cacf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482a3d629e32a1f4c1d77061ed8a926f"><td class="memItemLeft" align="right" valign="top"><a id="a482a3d629e32a1f4c1d77061ed8a926f"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetArgument</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr, size_t pos=0)</td></tr>
<tr class="separator:a482a3d629e32a1f4c1d77061ed8a926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29edb0599112f8a51a4663822109ae01"><td class="memItemLeft" align="right" valign="top"><a id="a29edb0599112f8a51a4663822109ae01"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetCommutable</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a29edb0599112f8a51a4663822109ae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e7e8980e5c268081628a2bbd2c2ba5"><td class="memItemLeft" align="right" valign="top"><a id="af7e7e8980e5c268081628a2bbd2c2ba5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetCommutable</b> (<a class="el" href="classcsl_1_1Abstract.html">csl::Expr_info</a> expr)</td></tr>
<tr class="separator:af7e7e8980e5c268081628a2bbd2c2ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dd7393b10cc0906bca3c425a8e2178"><td class="memItemLeft" align="right" valign="top"><a id="aa8dd7393b10cc0906bca3c425a8e2178"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetCommutable</b> (<a class="el" href="classcsl_1_1Abstract.html">csl::Abstract</a> const &amp;expr)</td></tr>
<tr class="separator:aa8dd7393b10cc0906bca3c425a8e2178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cba002dbb691fe0c9b1c496e0d41706"><td class="memItemLeft" align="right" valign="top"><a id="a2cba002dbb691fe0c9b1c496e0d41706"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetSymbol</b> (std::string_view name, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init)</td></tr>
<tr class="separator:a2cba002dbb691fe0c9b1c496e0d41706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63350b46f1d9c1bba3ad6f086bbe9463"><td class="memItemLeft" align="right" valign="top"><a id="a63350b46f1d9c1bba3ad6f086bbe9463"></a>
<a class="el" href="classcsl_1_1Parent.html">Parent</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetParent</b> (std::string_view name, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init)</td></tr>
<tr class="separator:a63350b46f1d9c1bba3ad6f086bbe9463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9758f4749012992f37a81d7e7f5ff1"><td class="memItemLeft" align="right" valign="top"><a id="afb9758f4749012992f37a81d7e7f5ff1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DependsOn</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;x)</td></tr>
<tr class="separator:afb9758f4749012992f37a81d7e7f5ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422849a21824a75cd0fb220b8f8e4909"><td class="memItemLeft" align="right" valign="top"><a id="a422849a21824a75cd0fb220b8f8e4909"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DependsExplicitlyOn</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;x)</td></tr>
<tr class="separator:a422849a21824a75cd0fb220b8f8e4909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5083ece2c4e357494999031377e94380"><td class="memItemLeft" align="right" valign="top"><a id="a5083ece2c4e357494999031377e94380"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DependsOn</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> const &amp;x)</td></tr>
<tr class="separator:a5083ece2c4e357494999031377e94380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9147a9a8c0b92c75c945d8f05381cc"><td class="memItemLeft" align="right" valign="top"><a id="a4a9147a9a8c0b92c75c945d8f05381cc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DependsExplicitlyOn</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> const &amp;x)</td></tr>
<tr class="separator:a4a9147a9a8c0b92c75c945d8f05381cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5472b4e9c9fb0998a0a8a0b15cc00f8e"><td class="memItemLeft" align="right" valign="top"><a id="a5472b4e9c9fb0998a0a8a0b15cc00f8e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Expand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, bool full=false, bool inplace=false)</td></tr>
<tr class="separator:a5472b4e9c9fb0998a0a8a0b15cc00f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091552cbd1807518647256c45a529852"><td class="memItemLeft" align="right" valign="top"><a id="a091552cbd1807518647256c45a529852"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Expanded</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, bool full=false, bool inplace=false)</td></tr>
<tr class="separator:a091552cbd1807518647256c45a529852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97846f6299e3eb1c15af93a1020080d"><td class="memItemLeft" align="right" valign="top"><a id="aa97846f6299e3eb1c15af93a1020080d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ExpandIf</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, bool full=false, bool inplace=false)</td></tr>
<tr class="separator:aa97846f6299e3eb1c15af93a1020080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13966c5debc0b3d689f63ec3a9deb7e5"><td class="memItemLeft" align="right" valign="top"><a id="a13966c5debc0b3d689f63ec3a9deb7e5"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ExpandedIf</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, bool full=false, bool inplace=false)</td></tr>
<tr class="separator:a13966c5debc0b3d689f63ec3a9deb7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4c329210a2483aa1eaf3f3469a3167"><td class="memItemLeft" align="right" valign="top"><a id="afd4c329210a2483aa1eaf3f3469a3167"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, bool inplace=false)</td></tr>
<tr class="separator:afd4c329210a2483aa1eaf3f3469a3167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b240c02119affaf20698ba373dba35"><td class="memItemLeft" align="right" valign="top"><a id="ac0b240c02119affaf20698ba373dba35"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepExpanded</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, bool inplace=false)</td></tr>
<tr class="separator:ac0b240c02119affaf20698ba373dba35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82647f36d65a0c38a98a2a0fed8756c2"><td class="memItemLeft" align="right" valign="top"><a id="a82647f36d65a0c38a98a2a0fed8756c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepExpandIf</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, bool inplace=false)</td></tr>
<tr class="separator:a82647f36d65a0c38a98a2a0fed8756c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1254126d4d45678acf1d1ae6d37026e"><td class="memItemLeft" align="right" valign="top"><a id="ae1254126d4d45678acf1d1ae6d37026e"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepExpandedIf</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, bool inplace=false)</td></tr>
<tr class="separator:ae1254126d4d45678acf1d1ae6d37026e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb313dddfd9e007ac7d0ef239c2b967f"><td class="memItemLeft" align="right" valign="top"><a id="aeb313dddfd9e007ac7d0ef239c2b967f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepExpandIf_lock</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int lockId=0, bool inplace=false, bool refactor=false)</td></tr>
<tr class="separator:aeb313dddfd9e007ac7d0ef239c2b967f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc8b20e4d33005fa6f3e0378a1a9781"><td class="memItemLeft" align="right" valign="top"><a id="abcc8b20e4d33005fa6f3e0378a1a9781"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepExpandedIf_lock</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;f, int lockId=0, bool inplace=false, bool refactor=false)</td></tr>
<tr class="separator:abcc8b20e4d33005fa6f3e0378a1a9781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa93f7ce0d99dac2a03025ea9ebacb"><td class="memItemLeft" align="right" valign="top"><a id="a01aa93f7ce0d99dac2a03025ea9ebacb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Factor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, bool full=false)</td></tr>
<tr class="separator:a01aa93f7ce0d99dac2a03025ea9ebacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac429e94b692f3c1327d82e5f9b26c8bd"><td class="memItemLeft" align="right" valign="top"><a id="ac429e94b692f3c1327d82e5f9b26c8bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Factor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor, bool full=false)</td></tr>
<tr class="separator:ac429e94b692f3c1327d82e5f9b26c8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b76b9fb6118f082652bceba66ccc49"><td class="memItemLeft" align="right" valign="top"><a id="a03b76b9fb6118f082652bceba66ccc49"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Factor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;factor, bool full=false)</td></tr>
<tr class="separator:a03b76b9fb6118f082652bceba66ccc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32b8616d7957c24edec2c36848ab3ea"><td class="memItemLeft" align="right" valign="top"><a id="aa32b8616d7957c24edec2c36848ab3ea"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Factored</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, bool full=false)</td></tr>
<tr class="separator:aa32b8616d7957c24edec2c36848ab3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3977959763a376c44f54755bc79b42b2"><td class="memItemLeft" align="right" valign="top"><a id="a3977959763a376c44f54755bc79b42b2"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Factored</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor, bool full=false)</td></tr>
<tr class="separator:a3977959763a376c44f54755bc79b42b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab094de47a77da60eeca35fb8e4474d"><td class="memItemLeft" align="right" valign="top"><a id="abab094de47a77da60eeca35fb8e4474d"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Factored</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;factor, bool full=false)</td></tr>
<tr class="separator:abab094de47a77da60eeca35fb8e4474d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2601fcd2b63899c640ccf5c7e8c112"><td class="memItemLeft" align="right" valign="top"><a id="a5d2601fcd2b63899c640ccf5c7e8c112"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepFactor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:a5d2601fcd2b63899c640ccf5c7e8c112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523b38f44ab1e531d991f24e2f282250"><td class="memItemLeft" align="right" valign="top"><a id="a523b38f44ab1e531d991f24e2f282250"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepFactor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor)</td></tr>
<tr class="separator:a523b38f44ab1e531d991f24e2f282250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af341c96c577aeaf097b7b82529c6f303"><td class="memItemLeft" align="right" valign="top"><a id="af341c96c577aeaf097b7b82529c6f303"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepFactor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;factor)</td></tr>
<tr class="separator:af341c96c577aeaf097b7b82529c6f303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f27136f944537f727f7f342e9287f6c"><td class="memItemLeft" align="right" valign="top"><a id="a0f27136f944537f727f7f342e9287f6c"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepFactored</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:a0f27136f944537f727f7f342e9287f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321242441e08f7c1cab66d9552b540ad"><td class="memItemLeft" align="right" valign="top"><a id="a321242441e08f7c1cab66d9552b540ad"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepFactored</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor)</td></tr>
<tr class="separator:a321242441e08f7c1cab66d9552b540ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d747efebadc290f2f2ddb19162de1d1"><td class="memItemLeft" align="right" valign="top"><a id="a1d747efebadc290f2f2ddb19162de1d1"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepFactored</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;factor)</td></tr>
<tr class="separator:a1d747efebadc290f2f2ddb19162de1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e0d13976a4bd8cbc200e09581678f2"><td class="memItemLeft" align="right" valign="top"><a id="a03e0d13976a4bd8cbc200e09581678f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Collect</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors)</td></tr>
<tr class="separator:a03e0d13976a4bd8cbc200e09581678f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8606c566e78a2682ee87943ba2539df"><td class="memItemLeft" align="right" valign="top"><a id="ab8606c566e78a2682ee87943ba2539df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepCollect</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors)</td></tr>
<tr class="separator:ab8606c566e78a2682ee87943ba2539df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219ea397a53999668ada423de73a8104"><td class="memItemLeft" align="right" valign="top"><a id="a219ea397a53999668ada423de73a8104"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Collected</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors)</td></tr>
<tr class="separator:a219ea397a53999668ada423de73a8104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aba8653c79291b7f2fc5d773d38a03a"><td class="memItemLeft" align="right" valign="top"><a id="a7aba8653c79291b7f2fc5d773d38a03a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepCollected</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;factors)</td></tr>
<tr class="separator:a7aba8653c79291b7f2fc5d773d38a03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac04fc606668c21d68f4b810637d03bb"><td class="memItemLeft" align="right" valign="top"><a id="aac04fc606668c21d68f4b810637d03bb"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Distributed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor, bool full=false)</td></tr>
<tr class="separator:aac04fc606668c21d68f4b810637d03bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861f75045e2f7400e97e6200c7be190c"><td class="memItemLeft" align="right" valign="top"><a id="a861f75045e2f7400e97e6200c7be190c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Distribute</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor, bool full=false)</td></tr>
<tr class="separator:a861f75045e2f7400e97e6200c7be190c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18cd148f86ef78869887dd0280f5bab"><td class="memItemLeft" align="right" valign="top"><a id="ac18cd148f86ef78869887dd0280f5bab"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Distributed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;factor, bool full=false)</td></tr>
<tr class="separator:ac18cd148f86ef78869887dd0280f5bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9688960aa80989e461d3a9315fc1daa"><td class="memItemLeft" align="right" valign="top"><a id="af9688960aa80989e461d3a9315fc1daa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Distribute</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;factor, bool full=false)</td></tr>
<tr class="separator:af9688960aa80989e461d3a9315fc1daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a0a6f6486706c34707b44ee33dd5b3"><td class="memItemLeft" align="right" valign="top"><a id="a16a0a6f6486706c34707b44ee33dd5b3"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistributed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor)</td></tr>
<tr class="separator:a16a0a6f6486706c34707b44ee33dd5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0b2d12e78277ca9316a7083d67a9da"><td class="memItemLeft" align="right" valign="top"><a id="a4f0b2d12e78277ca9316a7083d67a9da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistribute</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> factor)</td></tr>
<tr class="separator:a4f0b2d12e78277ca9316a7083d67a9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452b0e919e36ed174b5d85c81465af4f"><td class="memItemLeft" align="right" valign="top"><a id="a452b0e919e36ed174b5d85c81465af4f"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistributed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;factor)</td></tr>
<tr class="separator:a452b0e919e36ed174b5d85c81465af4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c502965ecc1bf2b540c45730534df7b"><td class="memItemLeft" align="right" valign="top"><a id="a1c502965ecc1bf2b540c45730534df7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistribute</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;factor)</td></tr>
<tr class="separator:a1c502965ecc1bf2b540c45730534df7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed52633625c5ae76e7aab1c0834e7b4"><td class="memItemLeft" align="right" valign="top"><a id="a7ed52633625c5ae76e7aab1c0834e7b4"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Distributed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, <a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> factor, bool full=false)</td></tr>
<tr class="separator:a7ed52633625c5ae76e7aab1c0834e7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad488d124db62ad3aecadca95e6b98044"><td class="memItemLeft" align="right" valign="top"><a id="ad488d124db62ad3aecadca95e6b98044"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Distribute</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> factor, bool full=false)</td></tr>
<tr class="separator:ad488d124db62ad3aecadca95e6b98044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da501c019889436033ebc8021234d46"><td class="memItemLeft" align="right" valign="top"><a id="a2da501c019889436033ebc8021234d46"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Distributed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, <a class="el" href="classcsl_1_1Parent.html">Parent</a> const &amp;factor, bool full=false)</td></tr>
<tr class="separator:a2da501c019889436033ebc8021234d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55baea7e93f55c404d4012473b118d61"><td class="memItemLeft" align="right" valign="top"><a id="a55baea7e93f55c404d4012473b118d61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Distribute</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Parent.html">Parent</a> const &amp;factor, bool full=false)</td></tr>
<tr class="separator:a55baea7e93f55c404d4012473b118d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e0d3c266390fce166f09cd000fff91"><td class="memItemLeft" align="right" valign="top"><a id="a59e0d3c266390fce166f09cd000fff91"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistributed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, <a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> factor)</td></tr>
<tr class="separator:a59e0d3c266390fce166f09cd000fff91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226d09b96915263fb992a59a4e11c162"><td class="memItemLeft" align="right" valign="top"><a id="a226d09b96915263fb992a59a4e11c162"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistribute</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1AbstractParent.html">Parent_info</a> factor)</td></tr>
<tr class="separator:a226d09b96915263fb992a59a4e11c162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2656461b31efecdf181c684de8663b6"><td class="memItemLeft" align="right" valign="top"><a id="ac2656461b31efecdf181c684de8663b6"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistributed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, <a class="el" href="classcsl_1_1Parent.html">Parent</a> const &amp;factor)</td></tr>
<tr class="separator:ac2656461b31efecdf181c684de8663b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3c31a53c12157df8b51d9f8c867e8f"><td class="memItemLeft" align="right" valign="top"><a id="a3f3c31a53c12157df8b51d9f8c867e8f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistribute</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Parent.html">Parent</a> const &amp;factor)</td></tr>
<tr class="separator:a3f3c31a53c12157df8b51d9f8c867e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5124a19b7886ff60b7d4507dafe834"><td class="memItemLeft" align="right" valign="top"><a id="aaf5124a19b7886ff60b7d4507dafe834"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DistributedIf</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; f, bool full=false)</td></tr>
<tr class="separator:aaf5124a19b7886ff60b7d4507dafe834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71b3b260782bfc23d5aa0e7ba9baa40"><td class="memItemLeft" align="right" valign="top"><a id="ac71b3b260782bfc23d5aa0e7ba9baa40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DistributeIf</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; f, bool full=false)</td></tr>
<tr class="separator:ac71b3b260782bfc23d5aa0e7ba9baa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1943344b18e34fec6f1a10722809b446"><td class="memItemLeft" align="right" valign="top"><a id="a1943344b18e34fec6f1a10722809b446"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistributedIf</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; f)</td></tr>
<tr class="separator:a1943344b18e34fec6f1a10722809b446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0f01d822c3f234a96dcbb6a5722c27"><td class="memItemLeft" align="right" valign="top"><a id="abb0f01d822c3f234a96dcbb6a5722c27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepDistributeIf</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; f)</td></tr>
<tr class="separator:abb0f01d822c3f234a96dcbb6a5722c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ac2b475bc681e2d35463eb0006b303"><td class="memItemLeft" align="right" valign="top"><a id="a51ac2b475bc681e2d35463eb0006b303"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTerm</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:a51ac2b475bc681e2d35463eb0006b303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06afad91a45afb3fb065c256774fe57b"><td class="memItemLeft" align="right" valign="top"><a id="a06afad91a45afb3fb065c256774fe57b"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Derived</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> variable)</td></tr>
<tr class="separator:a06afad91a45afb3fb065c256774fe57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82ea078f93ac899142f931e936f5ab7"><td class="memItemLeft" align="right" valign="top"><a id="ad82ea078f93ac899142f931e936f5ab7"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Derived</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;variable)</td></tr>
<tr class="separator:ad82ea078f93ac899142f931e936f5ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa381b21aa4a4189d0ad2b317c303fbfb"><td class="memItemLeft" align="right" valign="top"><a id="aa381b21aa4a4189d0ad2b317c303fbfb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Derive</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> variable)</td></tr>
<tr class="separator:aa381b21aa4a4189d0ad2b317c303fbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514cdcb2c708e825ec620bf630d42d6d"><td class="memItemLeft" align="right" valign="top"><a id="a514cdcb2c708e825ec620bf630d42d6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Derive</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;variable)</td></tr>
<tr class="separator:a514cdcb2c708e825ec620bf630d42d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d73b2299a37eef69581a213172d450"><td class="memItemLeft" align="right" valign="top"><a id="a70d73b2299a37eef69581a213172d450"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetPolynomialTerm</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> variable, int order)</td></tr>
<tr class="separator:a70d73b2299a37eef69581a213172d450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9211472bbbb158e17ae24fc9818c53d2"><td class="memItemLeft" align="right" valign="top"><a id="a9211472bbbb158e17ae24fc9818c53d2"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetPolynomialTerm</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;variable, int order)</td></tr>
<tr class="separator:a9211472bbbb158e17ae24fc9818c53d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547000792cc7a324993dc5bd7fc40030"><td class="memItemLeft" align="right" valign="top"><a id="a547000792cc7a324993dc5bd7fc40030"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Evaluated</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:a547000792cc7a324993dc5bd7fc40030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e945ec91d4d3c42684a1911b2926f7"><td class="memItemLeft" align="right" valign="top"><a id="a57e945ec91d4d3c42684a1911b2926f7"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Evaluated</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, csl::eval::mode user_mode)</td></tr>
<tr class="separator:a57e945ec91d4d3c42684a1911b2926f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92933402f5684f9ddf75af6b78f0a695"><td class="memItemLeft" align="right" valign="top"><a id="a92933402f5684f9ddf75af6b78f0a695"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Evaluate</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a92933402f5684f9ddf75af6b78f0a695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0013e5d0bcf5e7643e4a0c65d4a75a4"><td class="memItemLeft" align="right" valign="top"><a id="ab0013e5d0bcf5e7643e4a0c65d4a75a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Evaluate</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, eval::mode user_mode)</td></tr>
<tr class="separator:ab0013e5d0bcf5e7643e4a0c65d4a75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8df6ba7c39fd03780af28b9cb2d918"><td class="memItemLeft" align="right" valign="top"><a id="a2a8df6ba7c39fd03780af28b9cb2d918"></a>
<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">ComplexProperty</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetComplexProperty</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a2a8df6ba7c39fd03780af28b9cb2d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501154931770fe51f69645d8a57ebf12"><td class="memItemLeft" align="right" valign="top"><a id="a501154931770fe51f69645d8a57ebf12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetComplexProperty</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">ComplexProperty</a> prop)</td></tr>
<tr class="separator:a501154931770fe51f69645d8a57ebf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4badade11e622f75d9c887291bcc5d06"><td class="memItemLeft" align="right" valign="top"><a id="a4badade11e622f75d9c887291bcc5d06"></a>
<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">ComplexProperty</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetComplexProperty</b> (<a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> const &amp;parent)</td></tr>
<tr class="separator:a4badade11e622f75d9c887291bcc5d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc4ed5e9d464a3a13d7fe5a91df2261"><td class="memItemLeft" align="right" valign="top"><a id="a5bc4ed5e9d464a3a13d7fe5a91df2261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetComplexProperty</b> (<a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> &amp;parent, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">ComplexProperty</a> prop)</td></tr>
<tr class="separator:a5bc4ed5e9d464a3a13d7fe5a91df2261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85346c691f188091562545ed84088f88"><td class="memTemplParams" colspan="2"><a id="a85346c691f188091562545ed84088f88"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a85346c691f188091562545ed84088f88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetComplexProperty</b> (T parent, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">ComplexProperty</a> prop)</td></tr>
<tr class="separator:a85346c691f188091562545ed84088f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afcab855dcbe3f48f03b2c589bb7385"><td class="memItemLeft" align="right" valign="top"><a id="a7afcab855dcbe3f48f03b2c589bb7385"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetRealPart</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:a7afcab855dcbe3f48f03b2c589bb7385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47dcd50e52537bd07e77109e139ddd3"><td class="memItemLeft" align="right" valign="top"><a id="ad47dcd50e52537bd07e77109e139ddd3"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetImaginaryPart</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:ad47dcd50e52537bd07e77109e139ddd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064e11568f971ef9ac6f989390283920"><td class="memItemLeft" align="right" valign="top"><a id="a064e11568f971ef9ac6f989390283920"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetComplexModulus</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:a064e11568f971ef9ac6f989390283920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1b222d7e7a23d784d6509f1c23c3f2"><td class="memItemLeft" align="right" valign="top"><a id="acc1b222d7e7a23d784d6509f1c23c3f2"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetComplexArgument</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:acc1b222d7e7a23d784d6509f1c23c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf21d6b36935e0e8dbdeb8f984e6e9f"><td class="memItemLeft" align="right" valign="top"><a id="aabf21d6b36935e0e8dbdeb8f984e6e9f"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetComplexConjugate</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression)</td></tr>
<tr class="separator:aabf21d6b36935e0e8dbdeb8f984e6e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b39c214b43931ff072a7a72a8158a8d"><td class="memItemLeft" align="right" valign="top"><a id="a0b39c214b43931ff072a7a72a8158a8d"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTransposed</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Space.html">Space</a> *space, bool applyProp=true)</td></tr>
<tr class="separator:a0b39c214b43931ff072a7a72a8158a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b566343ddcad23deb2b6f3adff20b1"><td class="memItemLeft" align="right" valign="top"><a id="a93b566343ddcad23deb2b6f3adff20b1"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTransposed</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces, bool applyProp=true)</td></tr>
<tr class="separator:a93b566343ddcad23deb2b6f3adff20b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9bfe96fea320eb82169ab44a5f9c5"><td class="memItemLeft" align="right" valign="top"><a id="aafe9bfe96fea320eb82169ab44a5f9c5"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetHermitianConjugate</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Space.html">Space</a> *space)</td></tr>
<tr class="separator:aafe9bfe96fea320eb82169ab44a5f9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035dc8454be548e76b13d2ad3f001bc8"><td class="memItemLeft" align="right" valign="top"><a id="a035dc8454be548e76b13d2ad3f001bc8"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetHermitianConjugate</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces)</td></tr>
<tr class="separator:a035dc8454be548e76b13d2ad3f001bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0187ff511c88b8241b71bb8594e6ad0"><td class="memItemLeft" align="right" valign="top"><a id="ae0187ff511c88b8241b71bb8594e6ad0"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Swapped</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index1, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index2, bool refresh=true)</td></tr>
<tr class="separator:ae0187ff511c88b8241b71bb8594e6ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403899ce406608ac967d5c6387ef734e"><td class="memItemLeft" align="right" valign="top"><a id="a403899ce406608ac967d5c6387ef734e"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Swapped</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;index1, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;index2, bool refresh=true)</td></tr>
<tr class="separator:a403899ce406608ac967d5c6387ef734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefed73b5aa89fc28c42fe8bf0140e05d"><td class="memItemLeft" align="right" valign="top"><a id="aefed73b5aa89fc28c42fe8bf0140e05d"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Swapped</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;index1, const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;index2, bool refresh=true)</td></tr>
<tr class="separator:aefed73b5aa89fc28c42fe8bf0140e05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aa2a457a2d1c52d76643c0a4f1c69c"><td class="memTemplParams" colspan="2"><a id="aa2aa2a457a2d1c52d76643c0a4f1c69c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2aa2a457a2d1c52d76643c0a4f1c69c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Swap</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, T const &amp;old_obj, T const &amp;new_obj)</td></tr>
<tr class="separator:aa2aa2a457a2d1c52d76643c0a4f1c69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c1e64ee3f7850e821f509e3aa3c3cf"><td class="memItemLeft" align="right" valign="top"><a id="a72c1e64ee3f7850e821f509e3aa3c3cf"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ContractIndex</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index)</td></tr>
<tr class="separator:a72c1e64ee3f7850e821f509e3aa3c3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63547c3137af5311d82a57ac9de016e"><td class="memItemLeft" align="right" valign="top"><a id="ae63547c3137af5311d82a57ac9de016e"></a>
<a class="el" href="classcsl_1_1Index.html">csl::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GenerateIndex</b> (const <a class="el" href="classcsl_1_1Space.html">csl::Space</a> *space, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="separator:ae63547c3137af5311d82a57ac9de016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3308499e1a6a0308721cf4a5160310a"><td class="memItemLeft" align="right" valign="top"><a id="ad3308499e1a6a0308721cf4a5160310a"></a>
<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetDelta</b> (const <a class="el" href="classcsl_1_1Space.html">csl::Space</a> *space)</td></tr>
<tr class="separator:ad3308499e1a6a0308721cf4a5160310a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627520800fbe183de1614aa9ccaf187b"><td class="memItemLeft" align="right" valign="top"><a id="a627520800fbe183de1614aa9ccaf187b"></a>
<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetMetric</b> (const <a class="el" href="classcsl_1_1Space.html">csl::Space</a> *space)</td></tr>
<tr class="separator:a627520800fbe183de1614aa9ccaf187b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b7a3d00640c5c0baef0d045a49e5ff"><td class="memItemLeft" align="right" valign="top"><a id="a41b7a3d00640c5c0baef0d045a49e5ff"></a>
<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetEpsilon</b> (const <a class="el" href="classcsl_1_1Space.html">csl::Space</a> *space)</td></tr>
<tr class="separator:a41b7a3d00640c5c0baef0d045a49e5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012ebc8a748514390004737bf132e204"><td class="memItemLeft" align="right" valign="top"><a id="a012ebc8a748514390004737bf132e204"></a>
<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetDelta</b> (const <a class="el" href="classcsl_1_1Space.html">csl::Space</a> &amp;space)</td></tr>
<tr class="separator:a012ebc8a748514390004737bf132e204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662f9d542ff4dc856444bea7812f8035"><td class="memItemLeft" align="right" valign="top"><a id="a662f9d542ff4dc856444bea7812f8035"></a>
<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetMetric</b> (const <a class="el" href="classcsl_1_1Space.html">csl::Space</a> &amp;space)</td></tr>
<tr class="separator:a662f9d542ff4dc856444bea7812f8035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be9c4e1a0deb6c6e4963eaccd88251b"><td class="memItemLeft" align="right" valign="top"><a id="a1be9c4e1a0deb6c6e4963eaccd88251b"></a>
<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetEpsilon</b> (const <a class="el" href="classcsl_1_1Space.html">csl::Space</a> &amp;space)</td></tr>
<tr class="separator:a1be9c4e1a0deb6c6e4963eaccd88251b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283b7920a06dd6ce3b3e38b945428721"><td class="memItemLeft" align="right" valign="top"><a id="a283b7920a06dd6ce3b3e38b945428721"></a>
<a class="el" href="classcsl_1_1Parent.html">Parent</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetParent</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;tensor)</td></tr>
<tr class="separator:a283b7920a06dd6ce3b3e38b945428721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbb1c2e16eb5567cba6dbf4a6e4d976"><td class="memItemLeft" align="right" valign="top"><a id="a7cbb1c2e16eb5567cba6dbf4a6e4d976"></a>
<a class="el" href="classcsl_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTensorParent</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;tensor)</td></tr>
<tr class="separator:a7cbb1c2e16eb5567cba6dbf4a6e4d976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad83d07136b6e3feb0ec3531c3003792"><td class="memItemLeft" align="right" valign="top"><a id="aad83d07136b6e3feb0ec3531c3003792"></a>
<a class="el" href="classcsl_1_1TensorField.html">TensorField</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTensorFieldParent</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;tensor)</td></tr>
<tr class="separator:aad83d07136b6e3feb0ec3531c3003792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b90dc4c985c02d89dc1cbd5bc55ef5"><td class="memItemLeft" align="right" valign="top"><a id="a18b90dc4c985c02d89dc1cbd5bc55ef5"></a>
<a class="el" href="classcsl_1_1TDerivative.html">TDerivative</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTDerivativeParent</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;tensor)</td></tr>
<tr class="separator:a18b90dc4c985c02d89dc1cbd5bc55ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f78de91ea6578bfcfbb31857ecba116"><td class="memItemLeft" align="right" valign="top"><a id="a9f78de91ea6578bfcfbb31857ecba116"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddSelfContraction</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;parent, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;A, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;B, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;res)</td></tr>
<tr class="separator:a9f78de91ea6578bfcfbb31857ecba116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14694e3ce4d63350b9d0180aaf17ce89"><td class="memItemLeft" align="right" valign="top"><a id="a14694e3ce4d63350b9d0180aaf17ce89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddContractionProperty</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;parent, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;tensors, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;res)</td></tr>
<tr class="separator:a14694e3ce4d63350b9d0180aaf17ce89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdacb64f7e44195c02bfd8e7a4424b8"><td class="memItemLeft" align="right" valign="top"><a id="a0bdacb64f7e44195c02bfd8e7a4424b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddComplexProperty</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;parent, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;A, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;B)</td></tr>
<tr class="separator:a0bdacb64f7e44195c02bfd8e7a4424b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c047788103acd2024ebff5c7866895"><td class="memItemLeft" align="right" valign="top"><a id="a73c047788103acd2024ebff5c7866895"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddTransposedProperty</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;parent, <a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;A, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;B)</td></tr>
<tr class="separator:a73c047788103acd2024ebff5c7866895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a55d76363aa38a8f938d44ddf544155"><td class="memItemLeft" align="right" valign="top"><a id="a9a55d76363aa38a8f938d44ddf544155"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddHermitianProperty</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;parent, <a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;A, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;B)</td></tr>
<tr class="separator:a9a55d76363aa38a8f938d44ddf544155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce7a7ad7505c2977a7021681f9f9d96"><td class="memItemLeft" align="right" valign="top"><a id="a1ce7a7ad7505c2977a7021681f9f9d96"></a>
<a class="el" href="classcsl_1_1LibDependency.html">LibDependency</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetLibraryDependencies</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression)</td></tr>
<tr class="separator:a1ce7a7ad7505c2977a7021681f9f9d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdebc6a45b5f4a79f0c3780e358a51e"><td class="memItemLeft" align="right" valign="top"><a id="adcdebc6a45b5f4a79f0c3780e358a51e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIndexed</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:adcdebc6a45b5f4a79f0c3780e358a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce59c190b45bcc8a74af071c6d3fad8"><td class="memItemLeft" align="right" valign="top"><a id="a7ce59c190b45bcc8a74af071c6d3fad8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsNumerical</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a7ce59c190b45bcc8a74af071c6d3fad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d128d954d296aac31d65ff8da1a108"><td class="memItemLeft" align="right" valign="top"><a id="a95d128d954d296aac31d65ff8da1a108"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsLiteral</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a95d128d954d296aac31d65ff8da1a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb4d6f5489e26f2ec4109b55d88860f"><td class="memItemLeft" align="right" valign="top"><a id="afeb4d6f5489e26f2ec4109b55d88860f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalarFunction</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:afeb4d6f5489e26f2ec4109b55d88860f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7222d17cb16522b99386de9f13c8d7a"><td class="memItemLeft" align="right" valign="top"><a id="ad7222d17cb16522b99386de9f13c8d7a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsMultiFunction</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:ad7222d17cb16522b99386de9f13c8d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa801bd8a4ed4fd370b6d501bd5e886"><td class="memItemLeft" align="right" valign="top"><a id="a1fa801bd8a4ed4fd370b6d501bd5e886"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVectorial</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a1fa801bd8a4ed4fd370b6d501bd5e886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4e989ba8526376f53aabc053b43a3a"><td class="memItemLeft" align="right" valign="top"><a id="aec4e989ba8526376f53aabc053b43a3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIndicial</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aec4e989ba8526376f53aabc053b43a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45e1e3b62dcc3fef64cf4a5956543b6"><td class="memItemLeft" align="right" valign="top"><a id="ad45e1e3b62dcc3fef64cf4a5956543b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsField</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:ad45e1e3b62dcc3fef64cf4a5956543b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f041b6871d886a0533b208e13c47b"><td class="memItemLeft" align="right" valign="top"><a id="abc4f041b6871d886a0533b208e13c47b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsArbitrary</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:abc4f041b6871d886a0533b208e13c47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710459bfd53ea481ad2e1db6838c945c"><td class="memItemLeft" align="right" valign="top"><a id="a710459bfd53ea481ad2e1db6838c945c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsInteger</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a710459bfd53ea481ad2e1db6838c945c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334fa354bbfba58cb234379d2937eae2"><td class="memItemLeft" align="right" valign="top"><a id="a334fa354bbfba58cb234379d2937eae2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsFloat</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a334fa354bbfba58cb234379d2937eae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3e9ec5328f36ffbc0fea1465fee6fd"><td class="memItemLeft" align="right" valign="top"><a id="a2c3e9ec5328f36ffbc0fea1465fee6fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIntFraction</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a2c3e9ec5328f36ffbc0fea1465fee6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7161252442ca7268f911fb8372ee57"><td class="memItemLeft" align="right" valign="top"><a id="aeb7161252442ca7268f911fb8372ee57"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIntFactorial</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aeb7161252442ca7268f911fb8372ee57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c4d02701c0a2c62125c01e0b504ae0"><td class="memItemLeft" align="right" valign="top"><a id="a88c4d02701c0a2c62125c01e0b504ae0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsComplex</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a88c4d02701c0a2c62125c01e0b504ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46d2aa651dff22500e8002a35dc60d5"><td class="memItemLeft" align="right" valign="top"><a id="aa46d2aa651dff22500e8002a35dc60d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsNumericalEval</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aa46d2aa651dff22500e8002a35dc60d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d159276ee9d2e0b18f548d121398add"><td class="memItemLeft" align="right" valign="top"><a id="a7d159276ee9d2e0b18f548d121398add"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsImaginary</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a7d159276ee9d2e0b18f548d121398add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac950c24421d95a69b268669d70417d7f"><td class="memItemLeft" align="right" valign="top"><a id="ac950c24421d95a69b268669d70417d7f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsConstant</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:ac950c24421d95a69b268669d70417d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96da9988f9257092883eb38d8b80682e"><td class="memItemLeft" align="right" valign="top"><a id="a96da9988f9257092883eb38d8b80682e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVariable</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a96da9988f9257092883eb38d8b80682e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac72d5b322559cd6689bba23c572612"><td class="memItemLeft" align="right" valign="top"><a id="a7ac72d5b322559cd6689bba23c572612"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsExp</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a7ac72d5b322559cd6689bba23c572612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2ad94e66dfbefa911129b3026d1fa2"><td class="memItemLeft" align="right" valign="top"><a id="a6e2ad94e66dfbefa911129b3026d1fa2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsLog</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a6e2ad94e66dfbefa911129b3026d1fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda0fe72bd886bdb32043ff72bd3cb26"><td class="memItemLeft" align="right" valign="top"><a id="aeda0fe72bd886bdb32043ff72bd3cb26"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsDiracDelta</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aeda0fe72bd886bdb32043ff72bd3cb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2416a821c5efdeb01e94d41458b7831a"><td class="memItemLeft" align="right" valign="top"><a id="a2416a821c5efdeb01e94d41458b7831a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsAbs</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a2416a821c5efdeb01e94d41458b7831a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea3d0182b0e531af9e692e213462ca6"><td class="memItemLeft" align="right" valign="top"><a id="a1ea3d0182b0e531af9e692e213462ca6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCos</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a1ea3d0182b0e531af9e692e213462ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb77965dbb36f49a9f19a5a6c2b561b6"><td class="memItemLeft" align="right" valign="top"><a id="abb77965dbb36f49a9f19a5a6c2b561b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSin</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:abb77965dbb36f49a9f19a5a6c2b561b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb3dffea91a96130edee4dedead53c1"><td class="memItemLeft" align="right" valign="top"><a id="abbb3dffea91a96130edee4dedead53c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTan</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:abbb3dffea91a96130edee4dedead53c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e11a78d9bec3070c5984dc6bef7d17"><td class="memItemLeft" align="right" valign="top"><a id="ad3e11a78d9bec3070c5984dc6bef7d17"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCosh</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:ad3e11a78d9bec3070c5984dc6bef7d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5961b6b86af88051cedb62a61e1d70d"><td class="memItemLeft" align="right" valign="top"><a id="af5961b6b86af88051cedb62a61e1d70d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSinh</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:af5961b6b86af88051cedb62a61e1d70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e957b735200dac17c6ce041f0ffddb8"><td class="memItemLeft" align="right" valign="top"><a id="a5e957b735200dac17c6ce041f0ffddb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTanh</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a5e957b735200dac17c6ce041f0ffddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc42d7d43012d09e1f26f25e25c759a"><td class="memItemLeft" align="right" valign="top"><a id="aabc42d7d43012d09e1f26f25e25c759a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsACos</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aabc42d7d43012d09e1f26f25e25c759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297062416977feccfe2d0049345a46d1"><td class="memItemLeft" align="right" valign="top"><a id="a297062416977feccfe2d0049345a46d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsASin</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a297062416977feccfe2d0049345a46d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2236666ea79e847e541266964fa599a7"><td class="memItemLeft" align="right" valign="top"><a id="a2236666ea79e847e541266964fa599a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsATan</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a2236666ea79e847e541266964fa599a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e3dc6e03acbe860eca4c535402ba4e"><td class="memItemLeft" align="right" valign="top"><a id="a19e3dc6e03acbe860eca4c535402ba4e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsACosh</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a19e3dc6e03acbe860eca4c535402ba4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cc636ab347701b35eccffc259233ec"><td class="memItemLeft" align="right" valign="top"><a id="a93cc636ab347701b35eccffc259233ec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsASinh</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a93cc636ab347701b35eccffc259233ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a539727f85b416cf83e996686757fb2"><td class="memItemLeft" align="right" valign="top"><a id="a0a539727f85b416cf83e996686757fb2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsATanh</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a0a539727f85b416cf83e996686757fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876cbba4d3c563e504a8eb2ba4342cab"><td class="memItemLeft" align="right" valign="top"><a id="a876cbba4d3c563e504a8eb2ba4342cab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalar</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a876cbba4d3c563e504a8eb2ba4342cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e61aee45db218372b0397a297f6f726"><td class="memItemLeft" align="right" valign="top"><a id="a5e61aee45db218372b0397a297f6f726"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRealPart</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a5e61aee45db218372b0397a297f6f726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5628e6082a9900e297ff04fa273213b6"><td class="memItemLeft" align="right" valign="top"><a id="a5628e6082a9900e297ff04fa273213b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsImaginaryPart</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a5628e6082a9900e297ff04fa273213b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e2e843891be6a1b40ca8eb87dbae42"><td class="memItemLeft" align="right" valign="top"><a id="ac9e2e843891be6a1b40ca8eb87dbae42"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsITensor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:ac9e2e843891be6a1b40ca8eb87dbae42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0500be7ecabbe4dd34715a769fbb03f"><td class="memItemLeft" align="right" valign="top"><a id="aa0500be7ecabbe4dd34715a769fbb03f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalarField</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aa0500be7ecabbe4dd34715a769fbb03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be2947ffc58e823462aacdc020a7d78"><td class="memItemLeft" align="right" valign="top"><a id="a4be2947ffc58e823462aacdc020a7d78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTensorField</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a4be2947ffc58e823462aacdc020a7d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2193785686eacaa5c8823ee8086379b"><td class="memItemLeft" align="right" valign="top"><a id="af2193785686eacaa5c8823ee8086379b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTensorialDerivative</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:af2193785686eacaa5c8823ee8086379b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa465fba90e9f3781f1ed8ea346ebf7ca"><td class="memItemLeft" align="right" valign="top"><a id="aa465fba90e9f3781f1ed8ea346ebf7ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsStandardDuo</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aa465fba90e9f3781f1ed8ea346ebf7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f4b3bebaafcc8b8ff994f6b1487f27"><td class="memItemLeft" align="right" valign="top"><a id="a07f4b3bebaafcc8b8ff994f6b1487f27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsStandardMult</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a07f4b3bebaafcc8b8ff994f6b1487f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ade8727691988bbbef117643c1ab0f"><td class="memItemLeft" align="right" valign="top"><a id="ae0ade8727691988bbbef117643c1ab0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPow</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:ae0ade8727691988bbbef117643c1ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9ea487f51b0883293e1483933ca1fb"><td class="memItemLeft" align="right" valign="top"><a id="abb9ea487f51b0883293e1483933ca1fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsProd</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:abb9ea487f51b0883293e1483933ca1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0f93949297db79dee52dcca93e666b"><td class="memItemLeft" align="right" valign="top"><a id="a2c0f93949297db79dee52dcca93e666b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSum</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a2c0f93949297db79dee52dcca93e666b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca47f1fc9c0f1f22fd8aeeb49008a54"><td class="memItemLeft" align="right" valign="top"><a id="aeca47f1fc9c0f1f22fd8aeeb49008a54"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPolynomial</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aeca47f1fc9c0f1f22fd8aeeb49008a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9223e0ed91dbf7a77b168058915d7f01"><td class="memItemLeft" align="right" valign="top"><a id="a9223e0ed91dbf7a77b168058915d7f01"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsDerivative</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a9223e0ed91dbf7a77b168058915d7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee8eb88195d43364dfaadbfc5d69044"><td class="memItemLeft" align="right" valign="top"><a id="a2ee8eb88195d43364dfaadbfc5d69044"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCommutator</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a2ee8eb88195d43364dfaadbfc5d69044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accda8cc479ae563e1e81d5e21447ec87"><td class="memItemLeft" align="right" valign="top"><a id="accda8cc479ae563e1e81d5e21447ec87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsAngle</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:accda8cc479ae563e1e81d5e21447ec87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35abcd5f7253764ed2d15670551bd51"><td class="memItemLeft" align="right" valign="top"><a id="ad35abcd5f7253764ed2d15670551bd51"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsFactorial</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:ad35abcd5f7253764ed2d15670551bd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df0bbf92952a6d925b4ed2d29cc1538"><td class="memItemLeft" align="right" valign="top"><a id="a6df0bbf92952a6d925b4ed2d29cc1538"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIntegral</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a6df0bbf92952a6d925b4ed2d29cc1538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5732eea87d5e76e66774d8eee7ee5e53"><td class="memItemLeft" align="right" valign="top"><a id="a5732eea87d5e76e66774d8eee7ee5e53"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalarIntegral</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a5732eea87d5e76e66774d8eee7ee5e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b556e46550d5d20cb90d3d195240d0a"><td class="memItemLeft" align="right" valign="top"><a id="a6b556e46550d5d20cb90d3d195240d0a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVectorIntegral</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a6b556e46550d5d20cb90d3d195240d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423118242d83867ff1db9f929ed93cdd"><td class="memItemLeft" align="right" valign="top"><a id="a423118242d83867ff1db9f929ed93cdd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVector</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a423118242d83867ff1db9f929ed93cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eb06fcee3a9ac1940ce563efdc006c"><td class="memItemLeft" align="right" valign="top"><a id="a47eb06fcee3a9ac1940ce563efdc006c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsMatrix</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a47eb06fcee3a9ac1940ce563efdc006c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d31c8e21a1b5e7cb351ec309ec1d71"><td class="memItemLeft" align="right" valign="top"><a id="a35d31c8e21a1b5e7cb351ec309ec1d71"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsHighDTensor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a35d31c8e21a1b5e7cb351ec309ec1d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0613b18ae95c84a405ae99d1ebaaea"><td class="memItemLeft" align="right" valign="top"><a id="a1b0613b18ae95c84a405ae99d1ebaaea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIndexed</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a1b0613b18ae95c84a405ae99d1ebaaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16b218bb07e4e61c026e0ef1ee21ba2"><td class="memItemLeft" align="right" valign="top"><a id="ae16b218bb07e4e61c026e0ef1ee21ba2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsNumerical</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:ae16b218bb07e4e61c026e0ef1ee21ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f62b4bccc65d20101d3b26e3e3926e"><td class="memItemLeft" align="right" valign="top"><a id="aa5f62b4bccc65d20101d3b26e3e3926e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsLiteral</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:aa5f62b4bccc65d20101d3b26e3e3926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33d96f4bcf6d0582b4277373fca8b54"><td class="memItemLeft" align="right" valign="top"><a id="ad33d96f4bcf6d0582b4277373fca8b54"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalarFunction</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:ad33d96f4bcf6d0582b4277373fca8b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17214565f959cdaa4553ee6170861cea"><td class="memItemLeft" align="right" valign="top"><a id="a17214565f959cdaa4553ee6170861cea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsMultiFunction</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a17214565f959cdaa4553ee6170861cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427068961aa2a431fc082db2fe838041"><td class="memItemLeft" align="right" valign="top"><a id="a427068961aa2a431fc082db2fe838041"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVectorial</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a427068961aa2a431fc082db2fe838041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f876c93d62d7f199d44e8e140ac083"><td class="memItemLeft" align="right" valign="top"><a id="aa8f876c93d62d7f199d44e8e140ac083"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIndicial</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:aa8f876c93d62d7f199d44e8e140ac083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44233c9cef2cffd563b91d235b9351b6"><td class="memItemLeft" align="right" valign="top"><a id="a44233c9cef2cffd563b91d235b9351b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsField</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a44233c9cef2cffd563b91d235b9351b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2844344bbf4fa33601014aa26a310262"><td class="memItemLeft" align="right" valign="top"><a id="a2844344bbf4fa33601014aa26a310262"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsArbitrary</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a2844344bbf4fa33601014aa26a310262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2fff39a2dd71b3b3aa40c614a589e4"><td class="memItemLeft" align="right" valign="top"><a id="a9f2fff39a2dd71b3b3aa40c614a589e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsInteger</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a9f2fff39a2dd71b3b3aa40c614a589e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e3c07e21bf99bfff307b5baafb3db8"><td class="memItemLeft" align="right" valign="top"><a id="a21e3c07e21bf99bfff307b5baafb3db8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsFloat</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a21e3c07e21bf99bfff307b5baafb3db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de1fd017dbb1fba7d0be41aa4e7ffd"><td class="memItemLeft" align="right" valign="top"><a id="a31de1fd017dbb1fba7d0be41aa4e7ffd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIntFraction</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a31de1fd017dbb1fba7d0be41aa4e7ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a7f9c9ac4e4567ba4b4714ad71fe36"><td class="memItemLeft" align="right" valign="top"><a id="a10a7f9c9ac4e4567ba4b4714ad71fe36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIntFactorial</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a10a7f9c9ac4e4567ba4b4714ad71fe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065eb450f2568ff402e5d8b1b7a0dbcf"><td class="memItemLeft" align="right" valign="top"><a id="a065eb450f2568ff402e5d8b1b7a0dbcf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsComplex</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a065eb450f2568ff402e5d8b1b7a0dbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bc768952cfad359299c6d1d76b2ba2"><td class="memItemLeft" align="right" valign="top"><a id="af9bc768952cfad359299c6d1d76b2ba2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsNumericalEval</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:af9bc768952cfad359299c6d1d76b2ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333eefc5eef357e93df4b16d08e24c09"><td class="memItemLeft" align="right" valign="top"><a id="a333eefc5eef357e93df4b16d08e24c09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsImaginary</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a333eefc5eef357e93df4b16d08e24c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb54f1a23c9696f5471e1cdd4b1e5a6b"><td class="memItemLeft" align="right" valign="top"><a id="aeb54f1a23c9696f5471e1cdd4b1e5a6b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsConstant</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:aeb54f1a23c9696f5471e1cdd4b1e5a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf08728279011339fb8d406c4b297174"><td class="memItemLeft" align="right" valign="top"><a id="aaf08728279011339fb8d406c4b297174"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVariable</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:aaf08728279011339fb8d406c4b297174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc8db92414c195f688fb3cf94ff5b63"><td class="memItemLeft" align="right" valign="top"><a id="a6bc8db92414c195f688fb3cf94ff5b63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsExp</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a6bc8db92414c195f688fb3cf94ff5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0513e1bfbdff5058652825ff3be0107f"><td class="memItemLeft" align="right" valign="top"><a id="a0513e1bfbdff5058652825ff3be0107f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsLog</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a0513e1bfbdff5058652825ff3be0107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25aacf04c1568e2a57a28610b144d71f"><td class="memItemLeft" align="right" valign="top"><a id="a25aacf04c1568e2a57a28610b144d71f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsDiracDelta</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a25aacf04c1568e2a57a28610b144d71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48faf443eecc89724a5a460620b2dfc"><td class="memItemLeft" align="right" valign="top"><a id="af48faf443eecc89724a5a460620b2dfc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsAbs</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:af48faf443eecc89724a5a460620b2dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf343a105a87d08abc656b80bc99a7f0"><td class="memItemLeft" align="right" valign="top"><a id="acf343a105a87d08abc656b80bc99a7f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCos</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:acf343a105a87d08abc656b80bc99a7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5749555cc4d22dad93eb1d1700ac87"><td class="memItemLeft" align="right" valign="top"><a id="aed5749555cc4d22dad93eb1d1700ac87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSin</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:aed5749555cc4d22dad93eb1d1700ac87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63f05f19671a844cf8a184f1aef2206"><td class="memItemLeft" align="right" valign="top"><a id="aa63f05f19671a844cf8a184f1aef2206"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTan</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:aa63f05f19671a844cf8a184f1aef2206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720fdedbf6fb795fc84b768120074639"><td class="memItemLeft" align="right" valign="top"><a id="a720fdedbf6fb795fc84b768120074639"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCosh</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a720fdedbf6fb795fc84b768120074639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331028fd8ec22818062aa898a6079d50"><td class="memItemLeft" align="right" valign="top"><a id="a331028fd8ec22818062aa898a6079d50"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSinh</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a331028fd8ec22818062aa898a6079d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ad4c786aa9d03d7ffc60a15878ea93"><td class="memItemLeft" align="right" valign="top"><a id="a07ad4c786aa9d03d7ffc60a15878ea93"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTanh</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a07ad4c786aa9d03d7ffc60a15878ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1975dc7b698a9275626ffd4101db1f"><td class="memItemLeft" align="right" valign="top"><a id="a2e1975dc7b698a9275626ffd4101db1f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsACos</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a2e1975dc7b698a9275626ffd4101db1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4debb35e9238cf1bc3d7d75f0a365053"><td class="memItemLeft" align="right" valign="top"><a id="a4debb35e9238cf1bc3d7d75f0a365053"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsASin</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a4debb35e9238cf1bc3d7d75f0a365053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147dc80496a6f67152e662f98d51b9e1"><td class="memItemLeft" align="right" valign="top"><a id="a147dc80496a6f67152e662f98d51b9e1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsATan</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a147dc80496a6f67152e662f98d51b9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec9be26f4c25f34bac664768a3ef9e0"><td class="memItemLeft" align="right" valign="top"><a id="adec9be26f4c25f34bac664768a3ef9e0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsACosh</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:adec9be26f4c25f34bac664768a3ef9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e32028129f006371889f9a269b1dbe"><td class="memItemLeft" align="right" valign="top"><a id="ab2e32028129f006371889f9a269b1dbe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsASinh</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:ab2e32028129f006371889f9a269b1dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddfd9815a501bdd9f274957d76531bb"><td class="memItemLeft" align="right" valign="top"><a id="a7ddfd9815a501bdd9f274957d76531bb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsATanh</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a7ddfd9815a501bdd9f274957d76531bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47ebdf65a6c1af60b015330274fc90a"><td class="memItemLeft" align="right" valign="top"><a id="ae47ebdf65a6c1af60b015330274fc90a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalar</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:ae47ebdf65a6c1af60b015330274fc90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04415f7177cdd01dfbee736d3af1ebe0"><td class="memItemLeft" align="right" valign="top"><a id="a04415f7177cdd01dfbee736d3af1ebe0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRealPart</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a04415f7177cdd01dfbee736d3af1ebe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43af5bfd88aa39510319961e0a40283d"><td class="memItemLeft" align="right" valign="top"><a id="a43af5bfd88aa39510319961e0a40283d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsImaginaryPart</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a43af5bfd88aa39510319961e0a40283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e76a70707cb6495e68999321eab53"><td class="memItemLeft" align="right" valign="top"><a id="a058e76a70707cb6495e68999321eab53"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsITensor</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a058e76a70707cb6495e68999321eab53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15e71665b009e4b3f538f0283fba808"><td class="memItemLeft" align="right" valign="top"><a id="ac15e71665b009e4b3f538f0283fba808"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalarField</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:ac15e71665b009e4b3f538f0283fba808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd3f45e45bb6470250b0345796262b9"><td class="memItemLeft" align="right" valign="top"><a id="a4bd3f45e45bb6470250b0345796262b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTensorField</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a4bd3f45e45bb6470250b0345796262b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567aee305288c0334c4302d75ab96db3"><td class="memItemLeft" align="right" valign="top"><a id="a567aee305288c0334c4302d75ab96db3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTensorialDerivative</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a567aee305288c0334c4302d75ab96db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ceba70ba5bfb0367ce25c1f0aef2d0"><td class="memItemLeft" align="right" valign="top"><a id="a19ceba70ba5bfb0367ce25c1f0aef2d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsStandardDuo</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a19ceba70ba5bfb0367ce25c1f0aef2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca8cfa9536d37bbaed82e75276b4b7"><td class="memItemLeft" align="right" valign="top"><a id="a39ca8cfa9536d37bbaed82e75276b4b7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsStandardMult</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a39ca8cfa9536d37bbaed82e75276b4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec62ed9a54f53c6cb6184ddf7ada80"><td class="memItemLeft" align="right" valign="top"><a id="a5eec62ed9a54f53c6cb6184ddf7ada80"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPow</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a5eec62ed9a54f53c6cb6184ddf7ada80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1233811f2a52250b0b488951f559193"><td class="memItemLeft" align="right" valign="top"><a id="aa1233811f2a52250b0b488951f559193"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsProd</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:aa1233811f2a52250b0b488951f559193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71911fe28b7a192f255585195184cdcb"><td class="memItemLeft" align="right" valign="top"><a id="a71911fe28b7a192f255585195184cdcb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSum</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a71911fe28b7a192f255585195184cdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913e5d22d13fa7fccb0a4a667bbc1fc4"><td class="memItemLeft" align="right" valign="top"><a id="a913e5d22d13fa7fccb0a4a667bbc1fc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPolynomial</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a913e5d22d13fa7fccb0a4a667bbc1fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567a82e8a8f5882f3473c57686128ac1"><td class="memItemLeft" align="right" valign="top"><a id="a567a82e8a8f5882f3473c57686128ac1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsDerivative</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a567a82e8a8f5882f3473c57686128ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793fc1f53c48e3df00cb1c02e1391c98"><td class="memItemLeft" align="right" valign="top"><a id="a793fc1f53c48e3df00cb1c02e1391c98"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCommutator</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a793fc1f53c48e3df00cb1c02e1391c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c5c91f2b2b22f4d776c8fbcdcdde3c"><td class="memItemLeft" align="right" valign="top"><a id="ad8c5c91f2b2b22f4d776c8fbcdcdde3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsAngle</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:ad8c5c91f2b2b22f4d776c8fbcdcdde3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d760de5d09daf48243e6ec09ea505af"><td class="memItemLeft" align="right" valign="top"><a id="a3d760de5d09daf48243e6ec09ea505af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsFactorial</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a3d760de5d09daf48243e6ec09ea505af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e82d4b4347d30ba63604ff8068042ef"><td class="memItemLeft" align="right" valign="top"><a id="a1e82d4b4347d30ba63604ff8068042ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIntegral</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a1e82d4b4347d30ba63604ff8068042ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0839acde42ca07ef0e6b7a2f00769a"><td class="memItemLeft" align="right" valign="top"><a id="a8a0839acde42ca07ef0e6b7a2f00769a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsScalarIntegral</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a8a0839acde42ca07ef0e6b7a2f00769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bf984d6ebb21eaaf9e1c7bdddf3bcb"><td class="memItemLeft" align="right" valign="top"><a id="a65bf984d6ebb21eaaf9e1c7bdddf3bcb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVectorIntegral</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a65bf984d6ebb21eaaf9e1c7bdddf3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28027af3f53a7471ceeb8fadb8dd9f0"><td class="memItemLeft" align="right" valign="top"><a id="af28027af3f53a7471ceeb8fadb8dd9f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVector</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:af28027af3f53a7471ceeb8fadb8dd9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8762176402b32eef3abbff6c23b93ee8"><td class="memItemLeft" align="right" valign="top"><a id="a8762176402b32eef3abbff6c23b93ee8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsMatrix</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a8762176402b32eef3abbff6c23b93ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca50e143d0dddc1fcec29b70a0f3bfd"><td class="memItemLeft" align="right" valign="top"><a id="a0ca50e143d0dddc1fcec29b70a0f3bfd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsHighDTensor</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> expr)</td></tr>
<tr class="separator:a0ca50e143d0dddc1fcec29b70a0f3bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf713387a07a13348155f7043b55c933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#acf713387a07a13348155f7043b55c933">ApplySelfProperty</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, <a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;tensor, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;A, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;B, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;res)</td></tr>
<tr class="memdesc:acf713387a07a13348155f7043b55c933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a self contraction property just the time of a refresh in order to apply it on one expression.  <a href="#acf713387a07a13348155f7043b55c933">More...</a><br /></td></tr>
<tr class="separator:acf713387a07a13348155f7043b55c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d313d19ed9c1b6e4cfbefbb7af7169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a36d313d19ed9c1b6e4cfbefbb7af7169">ApplyChainProperty</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, <a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;tensor, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;prod, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;res)</td></tr>
<tr class="memdesc:a36d313d19ed9c1b6e4cfbefbb7af7169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a chain contraction property just the time of a refresh in order to apply it on one expression.  <a href="#a36d313d19ed9c1b6e4cfbefbb7af7169">More...</a><br /></td></tr>
<tr class="separator:a36d313d19ed9c1b6e4cfbefbb7af7169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1baa69edc83c2d90efd6f79bbdb0b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a9b1baa69edc83c2d90efd6f79bbdb0b4">CheckValidity</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, std::vector&lt; <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> &gt; encountered=std::vector&lt; <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> &gt;())</td></tr>
<tr class="memdesc:a9b1baa69edc83c2d90efd6f79bbdb0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the validity of an expression.  <a href="#a9b1baa69edc83c2d90efd6f79bbdb0b4">More...</a><br /></td></tr>
<tr class="separator:a9b1baa69edc83c2d90efd6f79bbdb0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769c039db45134ce7cbdd918da92273b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a769c039db45134ce7cbdd918da92273b">MemorySizeOf</a> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expression)</td></tr>
<tr class="memdesc:a769c039db45134ce7cbdd918da92273b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an estimate of the total memory that an expression takes.  <a href="#a769c039db45134ce7cbdd918da92273b">More...</a><br /></td></tr>
<tr class="separator:a769c039db45134ce7cbdd918da92273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5166050632365ea31dd98526321fe732"><td class="memItemLeft" align="right" valign="top"><a id="a5166050632365ea31dd98526321fe732"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddProperty</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;tensor, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;A, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;B, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;res)</td></tr>
<tr class="separator:a5166050632365ea31dd98526321fe732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e78f450ecfeca700efa0cd81919a80"><td class="memItemLeft" align="right" valign="top"><a id="aa1e78f450ecfeca700efa0cd81919a80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddProperty</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;tensor, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;product, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;res)</td></tr>
<tr class="separator:aa1e78f450ecfeca700efa0cd81919a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48da7694dd9795dbfe837896e1906cc8"><td class="memItemLeft" align="right" valign="top"><a id="a48da7694dd9795dbfe837896e1906cc8"></a>
const <a class="el" href="classcsl_1_1Space.html">csl::Space</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSpace</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> const &amp;tensor, int pos=0)</td></tr>
<tr class="separator:a48da7694dd9795dbfe837896e1906cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6399d0d3561e6f47274bce31ca740de7"><td class="memItemLeft" align="right" valign="top"><a id="a6399d0d3561e6f47274bce31ca740de7"></a>
<a class="el" href="classcsl_1_1Index.html">csl::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetIndex</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> const &amp;tensor, int pos=0)</td></tr>
<tr class="separator:a6399d0d3561e6f47274bce31ca740de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be80de8472a9225500a76b35bcfea62"><td class="memItemLeft" align="right" valign="top"><a id="a8be80de8472a9225500a76b35bcfea62"></a>
<a class="el" href="classcsl_1_1Index.html">csl::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetIndex</b> (<a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space)</td></tr>
<tr class="separator:a8be80de8472a9225500a76b35bcfea62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d73b7d4124c0a5cff5af54eb25ee275"><td class="memItemLeft" align="right" valign="top"><a id="a3d73b7d4124c0a5cff5af54eb25ee275"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetIndices</b> (size_t N, <a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space)</td></tr>
<tr class="separator:a3d73b7d4124c0a5cff5af54eb25ee275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55eeea239ab6fc3827cd49b0deaed41"><td class="memItemLeft" align="right" valign="top"><a id="af55eeea239ab6fc3827cd49b0deaed41"></a>
<a class="el" href="classcsl_1_1Index.html">csl::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetIndex</b> (<a class="el" href="classcsl_1_1Space.html">csl::Space</a> const &amp;space)</td></tr>
<tr class="separator:af55eeea239ab6fc3827cd49b0deaed41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c19e712134df4d3cd72201558cb87bf"><td class="memItemLeft" align="right" valign="top"><a id="a2c19e712134df4d3cd72201558cb87bf"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetIndices</b> (size_t N, <a class="el" href="classcsl_1_1Space.html">csl::Space</a> const &amp;space)</td></tr>
<tr class="separator:a2c19e712134df4d3cd72201558cb87bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5355ae57f5d973a78b8dc3d0034b7185"><td class="memItemLeft" align="right" valign="top"><a id="a5355ae57f5d973a78b8dc3d0034b7185"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetIndices</b> (size_t N, <a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> const &amp;tensor, int pos=0)</td></tr>
<tr class="separator:a5355ae57f5d973a78b8dc3d0034b7185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24e93760d56e33962ca45f294238fe7"><td class="memItemLeft" align="right" valign="top"><a id="ad24e93760d56e33962ca45f294238fe7"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetFullSetOfIndicesFor</b> (<a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> const &amp;tensor)</td></tr>
<tr class="separator:ad24e93760d56e33962ca45f294238fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537e8cc548abc8cc16d6a7a993221f4e"><td class="memItemLeft" align="right" valign="top"><a id="a537e8cc548abc8cc16d6a7a993221f4e"></a>
<a class="el" href="classcsl_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Unitary</b> (std::string const &amp;name, <a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space)</td></tr>
<tr class="separator:a537e8cc548abc8cc16d6a7a993221f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7fc6ff782da5e0c59dc98c1678e33b"><td class="memItemLeft" align="right" valign="top"><a id="a3c7fc6ff782da5e0c59dc98c1678e33b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TestIndexSanity</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr, bool verbose=false)</td></tr>
<tr class="separator:a3c7fc6ff782da5e0c59dc98c1678e33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8301d8df92dac9777367c7d16e91fd2"><td class="memItemLeft" align="right" valign="top"><a id="af8301d8df92dac9777367c7d16e91fd2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printCallableStructure</b> (std::ostream &amp;out)</td></tr>
<tr class="separator:af8301d8df92dac9777367c7d16e91fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b004ada1a49262b69febdc3f8ac931"><td class="memItemLeft" align="right" valign="top"><a id="a72b004ada1a49262b69febdc3f8ac931"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_libcomplexop_hdata</b> (std::ostream &amp;out)</td></tr>
<tr class="separator:a72b004ada1a49262b69febdc3f8ac931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8be4089a7741693c7a84ebb20b4e425"><td class="memItemLeft" align="right" valign="top"><a id="aa8be4089a7741693c7a84ebb20b4e425"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_libdiagonalization_cppdata</b> (std::ostream &amp;out)</td></tr>
<tr class="separator:aa8be4089a7741693c7a84ebb20b4e425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1825c01d4afa2677f372c511312c37f"><td class="memItemLeft" align="right" valign="top"><a id="ae1825c01d4afa2677f372c511312c37f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_libdiagonalization_hdata</b> (std::ostream &amp;out)</td></tr>
<tr class="separator:ae1825c01d4afa2677f372c511312c37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e1177fe1527ddb46b3b9b85b45257c"><td class="memItemLeft" align="right" valign="top"><a id="a03e1177fe1527ddb46b3b9b85b45257c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, <a class="el" href="structcsl_1_1LibEvalSession_1_1Perf.html">LibEvalSession::Perf</a> perf)</td></tr>
<tr class="separator:a03e1177fe1527ddb46b3b9b85b45257c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d64e2c80d73a47d1f5a9f150e1a2fd"><td class="memItemLeft" align="right" valign="top"><a id="a22d64e2c80d73a47d1f5a9f150e1a2fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="structcsl_1_1LibParameter.html">LibParameter</a> const &amp;A, <a class="el" href="structcsl_1_1LibParameter.html">LibParameter</a> const &amp;B)</td></tr>
<tr class="separator:a22d64e2c80d73a47d1f5a9f150e1a2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21746d4f85238c34a1ed019abffd0f8c"><td class="memItemLeft" align="right" valign="top"><a id="a21746d4f85238c34a1ed019abffd0f8c"></a>
std::vector&lt; <a class="el" href="structcsl_1_1LibParameter.html">LibParameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inputParams</b> (std::vector&lt; <a class="el" href="structcsl_1_1LibraryGenerator_1_1DiagonalizationData.html">LibraryGenerator::DiagonalizationData</a> &gt; const &amp;diagData)</td></tr>
<tr class="separator:a21746d4f85238c34a1ed019abffd0f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9536be54f590195c41829c0961b765eb"><td class="memItemLeft" align="right" valign="top"><a id="a9536be54f590195c41829c0961b765eb"></a>
std::vector&lt; <a class="el" href="structcsl_1_1LibParameter.html">LibParameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>outputParams</b> (std::vector&lt; <a class="el" href="structcsl_1_1LibraryGenerator_1_1DiagonalizationData.html">LibraryGenerator::DiagonalizationData</a> &gt; const &amp;diagData, std::vector&lt; std::string &gt; const &amp;massExpressions)</td></tr>
<tr class="separator:a9536be54f590195c41829c0961b765eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efbc4646fdc35ab36f804e395f90ce1"><td class="memItemLeft" align="right" valign="top"><a id="a0efbc4646fdc35ab36f804e395f90ce1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_librarytensor_hdata</b> (std::ostream &amp;out)</td></tr>
<tr class="separator:a0efbc4646fdc35ab36f804e395f90ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbc14af6671615ab035d1c56fdcc02a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a7fbc14af6671615ab035d1c56fdcc02a">intfactorial_s</a> (int value)</td></tr>
<tr class="separator:a7fbc14af6671615ab035d1c56fdcc02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a37fce062057444eea765a004bc180"><td class="memItemLeft" align="right" valign="top"><a id="a02a37fce062057444eea765a004bc180"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constant_s</b> (std::string const &amp;name, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop=<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1">csl::ComplexProperty::Real</a>)</td></tr>
<tr class="separator:a02a37fce062057444eea765a004bc180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa48ec0e9e78268c41f54f9e610463a"><td class="memItemLeft" align="right" valign="top"><a id="a7fa48ec0e9e78268c41f54f9e610463a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constant_s</b> (std::string const &amp;name, long double value, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop=<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1">csl::ComplexProperty::Real</a>)</td></tr>
<tr class="separator:a7fa48ec0e9e78268c41f54f9e610463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de4c749cd87049d977526b7897fe9e2"><td class="memItemLeft" align="right" valign="top"><a id="a4de4c749cd87049d977526b7897fe9e2"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constant_s</b> (std::string const &amp;name, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;value, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop=<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1">csl::ComplexProperty::Real</a>)</td></tr>
<tr class="separator:a4de4c749cd87049d977526b7897fe9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad650cc5bf3919186ad6fb17b67726e4a"><td class="memItemLeft" align="right" valign="top"><a id="ad650cc5bf3919186ad6fb17b67726e4a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variable_s</b> (std::string const &amp;name, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop=<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1">csl::ComplexProperty::Real</a>)</td></tr>
<tr class="separator:ad650cc5bf3919186ad6fb17b67726e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407c534d3534059bd6bd46bbd41758ae"><td class="memItemLeft" align="right" valign="top"><a id="a407c534d3534059bd6bd46bbd41758ae"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variable_s</b> (std::string const &amp;name, long double value, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop=<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1">csl::ComplexProperty::Real</a>)</td></tr>
<tr class="separator:a407c534d3534059bd6bd46bbd41758ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc179d7e1cfe3178fb8bd2b8e2dbfb78"><td class="memItemLeft" align="right" valign="top"><a id="adc179d7e1cfe3178fb8bd2b8e2dbfb78"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variable_s</b> (std::string const &amp;name, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;value, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop=<a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1">csl::ComplexProperty::Real</a>)</td></tr>
<tr class="separator:adc179d7e1cfe3178fb8bd2b8e2dbfb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5327d368e944125c5ffa58b304051751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a5327d368e944125c5ffa58b304051751">abs_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a5327d368e944125c5ffa58b304051751"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Abs.html" title="Final specialization of AbstractFunc, the abs function. ">Abs</a> acting on <b>expr</b>.  <a href="#a5327d368e944125c5ffa58b304051751">More...</a><br /></td></tr>
<tr class="separator:a5327d368e944125c5ffa58b304051751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677874110c8d7d3febc7f30085273e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a677874110c8d7d3febc7f30085273e6b">exp_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a677874110c8d7d3febc7f30085273e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Exp.html" title="Final specialization of AbstractFunc, the exponential function. ">Exp</a> acting on <b>expr</b>.  <a href="#a677874110c8d7d3febc7f30085273e6b">More...</a><br /></td></tr>
<tr class="separator:a677874110c8d7d3febc7f30085273e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a31d3871e8136ab04e15368528c846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a77a31d3871e8136ab04e15368528c846">log_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a77a31d3871e8136ab04e15368528c846"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Log.html" title="Final specialization of AbstractFunc, the logarithm function. ">Log</a> acting on <b>expr</b>.  <a href="#a77a31d3871e8136ab04e15368528c846">More...</a><br /></td></tr>
<tr class="separator:a77a31d3871e8136ab04e15368528c846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3033bff78373155994cbf45ec3e71493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a3033bff78373155994cbf45ec3e71493">cos_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a3033bff78373155994cbf45ec3e71493"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Cos.html" title="Final specialization of AbstractFunc, the cos function. ">Cos</a> acting on <b>expr</b>.  <a href="#a3033bff78373155994cbf45ec3e71493">More...</a><br /></td></tr>
<tr class="separator:a3033bff78373155994cbf45ec3e71493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f030b62fc81f11147493796bfa30b54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a5f030b62fc81f11147493796bfa30b54">sin_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a5f030b62fc81f11147493796bfa30b54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Sin.html" title="Final specialization of AbstractFunc, the sin function. ">Sin</a> acting on <b>expr</b>.  <a href="#a5f030b62fc81f11147493796bfa30b54">More...</a><br /></td></tr>
<tr class="separator:a5f030b62fc81f11147493796bfa30b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaab772a8fb873c65e06d079e73cd06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#afbaab772a8fb873c65e06d079e73cd06">tan_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:afbaab772a8fb873c65e06d079e73cd06"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Tan.html" title="Final specialization of AbstractFunc, the tan function. ">Tan</a> acting on <b>expr</b>.  <a href="#afbaab772a8fb873c65e06d079e73cd06">More...</a><br /></td></tr>
<tr class="separator:afbaab772a8fb873c65e06d079e73cd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f0625e0729c8516296eaa4e82a9928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a51f0625e0729c8516296eaa4e82a9928">acos_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a51f0625e0729c8516296eaa4e82a9928"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ACos.html" title="Final specialization of AbstractFunc, the acos function. ">ACos</a> acting on <b>expr</b>.  <a href="#a51f0625e0729c8516296eaa4e82a9928">More...</a><br /></td></tr>
<tr class="separator:a51f0625e0729c8516296eaa4e82a9928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fe6fa63f0b6cd80fd9edd625a715ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ac5fe6fa63f0b6cd80fd9edd625a715ad">asin_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ac5fe6fa63f0b6cd80fd9edd625a715ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ASin.html" title="Final specialization of AbstractFunc, the asin function. ">ASin</a> acting on <b>expr</b>.  <a href="#ac5fe6fa63f0b6cd80fd9edd625a715ad">More...</a><br /></td></tr>
<tr class="separator:ac5fe6fa63f0b6cd80fd9edd625a715ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a28054aa1541d982b05e4c90e22243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a55a28054aa1541d982b05e4c90e22243">atan_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a55a28054aa1541d982b05e4c90e22243"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ATan.html" title="Final specialization of AbstractFunc, the atan function. ">ATan</a> acting on <b>expr</b>.  <a href="#a55a28054aa1541d982b05e4c90e22243">More...</a><br /></td></tr>
<tr class="separator:a55a28054aa1541d982b05e4c90e22243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5869287cf8e8d58a895d81a9fbb126"><td class="memItemLeft" align="right" valign="top"><a id="a3a5869287cf8e8d58a895d81a9fbb126"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>angle_s</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;a, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;b)</td></tr>
<tr class="separator:a3a5869287cf8e8d58a895d81a9fbb126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f96bc23faf2e85278c67d2e77b02430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a9f96bc23faf2e85278c67d2e77b02430">cosh_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a9f96bc23faf2e85278c67d2e77b02430"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Cosh.html" title="Final specialization of AbstractFunc, the cosh function. ">Cosh</a> acting on <b>expr</b>.  <a href="#a9f96bc23faf2e85278c67d2e77b02430">More...</a><br /></td></tr>
<tr class="separator:a9f96bc23faf2e85278c67d2e77b02430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aab7af831ac14498b23ac3daa80d1d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a2aab7af831ac14498b23ac3daa80d1d5">sinh_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a2aab7af831ac14498b23ac3daa80d1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Sinh.html" title="Final specialization of AbstractFunc, the sinh function. ">Sinh</a> acting on <b>expr</b>.  <a href="#a2aab7af831ac14498b23ac3daa80d1d5">More...</a><br /></td></tr>
<tr class="separator:a2aab7af831ac14498b23ac3daa80d1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0975103bcda47f0e7a335677ba8e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a8a0975103bcda47f0e7a335677ba8e1f">tanh_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a8a0975103bcda47f0e7a335677ba8e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Tanh.html" title="Final specialization of AbstractFunc, the tanh function. ">Tanh</a> acting on <b>expr</b>.  <a href="#a8a0975103bcda47f0e7a335677ba8e1f">More...</a><br /></td></tr>
<tr class="separator:a8a0975103bcda47f0e7a335677ba8e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832f3758b9ec7e3f52e554b949c8acf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a832f3758b9ec7e3f52e554b949c8acf3">acosh_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a832f3758b9ec7e3f52e554b949c8acf3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ACosh.html" title="Final specialization of AbstractFunc, the acosh function. ">ACosh</a> acting on <b>expr</b>.  <a href="#a832f3758b9ec7e3f52e554b949c8acf3">More...</a><br /></td></tr>
<tr class="separator:a832f3758b9ec7e3f52e554b949c8acf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d17a63615e912a201b11ce163b9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a6f8d17a63615e912a201b11ce163b9dd">asinh_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a6f8d17a63615e912a201b11ce163b9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ASinh.html" title="Final specialization of AbstractFunc, the asinh function. ">ASinh</a> acting on <b>expr</b>.  <a href="#a6f8d17a63615e912a201b11ce163b9dd">More...</a><br /></td></tr>
<tr class="separator:a6f8d17a63615e912a201b11ce163b9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d65507d0aa73726a4f0969ba1134be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ac7d65507d0aa73726a4f0969ba1134be">atanh_s</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ac7d65507d0aa73726a4f0969ba1134be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ATanh.html" title="Final specialization of AbstractFunc, the atanh function. ">ATanh</a> acting on <b>expr</b>.  <a href="#ac7d65507d0aa73726a4f0969ba1134be">More...</a><br /></td></tr>
<tr class="separator:ac7d65507d0aa73726a4f0969ba1134be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58378a628b9b1e36084a3ca390de5a2"><td class="memItemLeft" align="right" valign="top"><a id="ae58378a628b9b1e36084a3ca390de5a2"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>factorial_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:ae58378a628b9b1e36084a3ca390de5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4ecd345db35bd025708f5e2209bbfd"><td class="memItemLeft" align="right" valign="top"><a id="a0f4ecd345db35bd025708f5e2209bbfd"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>diracdelta_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;argument)</td></tr>
<tr class="separator:a0f4ecd345db35bd025708f5e2209bbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e81b858e74ec884420ae98f4f5f1b14"><td class="memItemLeft" align="right" valign="top"><a id="a8e81b858e74ec884420ae98f4f5f1b14"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>float_s</b> (long double value)</td></tr>
<tr class="separator:a8e81b858e74ec884420ae98f4f5f1b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6ff04727d10c4a9b975f17996bcd46"><td class="memItemLeft" align="right" valign="top"><a id="a1f6ff04727d10c4a9b975f17996bcd46"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>int_s</b> (long long int value)</td></tr>
<tr class="separator:a1f6ff04727d10c4a9b975f17996bcd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c198badb2a6d2b98b49136ddd9e8b22"><td class="memItemLeft" align="right" valign="top"><a id="a6c198badb2a6d2b98b49136ddd9e8b22"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>autonumber_s</b> (long double value)</td></tr>
<tr class="separator:a6c198badb2a6d2b98b49136ddd9e8b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f5583f252a667f46719dd45c434924"><td class="memItemLeft" align="right" valign="top"><a id="a30f5583f252a667f46719dd45c434924"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>intfraction_s</b> (long long int num, long long int denom)</td></tr>
<tr class="separator:a30f5583f252a667f46719dd45c434924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2284a5aa4e5ff248cbcd942f0a9e74"><td class="memItemLeft" align="right" valign="top"><a id="a7b2284a5aa4e5ff248cbcd942f0a9e74"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>complex_s</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;real, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;imag)</td></tr>
<tr class="separator:a7b2284a5aa4e5ff248cbcd942f0a9e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019d8ee98ee45f4ea322a33b0b5b8e03"><td class="memItemLeft" align="right" valign="top"><a id="a019d8ee98ee45f4ea322a33b0b5b8e03"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numericaleval_s</b> (long double value, long double delta_plus)</td></tr>
<tr class="separator:a019d8ee98ee45f4ea322a33b0b5b8e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6468abc45600f7ee51b2406415504d"><td class="memItemLeft" align="right" valign="top"><a id="abf6468abc45600f7ee51b2406415504d"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numericaleval_s</b> (long double value, long double delta_plus, long double delta_minus)</td></tr>
<tr class="separator:abf6468abc45600f7ee51b2406415504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a57422d68bb34771dc9978b5f841e2"><td class="memTemplParams" colspan="2"><a id="a12a57422d68bb34771dc9978b5f841e2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a12a57422d68bb34771dc9978b5f841e2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;fout, const <a class="el" href="classcsl_1_1ObjectPermutation.html">ObjectPermutation</a>&lt; T &gt; &amp;perm)</td></tr>
<tr class="separator:a12a57422d68bb34771dc9978b5f841e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbd6fefc0fcb5fd5b701833fdf483d2"><td class="memTemplParams" colspan="2"><a id="a0bbd6fefc0fcb5fd5b701833fdf483d2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0bbd6fefc0fcb5fd5b701833fdf483d2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;fout, const <a class="el" href="classcsl_1_1ObjectSymmetry.html">ObjectSymmetry</a>&lt; T &gt; &amp;sym)</td></tr>
<tr class="separator:a0bbd6fefc0fcb5fd5b701833fdf483d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113b6a95fdf142a89734f25f30205aa5"><td class="memItemLeft" align="right" valign="top"><a id="a113b6a95fdf142a89734f25f30205aa5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getExponentStructure</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;argument, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;term, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;exponent)</td></tr>
<tr class="separator:a113b6a95fdf142a89734f25f30205aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdebee488b22c2dc74e7c6fb4e0ed0d5"><td class="memItemLeft" align="right" valign="top"><a id="acdebee488b22c2dc74e7c6fb4e0ed0d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyOperator</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;product)</td></tr>
<tr class="separator:acdebee488b22c2dc74e7c6fb4e0ed0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac510c2f73f168edd547c98bed8034e61"><td class="memItemLeft" align="right" valign="top"><a id="ac510c2f73f168edd547c98bed8034e61"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tensor_s</b> (const std::vector&lt; int &gt; &amp;shape, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;filler)</td></tr>
<tr class="separator:ac510c2f73f168edd547c98bed8034e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e555e3ffb0831348ca4e0635f476663"><td class="memItemLeft" align="right" valign="top"><a id="a4e555e3ffb0831348ca4e0635f476663"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pullLeft</b> (csl::vector_expr &amp;argument, size_t pos, size_t &amp;begin)</td></tr>
<tr class="separator:a4e555e3ffb0831348ca4e0635f476663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ca267a1d73b0df869e624c1a081d0f"><td class="memItemLeft" align="right" valign="top"><a id="a71ca267a1d73b0df869e624c1a081d0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pullRight</b> (csl::vector_expr &amp;argument, size_t &amp;pos, size_t &amp;end)</td></tr>
<tr class="separator:a71ca267a1d73b0df869e624c1a081d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01860bd23e3776aff3f1a3e43e040fb4"><td class="memItemLeft" align="right" valign="top"><a id="a01860bd23e3776aff3f1a3e43e040fb4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getParts</b> (const csl::vector_expr &amp;argument, size_t begin, size_t end, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;left, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;mid, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;right)</td></tr>
<tr class="separator:a01860bd23e3776aff3f1a3e43e040fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c9913d2f70c338a23882d6f83cf347"><td class="memItemLeft" align="right" valign="top"><a id="a90c9913d2f70c338a23882d6f83cf347"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>haveCommonIndices</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;a, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;b, <a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *space)</td></tr>
<tr class="separator:a90c9913d2f70c338a23882d6f83cf347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581930a9e8ef60ba4ccde160f46f8b1c"><td class="memItemLeft" align="right" valign="top"><a id="a581930a9e8ef60ba4ccde160f46f8b1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpandImplementation</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;prod, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</td></tr>
<tr class="separator:a581930a9e8ef60ba4ccde160f46f8b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761409fd06a017d848cc04d4c7a7ad9c"><td class="memItemLeft" align="right" valign="top"><a id="a761409fd06a017d848cc04d4c7a7ad9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpandImplementation</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;prod, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</td></tr>
<tr class="separator:a761409fd06a017d848cc04d4c7a7ad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623c52c8d2c4930f73f68c579eb853fa"><td class="memItemLeft" align="right" valign="top"><a id="a623c52c8d2c4930f73f68c579eb853fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpandImplementation</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;prod, ExpanderEmitter const &amp;isEmitterReceiver)</td></tr>
<tr class="separator:a623c52c8d2c4930f73f68c579eb853fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828d00aa38a5cb04ac9df50cf64a0c26"><td class="memItemLeft" align="right" valign="top"><a id="a828d00aa38a5cb04ac9df50cf64a0c26"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpanded</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</td></tr>
<tr class="separator:a828d00aa38a5cb04ac9df50cf64a0c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7530a412075a5a8372f298c55c2a72f"><td class="memItemLeft" align="right" valign="top"><a id="ae7530a412075a5a8372f298c55c2a72f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</td></tr>
<tr class="separator:ae7530a412075a5a8372f298c55c2a72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf22e1622a9b202a9eb06251212a918"><td class="memItemLeft" align="right" valign="top"><a id="abaf22e1622a9b202a9eb06251212a918"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepPartialExpanded</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</td></tr>
<tr class="separator:abaf22e1622a9b202a9eb06251212a918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac390377ac85216c687973cf55044a15"><td class="memItemLeft" align="right" valign="top"><a id="aac390377ac85216c687973cf55044a15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepPartialExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver)</td></tr>
<tr class="separator:aac390377ac85216c687973cf55044a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51cab5644c4ea063e2dd6c6e81ec3c0"><td class="memItemLeft" align="right" valign="top"><a id="ad51cab5644c4ea063e2dd6c6e81ec3c0"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpanded</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</td></tr>
<tr class="separator:ad51cab5644c4ea063e2dd6c6e81ec3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b4e902bc3d08c3d8dd8656f876a356"><td class="memItemLeft" align="right" valign="top"><a id="a03b4e902bc3d08c3d8dd8656f876a356"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</td></tr>
<tr class="separator:a03b4e902bc3d08c3d8dd8656f876a356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8344257ba4df866eb26909f43df213be"><td class="memItemLeft" align="right" valign="top"><a id="a8344257ba4df866eb26909f43df213be"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepPartialExpanded</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</td></tr>
<tr class="separator:a8344257ba4df866eb26909f43df213be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed32c5f631808284919014f0377cd011"><td class="memItemLeft" align="right" valign="top"><a id="aed32c5f631808284919014f0377cd011"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepPartialExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, ExpanderEmitter const &amp;isEmitter, ExpanderEmitter const &amp;isReceiver)</td></tr>
<tr class="separator:aed32c5f631808284919014f0377cd011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05686d056ffec54b490ca1d2467bf7a"><td class="memItemLeft" align="right" valign="top"><a id="af05686d056ffec54b490ca1d2467bf7a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpanded</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, ExpanderEmitter const &amp;isEmitter)</td></tr>
<tr class="separator:af05686d056ffec54b490ca1d2467bf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a601398238ce0f6f930b34b2b42ea1e"><td class="memItemLeft" align="right" valign="top"><a id="a1a601398238ce0f6f930b34b2b42ea1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PartialExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, ExpanderEmitter const &amp;isEmitter)</td></tr>
<tr class="separator:a1a601398238ce0f6f930b34b2b42ea1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1943ccff7f928b3bb290065b6e8e5c12"><td class="memItemLeft" align="right" valign="top"><a id="a1943ccff7f928b3bb290065b6e8e5c12"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DeepPartialExpanded</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, ExpanderEmitter const &amp;isEmitter)</td></tr>
<tr class="separator:a1943ccff7f928b3bb290065b6e8e5c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ca880f3db2212f1f18622aadd8e3ee"><td class="memItemLeft" align="right" valign="top"><a id="a55ca880f3db2212f1f18622aadd8e3ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepPartialExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, ExpanderEmitter const &amp;isEmitter)</td></tr>
<tr class="separator:a55ca880f3db2212f1f18622aadd8e3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f7791539aae1c98587db2f770f9cf2"><td class="memItemLeft" align="right" valign="top"><a id="aa1f7791539aae1c98587db2f770f9cf2"></a>
std::pair&lt; <a class="el" href="classcsl_1_1int__ap.html">int_ap</a>&lt; 2 &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>decomposeLongFloat</b> (long double number)</td></tr>
<tr class="separator:aa1f7791539aae1c98587db2f770f9cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6539c28a14270bdb022ce53318528fd1"><td class="memItemLeft" align="right" valign="top"><a id="a6539c28a14270bdb022ce53318528fd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillDigits</b> (const std::vector&lt; short &gt; &amp;digits, std::vector&lt; short &gt; &amp;receiver)</td></tr>
<tr class="separator:a6539c28a14270bdb022ce53318528fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd685197ac08fa6a7b35fb5e29da84d7"><td class="memTemplParams" colspan="2"><a id="acd685197ac08fa6a7b35fb5e29da84d7"></a>
template&lt;const size_t base&gt; </td></tr>
<tr class="memitem:acd685197ac08fa6a7b35fb5e29da84d7"><td class="memTemplItemLeft" align="right" valign="top">long double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log</b> (long double x)</td></tr>
<tr class="separator:acd685197ac08fa6a7b35fb5e29da84d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8eec8abed24cf348f9be3336c91f28"><td class="memItemLeft" align="right" valign="top"><a id="afb8eec8abed24cf348f9be3336c91f28"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>convertDigit</b> (short digit)</td></tr>
<tr class="separator:afb8eec8abed24cf348f9be3336c91f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd347e458acc97e685329e6d85760ef9"><td class="memTemplParams" colspan="2"><a id="afd347e458acc97e685329e6d85760ef9"></a>
template&lt;size_t base&gt; </td></tr>
<tr class="memitem:afd347e458acc97e685329e6d85760ef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1int__ap.html">int_ap</a>&lt; base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>factorial</b> (const <a class="el" href="classcsl_1_1int__ap.html">int_ap</a>&lt; base &gt; &amp;number)</td></tr>
<tr class="separator:afd347e458acc97e685329e6d85760ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05fcc3dc932d703d52ba5889a8314c5"><td class="memItemLeft" align="right" valign="top"><a id="ad05fcc3dc932d703d52ba5889a8314c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MakeIntegral</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init)</td></tr>
<tr class="separator:ad05fcc3dc932d703d52ba5889a8314c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fb6c03f69d9150fdc5552ab3492ea7"><td class="memTemplParams" colspan="2"><a id="a65fb6c03f69d9150fdc5552ab3492ea7"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a65fb6c03f69d9150fdc5552ab3492ea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scalarintegral_s</b> (Args ...args)</td></tr>
<tr class="separator:a65fb6c03f69d9150fdc5552ab3492ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb880e44ce2aa995cf4c48b15fa2f13"><td class="memItemLeft" align="right" valign="top"><a id="a3cb880e44ce2aa995cf4c48b15fa2f13"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vectorintegral_s</b> (const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;variables)</td></tr>
<tr class="separator:a3cb880e44ce2aa995cf4c48b15fa2f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d25b152139279dfe461c88ffe0740f8"><td class="memTemplParams" colspan="2"><a id="a2d25b152139279dfe461c88ffe0740f8"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a2d25b152139279dfe461c88ffe0740f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorintegral_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand, const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;variables, Args... args)</td></tr>
<tr class="separator:a2d25b152139279dfe461c88ffe0740f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acc43ce5e5aad372bf3ba7a1e397162"><td class="memTemplParams" colspan="2"><a id="a6acc43ce5e5aad372bf3ba7a1e397162"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a6acc43ce5e5aad372bf3ba7a1e397162"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorintegral_s</b> (const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;variables, Args... args)</td></tr>
<tr class="separator:a6acc43ce5e5aad372bf3ba7a1e397162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1945e37f740cebc9c2e43f52ef72ba9"><td class="memItemLeft" align="right" valign="top"><a id="ae1945e37f740cebc9c2e43f52ef72ba9"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vectorintegral_s</b> (const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;variables)</td></tr>
<tr class="separator:ae1945e37f740cebc9c2e43f52ef72ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36e387cbfb4da55af4853831c5ad919"><td class="memTemplParams" colspan="2"><a id="ad36e387cbfb4da55af4853831c5ad919"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ad36e387cbfb4da55af4853831c5ad919"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorintegral_s</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;operand, const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;variables, Args... args)</td></tr>
<tr class="separator:ad36e387cbfb4da55af4853831c5ad919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2031c89182609d1d769e0fd9ace2a020"><td class="memTemplParams" colspan="2"><a id="a2031c89182609d1d769e0fd9ace2a020"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a2031c89182609d1d769e0fd9ace2a020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorintegral_s</b> (const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;variables, Args... args)</td></tr>
<tr class="separator:a2031c89182609d1d769e0fd9ace2a020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19a4a894ef3884cb6cda68f5d092227"><td class="memItemLeft" align="right" valign="top"><a id="af19a4a894ef3884cb6cda68f5d092227"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;from, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;to)</td></tr>
<tr class="separator:af19a4a894ef3884cb6cda68f5d092227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928a62a7797c0600e507354c75bacc81"><td class="memItemLeft" align="right" valign="top"><a id="a928a62a7797c0600e507354c75bacc81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> const &amp;from, <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> const &amp;to)</td></tr>
<tr class="separator:a928a62a7797c0600e507354c75bacc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed301552ca6117976c2c8db06df6f03"><td class="memItemLeft" align="right" valign="top"><a id="aeed301552ca6117976c2c8db06df6f03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> const &amp;from, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;to)</td></tr>
<tr class="separator:aeed301552ca6117976c2c8db06df6f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c327742707f6732e9436b65b9c3f0f6"><td class="memItemLeft" align="right" valign="top"><a id="a7c327742707f6732e9436b65b9c3f0f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> &gt; const &amp;to)</td></tr>
<tr class="separator:a7c327742707f6732e9436b65b9c3f0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7799d21056038c2e6e7e8940e6a8b019"><td class="memItemLeft" align="right" valign="top"><a id="a7799d21056038c2e6e7e8940e6a8b019"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;to)</td></tr>
<tr class="separator:a7799d21056038c2e6e7e8940e6a8b019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64382d0f012ea0da49c04b3d5180fbf0"><td class="memItemLeft" align="right" valign="top"><a id="a64382d0f012ea0da49c04b3d5180fbf0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceIndicial</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;to)</td></tr>
<tr class="separator:a64382d0f012ea0da49c04b3d5180fbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accec01baa0856a6db7dcc917941b5113"><td class="memItemLeft" align="right" valign="top"><a id="accec01baa0856a6db7dcc917941b5113"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;to, bool refresh=true)</td></tr>
<tr class="separator:accec01baa0856a6db7dcc917941b5113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8e3919d773b1c8c20c3d634aa343a9"><td class="memTemplParams" colspan="2"><a id="a9d8e3919d773b1c8c20c3d634aa343a9"></a>
template&lt;class T , class U , class ... Params, typename  = std::enable_if_t&lt;                !csl::canDecay_v&lt;T, U, csl::Index&gt;                &amp;&amp; !csl::canDecay_v&lt;T, U, csl::IndexStructure&gt;                &amp;&amp; !csl::canDecay_v&lt;T, U, std::vector&lt;csl::Index&gt;&gt;                &gt;&gt; </td></tr>
<tr class="memitem:a9d8e3919d773b1c8c20c3d634aa343a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Replaced</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, T &amp;&amp;p1, U &amp;&amp;p2, Params &amp;&amp;...params)</td></tr>
<tr class="separator:a9d8e3919d773b1c8c20c3d634aa343a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f249cf7f73f3dc6e2f3eac909098602"><td class="memItemLeft" align="right" valign="top"><a id="a0f249cf7f73f3dc6e2f3eac909098602"></a>
<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Replaced</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, <a class="el" href="classcsl_1_1Index.html">csl::Index</a> const &amp;from, <a class="el" href="classcsl_1_1Index.html">csl::Index</a> const &amp;to, bool refresh=true)</td></tr>
<tr class="separator:a0f249cf7f73f3dc6e2f3eac909098602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4778e32b6eb23d0cebe39dcbcfdc19e8"><td class="memItemLeft" align="right" valign="top"><a id="a4778e32b6eb23d0cebe39dcbcfdc19e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, <a class="el" href="classcsl_1_1Index.html">csl::Index</a> const &amp;from, <a class="el" href="classcsl_1_1Index.html">csl::Index</a> const &amp;to, bool refresh=true)</td></tr>
<tr class="separator:a4778e32b6eb23d0cebe39dcbcfdc19e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdabccbbebf2f270e78e857e01e9ac7"><td class="memItemLeft" align="right" valign="top"><a id="a8bdabccbbebf2f270e78e857e01e9ac7"></a>
<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Replaced</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; const &amp;to, bool refresh=true)</td></tr>
<tr class="separator:a8bdabccbbebf2f270e78e857e01e9ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e074a686822f704a46b1c3d3d31ba87"><td class="memItemLeft" align="right" valign="top"><a id="a0e074a686822f704a46b1c3d3d31ba87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; const &amp;to, bool refresh=true)</td></tr>
<tr class="separator:a0e074a686822f704a46b1c3d3d31ba87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c1033c7bce7f51b2ef540e828e43ea"><td class="memItemLeft" align="right" valign="top"><a id="a24c1033c7bce7f51b2ef540e828e43ea"></a>
<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Replaced</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, <a class="el" href="classcsl_1_1IndexStructure.html">csl::IndexStructure</a> const &amp;from, <a class="el" href="classcsl_1_1IndexStructure.html">csl::IndexStructure</a> const &amp;to, bool refresh=true)</td></tr>
<tr class="separator:a24c1033c7bce7f51b2ef540e828e43ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea0cca96e24945e7f10fa51a6b31f55"><td class="memItemLeft" align="right" valign="top"><a id="afea0cca96e24945e7f10fa51a6b31f55"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, <a class="el" href="classcsl_1_1IndexStructure.html">csl::IndexStructure</a> const &amp;from, <a class="el" href="classcsl_1_1IndexStructure.html">csl::IndexStructure</a> const &amp;to, bool refresh=true)</td></tr>
<tr class="separator:afea0cca96e24945e7f10fa51a6b31f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc696cee24297cc1ca72e9ce5cfae806"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#abc696cee24297cc1ca72e9ce5cfae806">ruleToPredicate</a> (<a class="el" href="namespacecsl.html#aa804192228c299d8b648e4dc194cb689">replacementRule</a> const &amp;rule)</td></tr>
<tr class="memdesc:abc696cee24297cc1ca72e9ce5cfae806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a replacementRule into a predicate.  <a href="#abc696cee24297cc1ca72e9ce5cfae806">More...</a><br /></td></tr>
<tr class="separator:abc696cee24297cc1ca72e9ce5cfae806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b6337073b66a62d69827fd9246f092"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a65b6337073b66a62d69827fd9246f092">hasWeakDependency</a> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;)&gt; const &amp;predicate)</td></tr>
<tr class="memdesc:a65b6337073b66a62d69827fd9246f092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a true value for a given predicate in an expression, considering also sub-expressions encapsulated by abbreviations.  <a href="#a65b6337073b66a62d69827fd9246f092">More...</a><br /></td></tr>
<tr class="separator:a65b6337073b66a62d69827fd9246f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178cb5ff11ecfb69f32bbdea3253712a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a178cb5ff11ecfb69f32bbdea3253712a">applyThroughAbbreviations</a> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, <a class="el" href="namespacecsl.html#aa804192228c299d8b648e4dc194cb689">replacementRule</a> const &amp;rule)</td></tr>
<tr class="memdesc:a178cb5ff11ecfb69f32bbdea3253712a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a replacement rule thoughout an expression, also entering abbreviations and replacing them if a replacement is found.  <a href="#a178cb5ff11ecfb69f32bbdea3253712a">More...</a><br /></td></tr>
<tr class="separator:a178cb5ff11ecfb69f32bbdea3253712a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d511b748fb0264b448b6757d78846b"><td class="memItemLeft" align="right" valign="top"><a id="af1d511b748fb0264b448b6757d78846b"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scalarReplacement</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;ccFrom, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;to, bool isPredicate)</td></tr>
<tr class="separator:af1d511b748fb0264b448b6757d78846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9816bee914b3eb4f9183212664c505b"><td class="memItemLeft" align="right" valign="top"><a id="aa9816bee914b3eb4f9183212664c505b"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>indicialReplacement</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1AbstractParent.html">csl::Parent_info</a> &gt; const &amp;parentFrom, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;to, bool isPredicate)</td></tr>
<tr class="separator:aa9816bee914b3eb4f9183212664c505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a995aa2bcb8419ccb42c95baf51fa5"><td class="memItemLeft" align="right" valign="top"><a id="a33a995aa2bcb8419ccb42c95baf51fa5"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tensorReplacement</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> &gt; const &amp;to, bool isPredicate)</td></tr>
<tr class="separator:a33a995aa2bcb8419ccb42c95baf51fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4789033cbd37c9f98055c332e342bee"><td class="memItemLeft" align="right" valign="top"><a id="aa4789033cbd37c9f98055c332e342bee"></a>
std::optional&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tensorExpressionReplacement</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1Parent.html">csl::Parent</a> &gt; const &amp;from, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;to, bool isPredicate)</td></tr>
<tr class="separator:aa4789033cbd37c9f98055c332e342bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded19f239ae47cf9919876b0ba4131b7"><td class="memItemLeft" align="right" valign="top"><a id="aded19f239ae47cf9919876b0ba4131b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetDummyIndices</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr)</td></tr>
<tr class="separator:aded19f239ae47cf9919876b0ba4131b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355bea73616827d1164fd3944cb3a716"><td class="memItemLeft" align="right" valign="top"><a id="a355bea73616827d1164fd3944cb3a716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyIndices</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, <a class="el" href="classcsl_1_1IndexStructure.html">csl::IndexStructure</a> const &amp;structure)</td></tr>
<tr class="separator:a355bea73616827d1164fd3944cb3a716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfe96415afe869c8e4d414099fdc4c8"><td class="memItemLeft" align="right" valign="top"><a id="adbfe96415afe869c8e4d414099fdc4c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyIndices</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, <a class="el" href="classcsl_1_1IndexStructure.html">csl::IndexStructure</a> const &amp;from, <a class="el" href="classcsl_1_1IndexStructure.html">csl::IndexStructure</a> const &amp;to)</td></tr>
<tr class="separator:adbfe96415afe869c8e4d414099fdc4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52740687b676803d51f5f2b12c66c65b"><td class="memItemLeft" align="right" valign="top"><a id="a52740687b676803d51f5f2b12c66c65b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>renameIndex</b> (<a class="el" href="classcsl_1_1Index.html">csl::Index</a> &amp;index, std::map&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a>, <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; &amp;mapping)</td></tr>
<tr class="separator:a52740687b676803d51f5f2b12c66c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5cc29e454cbdff48a4ac3f365d0aad"><td class="memItemLeft" align="right" valign="top"><a id="a5d5cc29e454cbdff48a4ac3f365d0aad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RenameIndices</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr)</td></tr>
<tr class="separator:a5d5cc29e454cbdff48a4ac3f365d0aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe92af6e2c7997b1d37e45b56a681d8b"><td class="memItemLeft" align="right" valign="top"><a id="abe92af6e2c7997b1d37e45b56a681d8b"></a>
<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RenamedIndices</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr)</td></tr>
<tr class="separator:abe92af6e2c7997b1d37e45b56a681d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4521d40132faa978335ef90f8dd471"><td class="memItemLeft" align="right" valign="top"><a id="a4c4521d40132faa978335ef90f8dd471"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>internal_RenameIndices</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;expr, std::map&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a>, <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; &amp;mapping)</td></tr>
<tr class="separator:a4c4521d40132faa978335ef90f8dd471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c3c8469afcd37ca562ae8e845ff785"><td class="memTemplParams" colspan="2"><a id="a42c3c8469afcd37ca562ae8e845ff785"></a>
template&lt;class ParentType , typename  = std::enable_if_t&lt;std::is_convertible_v&lt;ParentType, Parent&gt;&gt;&gt; </td></tr>
<tr class="memitem:a42c3c8469afcd37ca562ae8e845ff785"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, std::vector&lt; ParentType &gt; const &amp;t_from, std::vector&lt; ParentType &gt; const &amp;t_to)</td></tr>
<tr class="separator:a42c3c8469afcd37ca562ae8e845ff785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc22b5410622d6421c615680536a9b68"><td class="memTemplParams" colspan="2"><a id="adc22b5410622d6421c615680536a9b68"></a>
template&lt;class ParentType , typename  = std::enable_if_t&lt;std::is_convertible_v&lt;ParentType, Parent&gt;&gt;&gt; </td></tr>
<tr class="memitem:adc22b5410622d6421c615680536a9b68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, std::vector&lt; ParentType &gt; const &amp;t_from, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;to)</td></tr>
<tr class="separator:adc22b5410622d6421c615680536a9b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96fd2b9759fc338d243821b5084d365"><td class="memTemplParams" colspan="2"><a id="ad96fd2b9759fc338d243821b5084d365"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:ad96fd2b9759fc338d243821b5084d365"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Tried</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ad96fd2b9759fc338d243821b5084d365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eca0c54494b784f3c91b1744ee0f75"><td class="memTemplParams" colspan="2"><a id="ae4eca0c54494b784f3c91b1744ee0f75"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:ae4eca0c54494b784f3c91b1744ee0f75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Try</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ae4eca0c54494b784f3c91b1744ee0f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37acbd47492bfc9ccef00d998d3a8c1b"><td class="memItemLeft" align="right" valign="top"><a id="a37acbd47492bfc9ccef00d998d3a8c1b"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;left, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;right)</td></tr>
<tr class="separator:a37acbd47492bfc9ccef00d998d3a8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab212e3a250819d11a12e4ad019a3b7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aab212e3a250819d11a12e4ad019a3b7e">printVector</a> (const csl::vector_expr &amp;vector)</td></tr>
<tr class="memdesc:aab212e3a250819d11a12e4ad019a3b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a vector of expressions. Useful in debug.  <a href="#aab212e3a250819d11a12e4ad019a3b7e">More...</a><br /></td></tr>
<tr class="separator:aab212e3a250819d11a12e4ad019a3b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89467d6317ff64a05858dca96a08479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae89467d6317ff64a05858dca96a08479">addAlternateForm</a> (csl::vector_expr &amp;alternateForms, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;newAlternate, bool add_factor_expand=true)</td></tr>
<tr class="memdesc:ae89467d6317ff64a05858dca96a08479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tried to add <b>newAlternate</b> in the set <b>alternateForms</b>. We simply test if the alternate is already present in the set <b>newAlternate</b> and add it if it is not the case. If <b>add_factor_expand</b> is set to <b>true</b>, we try to add the expanded and the factored forms of <b>newAlternate</b>.  <a href="#ae89467d6317ff64a05858dca96a08479">More...</a><br /></td></tr>
<tr class="separator:ae89467d6317ff64a05858dca96a08479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045a1acfa56caebfe583aea20e4222ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a045a1acfa56caebfe583aea20e4222ea">reduceAlternate</a> (csl::vector_expr &amp;alternateForms)</td></tr>
<tr class="memdesc:a045a1acfa56caebfe583aea20e4222ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the number of elements in <b>alternateForms</b> to MAX_ALTERNATE_FORMS.  <a href="#a045a1acfa56caebfe583aea20e4222ea">More...</a><br /></td></tr>
<tr class="separator:a045a1acfa56caebfe583aea20e4222ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84f9c884b931374b8cd46405ed164bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae84f9c884b931374b8cd46405ed164bf">clearRedundancyAlternate</a> (csl::vector_expr &amp;alternateForms)</td></tr>
<tr class="memdesc:ae84f9c884b931374b8cd46405ed164bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search and remove redundancies (equal alternate forms) in <b>alternateForms</b>.  <a href="#ae84f9c884b931374b8cd46405ed164bf">More...</a><br /></td></tr>
<tr class="separator:ae84f9c884b931374b8cd46405ed164bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d59a363192eb0486d9c16523f18fe4"><td class="memItemLeft" align="right" valign="top">csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a46d59a363192eb0486d9c16523f18fe4">getRecursiveAlternateForms</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, int depth=-1)</td></tr>
<tr class="memdesc:a46d59a363192eb0486d9c16523f18fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the alternate forms of <b>expr</b> by applying recursively <a class="el" href="namespacecsl.html#a49e7a13843443f95754c860cb4e92173" title="Calculates and return all alternate forms of expr, by getting (once) alternate forms of the possible ...">internalRecursiveAlternateForms()</a> MAX_RECURSION_ALTERNATE times: take alternates, then alternates of the alternates etc.  <a href="#a46d59a363192eb0486d9c16523f18fe4">More...</a><br /></td></tr>
<tr class="separator:a46d59a363192eb0486d9c16523f18fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e7a13843443f95754c860cb4e92173"><td class="memItemLeft" align="right" valign="top">csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a49e7a13843443f95754c860cb4e92173">internalRecursiveAlternateForms</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, int depth=-1)</td></tr>
<tr class="memdesc:a49e7a13843443f95754c860cb4e92173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and return all alternate forms of <b>expr</b>, by getting (once) alternate forms of the possible arguments of <b>expr</b>, and then the specific alternates of expr.  <a href="#a49e7a13843443f95754c860cb4e92173">More...</a><br /></td></tr>
<tr class="separator:a49e7a13843443f95754c860cb4e92173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27c8d3dd60c235e3e804b97790110ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ad27c8d3dd60c235e3e804b97790110ab">Simplify</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, int depth=-1)</td></tr>
<tr class="memdesc:ad27c8d3dd60c235e3e804b97790110ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Simplifies</b> <b>expr</b> depending on its type.  <a href="#ad27c8d3dd60c235e3e804b97790110ab">More...</a><br /></td></tr>
<tr class="separator:ad27c8d3dd60c235e3e804b97790110ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70f950e47354a4ec998afaa094c817"><td class="memItemLeft" align="right" valign="top"><a id="a3c70f950e47354a4ec998afaa094c817"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfMutatingNodes</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a3c70f950e47354a4ec998afaa094c817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4336753df953d3d5c7e52694d914a9f"><td class="memItemLeft" align="right" valign="top"><a id="af4336753df953d3d5c7e52694d914a9f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insertSortMutant</b> (csl::vector_expr &amp;vec, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;newExpr)</td></tr>
<tr class="separator:af4336753df953d3d5c7e52694d914a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8f1cb2db822c5166d7bbfc7446c027"><td class="memItemLeft" align="right" valign="top"><a id="a9a8f1cb2db822c5166d7bbfc7446c027"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addMutants</b> (csl::vector_expr &amp;individuals, const csl::vector_expr &amp;mutants)</td></tr>
<tr class="separator:a9a8f1cb2db822c5166d7bbfc7446c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3253879ee0318d8744a16949355ad113"><td class="memItemLeft" align="right" valign="top"><a id="a3253879ee0318d8744a16949355ad113"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomMutation</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a3253879ee0318d8744a16949355ad113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f20ab0890fcbec5af0497c71407bb32"><td class="memItemLeft" align="right" valign="top"><a id="a2f20ab0890fcbec5af0497c71407bb32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>naturalSelection</b> (csl::vector_expr &amp;individuals)</td></tr>
<tr class="separator:a2f20ab0890fcbec5af0497c71407bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada67d3f7198eeae4549c3fd938721343"><td class="memItemLeft" align="right" valign="top"><a id="ada67d3f7198eeae4549c3fd938721343"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>evolve</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;baseIndividual)</td></tr>
<tr class="separator:ada67d3f7198eeae4549c3fd938721343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30af37876f8c6102a9a0ffcb83c78f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a30af37876f8c6102a9a0ffcb83c78f13">sort</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;argument)</td></tr>
<tr class="memdesc:a30af37876f8c6102a9a0ffcb83c78f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a container using <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>.  <a href="#a30af37876f8c6102a9a0ffcb83c78f13">More...</a><br /></td></tr>
<tr class="separator:a30af37876f8c6102a9a0ffcb83c78f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038131f4648d3a85d7f66956b9a052f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a038131f4648d3a85d7f66956b9a052f9">sort</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator first, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator last)</td></tr>
<tr class="memdesc:a038131f4648d3a85d7f66956b9a052f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a container using <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>.  <a href="#a038131f4648d3a85d7f66956b9a052f9">More...</a><br /></td></tr>
<tr class="separator:a038131f4648d3a85d7f66956b9a052f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcde11ad745cfee42e9efa83d145031a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#adcde11ad745cfee42e9efa83d145031a">selectionSort</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;argument)</td></tr>
<tr class="memdesc:adcde11ad745cfee42e9efa83d145031a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the selection sort algorithm <img class="formulaInl" alt="$ \mathcal{O}(N^2) $" src="form_39.png"/> on a container.  <a href="#adcde11ad745cfee42e9efa83d145031a">More...</a><br /></td></tr>
<tr class="separator:adcde11ad745cfee42e9efa83d145031a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa60374eb375314f6f7c661a35c01e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aaa60374eb375314f6f7c661a35c01e67">selectionSort</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator first, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator last)</td></tr>
<tr class="memdesc:aaa60374eb375314f6f7c661a35c01e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the selection sort algorithm <img class="formulaInl" alt="$ \mathcal{O}(N^2) $" src="form_39.png"/> on a container.  <a href="#aaa60374eb375314f6f7c661a35c01e67">More...</a><br /></td></tr>
<tr class="separator:aaa60374eb375314f6f7c661a35c01e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c48c85e78f6b663a82bd7e100ad68d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0">mergeSort</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;argument)</td></tr>
<tr class="memdesc:a1c48c85e78f6b663a82bd7e100ad68d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the merge sort algorithm <img class="formulaInl" alt="$ \mathcal{O}(N\log N) $" src="form_40.png"/> on a container.  <a href="#a1c48c85e78f6b663a82bd7e100ad68d0">More...</a><br /></td></tr>
<tr class="separator:a1c48c85e78f6b663a82bd7e100ad68d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d5f0bc5267d581906fe5a40f3dcce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#af4d5f0bc5267d581906fe5a40f3dcce1">mergeSort</a> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator first, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator last)</td></tr>
<tr class="memdesc:af4d5f0bc5267d581906fe5a40f3dcce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the merge sort algorithm <img class="formulaInl" alt="$ \mathcal{O}(N\log N) $" src="form_40.png"/> on a container.  <a href="#af4d5f0bc5267d581906fe5a40f3dcce1">More...</a><br /></td></tr>
<tr class="separator:af4d5f0bc5267d581906fe5a40f3dcce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecef9b3f2cf93242af8662f9cd6dac5"><td class="memTemplParams" colspan="2"><a id="abecef9b3f2cf93242af8662f9cd6dac5"></a>
template&lt;typename T , typename G &gt; </td></tr>
<tr class="memitem:abecef9b3f2cf93242af8662f9cd6dac5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; T, G &gt; &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findFirstInPair</b> (std::vector&lt; std::pair&lt; T, G &gt;&gt; &amp;v, const T &amp;element)</td></tr>
<tr class="separator:abecef9b3f2cf93242af8662f9cd6dac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9756922888fcfb9016dc8c0068347fcb"><td class="memTemplParams" colspan="2"><a id="a9756922888fcfb9016dc8c0068347fcb"></a>
template&lt;typename T , typename G &gt; </td></tr>
<tr class="memitem:a9756922888fcfb9016dc8c0068347fcb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; T, G &gt; &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findSecondInPair</b> (std::vector&lt; std::pair&lt; T, G &gt;&gt; &amp;v, const G &amp;element)</td></tr>
<tr class="separator:a9756922888fcfb9016dc8c0068347fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c35fa756777b68cf4b801d6ec399da9"><td class="memItemLeft" align="right" valign="top"><a id="a9c35fa756777b68cf4b801d6ec399da9"></a>
const <a class="el" href="classcsl_1_1Space.html">Space</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>buildMinkowski</b> ()</td></tr>
<tr class="separator:a9c35fa756777b68cf4b801d6ec399da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6abd3ab4cdc44a414beaee90e01e5a6"><td class="memItemLeft" align="right" valign="top"><a id="ab6abd3ab4cdc44a414beaee90e01e5a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillEpsilonTensor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;tensor, int dim)</td></tr>
<tr class="separator:ab6abd3ab4cdc44a414beaee90e01e5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc609bb5307e2707f433fd90847da159"><td class="memItemLeft" align="right" valign="top"><a id="adc609bb5307e2707f433fd90847da159"></a>
const <a class="el" href="classcsl_1_1Space.html">Space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#adc609bb5307e2707f433fd90847da159">Euclid_R2</a> (&quot;R2&quot;, 2)</td></tr>
<tr class="memdesc:adc609bb5307e2707f433fd90847da159"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> <img class="formulaInl" alt="$ R^2 $" src="form_42.png"/>. <br /></td></tr>
<tr class="separator:adc609bb5307e2707f433fd90847da159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2032bf9b522dae416eb0c7f66642e89"><td class="memItemLeft" align="right" valign="top"><a id="ae2032bf9b522dae416eb0c7f66642e89"></a>
const <a class="el" href="classcsl_1_1Space.html">Space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae2032bf9b522dae416eb0c7f66642e89">Euclid_R3</a> (&quot;R3&quot;, 3)</td></tr>
<tr class="memdesc:ae2032bf9b522dae416eb0c7f66642e89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> <img class="formulaInl" alt="$ R^3 $" src="form_43.png"/>. <br /></td></tr>
<tr class="separator:ae2032bf9b522dae416eb0c7f66642e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1d8eb1cfa212c44e0ef199e78db957"><td class="memItemLeft" align="right" valign="top"><a id="a8d1d8eb1cfa212c44e0ef199e78db957"></a>
const <a class="el" href="classcsl_1_1Space.html">Space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a8d1d8eb1cfa212c44e0ef199e78db957">Euclid_R4</a> (&quot;R4&quot;, 4)</td></tr>
<tr class="memdesc:a8d1d8eb1cfa212c44e0ef199e78db957"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> <img class="formulaInl" alt="$ R^4 $" src="form_44.png"/>. <br /></td></tr>
<tr class="separator:a8d1d8eb1cfa212c44e0ef199e78db957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9bbef2158b7cb97a7d45e8739e01d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a8c9bbef2158b7cb97a7d45e8739e01d5">PGCD</a> (double a, double b)</td></tr>
<tr class="memdesc:a8c9bbef2158b7cb97a7d45e8739e01d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PGCD of a and b.  <a href="#a8c9bbef2158b7cb97a7d45e8739e01d5">More...</a><br /></td></tr>
<tr class="separator:a8c9bbef2158b7cb97a7d45e8739e01d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293f777248d9b27ff737fef8d51bb544"><td class="memItemLeft" align="right" valign="top">long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a293f777248d9b27ff737fef8d51bb544">PGCD</a> (long long int a, long long int b)</td></tr>
<tr class="memdesc:a293f777248d9b27ff737fef8d51bb544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PGCD of a and b.  <a href="#a293f777248d9b27ff737fef8d51bb544">More...</a><br /></td></tr>
<tr class="separator:a293f777248d9b27ff737fef8d51bb544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f23566569705a22bd8d9dcb8b46642a"><td class="memItemLeft" align="right" valign="top"><a id="a6f23566569705a22bd8d9dcb8b46642a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>PGCD</b> (int a, int b)</td></tr>
<tr class="separator:a6f23566569705a22bd8d9dcb8b46642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776ff8b234198c45db2d6233508ad558"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a776ff8b234198c45db2d6233508ad558">internal_PGCD</a> (long long int a, long long int b)</td></tr>
<tr class="memdesc:a776ff8b234198c45db2d6233508ad558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PGCD of a and b.  <a href="#a776ff8b234198c45db2d6233508ad558">More...</a><br /></td></tr>
<tr class="separator:a776ff8b234198c45db2d6233508ad558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ae14b0bc1a6b3f7e9138421b2b8360"><td class="memItemLeft" align="right" valign="top">long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a62ae14b0bc1a6b3f7e9138421b2b8360">sgn</a> (long long int a)</td></tr>
<tr class="memdesc:a62ae14b0bc1a6b3f7e9138421b2b8360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of a.  <a href="#a62ae14b0bc1a6b3f7e9138421b2b8360">More...</a><br /></td></tr>
<tr class="separator:a62ae14b0bc1a6b3f7e9138421b2b8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2da16ddbb46010b9d40d87308a834b"><td class="memItemLeft" align="right" valign="top"><a id="a2d2da16ddbb46010b9d40d87308a834b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sgn</b> (int a)</td></tr>
<tr class="separator:a2d2da16ddbb46010b9d40d87308a834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cdda72e72136f4b0afec1d865361c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a36cdda72e72136f4b0afec1d865361c5">sgn</a> (double a)</td></tr>
<tr class="memdesc:a36cdda72e72136f4b0afec1d865361c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of a.  <a href="#a36cdda72e72136f4b0afec1d865361c5">More...</a><br /></td></tr>
<tr class="separator:a36cdda72e72136f4b0afec1d865361c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd20a50cf5cdfbe57e3b896b980179e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a5bd20a50cf5cdfbe57e3b896b980179e">factorial</a> (int n)</td></tr>
<tr class="memdesc:a5bd20a50cf5cdfbe57e3b896b980179e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the factorial of a.  <a href="#a5bd20a50cf5cdfbe57e3b896b980179e">More...</a><br /></td></tr>
<tr class="separator:a5bd20a50cf5cdfbe57e3b896b980179e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fe2378efd87d7bc05ba13dbb35fa9e"><td class="memItemLeft" align="right" valign="top">long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a88fe2378efd87d7bc05ba13dbb35fa9e">internal_factorial</a> (long long int n)</td></tr>
<tr class="memdesc:a88fe2378efd87d7bc05ba13dbb35fa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the factorial of a.  <a href="#a88fe2378efd87d7bc05ba13dbb35fa9e">More...</a><br /></td></tr>
<tr class="separator:a88fe2378efd87d7bc05ba13dbb35fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7aff37dd08901e65dde87ba433b78f"><td class="memItemLeft" align="right" valign="top"><a id="ada7aff37dd08901e65dde87ba433b78f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compare</b> (std::string_view a, std::string_view b)</td></tr>
<tr class="separator:ada7aff37dd08901e65dde87ba433b78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77369a9f7c5fb4ded000b726bd8029d3"><td class="memItemLeft" align="right" valign="top"><a id="a77369a9f7c5fb4ded000b726bd8029d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="separator:a77369a9f7c5fb4ded000b726bd8029d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb6e8d6680cfdef7171a59ef2410452"><td class="memItemLeft" align="right" valign="top"><a id="afbb6e8d6680cfdef7171a59ef2410452"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="separator:afbb6e8d6680cfdef7171a59ef2410452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba402137e9956fe44de388ced3964bd"><td class="memItemLeft" align="right" valign="top"><a id="a6ba402137e9956fe44de388ced3964bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="separator:a6ba402137e9956fe44de388ced3964bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0b767ed145d9ceb68ef355e35c714a"><td class="memItemLeft" align="right" valign="top"><a id="a5d0b767ed145d9ceb68ef355e35c714a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="separator:a5d0b767ed145d9ceb68ef355e35c714a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32e3fbdeb6f7f01b9a4ccf729d8076"><td class="memItemLeft" align="right" valign="top"><a id="a0a32e3fbdeb6f7f01b9a4ccf729d8076"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_t n)</td></tr>
<tr class="separator:a0a32e3fbdeb6f7f01b9a4ccf729d8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633e799d5d19f9b7d5b5e720b7f95fc5"><td class="memItemLeft" align="right" valign="top"><a id="a633e799d5d19f9b7d5b5e720b7f95fc5"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_t i, size_t n)</td></tr>
<tr class="separator:a633e799d5d19f9b7d5b5e720b7f95fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91743f7f9372a3c89913006b498236f2"><td class="memItemLeft" align="right" valign="top"><a id="a91743f7f9372a3c89913006b498236f2"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_t i, size_t n, size_t step)</td></tr>
<tr class="separator:a91743f7f9372a3c89913006b498236f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f687274fba7d8f4dc865a21a1901ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31f687274fba7d8f4dc865a21a1901ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a31f687274fba7d8f4dc865a21a1901ac">comparePlaceIndependant</a> (std::vector&lt; T &gt; A, std::vector&lt; T &gt; B)</td></tr>
<tr class="memdesc:a31f687274fba7d8f4dc865a21a1901ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function that compares the elements in two vectors <b>A</b> and <b>B</b>, independently on their order.  <a href="#a31f687274fba7d8f4dc865a21a1901ac">More...</a><br /></td></tr>
<tr class="separator:a31f687274fba7d8f4dc865a21a1901ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90b89dc5d8450e4ce9538431f80925b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad90b89dc5d8450e4ce9538431f80925b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ad90b89dc5d8450e4ce9538431f80925b">partialComparePlaceIndependant</a> (std::vector&lt; T &gt; A, std::vector&lt; T &gt; B)</td></tr>
<tr class="memdesc:ad90b89dc5d8450e4ce9538431f80925b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function that compares the elements in two vectors <b>A</b> and <b>B</b>, independently on their order, <b>A</b> can be bigger, this function determines if all elements in <b>B</b> are present in <b>A</b>.  <a href="#ad90b89dc5d8450e4ce9538431f80925b">More...</a><br /></td></tr>
<tr class="separator:ad90b89dc5d8450e4ce9538431f80925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16a083cc7c50de69d67b66c20e030f2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ad16a083cc7c50de69d67b66c20e030f2">permutations</a> (std::vector&lt; int &gt; init)</td></tr>
<tr class="memdesc:ad16a083cc7c50de69d67b66c20e030f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all permutations (int the form of vectors of integers) of n elements, n beeing the size of <b>init</b>. The vector <b>init</b> must contain all integers between 0 and n-1.  <a href="#ad16a083cc7c50de69d67b66c20e030f2">More...</a><br /></td></tr>
<tr class="separator:ad16a083cc7c50de69d67b66c20e030f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19f782449354ccd37f8af92891e4647"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae19f782449354ccd37f8af92891e4647">permutations</a> (const <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &amp;init)</td></tr>
<tr class="memdesc:ae19f782449354ccd37f8af92891e4647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all permutations (int the form of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> objects) of n elements, n beeing the size of <b>init</b>.  <a href="#ae19f782449354ccd37f8af92891e4647">More...</a><br /></td></tr>
<tr class="separator:ae19f782449354ccd37f8af92891e4647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad292d5ba73b91dee12de72e4c96996b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ad292d5ba73b91dee12de72e4c96996b3">reducePermutation</a> (std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; &amp;permutation)</td></tr>
<tr class="memdesc:ad292d5ba73b91dee12de72e4c96996b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a vector of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> objects and erase the redundant ones, i.e. the permutations present several times in the vector.  <a href="#ad292d5ba73b91dee12de72e4c96996b3">More...</a><br /></td></tr>
<tr class="separator:ad292d5ba73b91dee12de72e4c96996b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe98d1ad16fa3c08f8a35317438fcb1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a6fe98d1ad16fa3c08f8a35317438fcb1">getSpan</a> (const std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; &amp;init)</td></tr>
<tr class="memdesc:a6fe98d1ad16fa3c08f8a35317438fcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all permutations spanned by an ensemble of initial Permutations <b>init</b>.  <a href="#a6fe98d1ad16fa3c08f8a35317438fcb1">More...</a><br /></td></tr>
<tr class="separator:a6fe98d1ad16fa3c08f8a35317438fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a9246a8bb37b33f7117f1e1eb571f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a67a9246a8bb37b33f7117f1e1eb571f9">getSpan</a> (std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; &amp;spanned, const <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &amp;element)</td></tr>
<tr class="memdesc:a67a9246a8bb37b33f7117f1e1eb571f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds an element in an already complete set of permutations. It assumes that the std::vector <b>spanned</b> is already complete by itself and modifies it by adding all the permutations spanned by itself and the new permutation <b>element</b>.  <a href="#a67a9246a8bb37b33f7117f1e1eb571f9">More...</a><br /></td></tr>
<tr class="separator:a67a9246a8bb37b33f7117f1e1eb571f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d88ed7abe1fa740fcb297989c23d0e"><td class="memTemplParams" colspan="2"><a id="a59d88ed7abe1fa740fcb297989c23d0e"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a59d88ed7abe1fa740fcb297989c23d0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classcsl_1_1TensorFieldParent.html">TensorFieldParent</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tensorfield_s</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a59d88ed7abe1fa740fcb297989c23d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9af8e82bb3d3edd943550639f22840"><td class="memTemplParams" colspan="2"><a id="a9e9af8e82bb3d3edd943550639f22840"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a9e9af8e82bb3d3edd943550639f22840"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classcsl_1_1TensorFieldParent.html">TensorFieldParent</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tensorfield_s</b> (std::string const &amp;name, <a class="el" href="classcsl_1_1Space.html">csl::Space</a> const *spaceField, std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; const &amp;indices, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a9e9af8e82bb3d3edd943550639f22840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0d9ee71eb3d3ed3783ba97181662ca"><td class="memTemplParams" colspan="2"><a id="a7b0d9ee71eb3d3ed3783ba97181662ca"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a7b0d9ee71eb3d3ed3783ba97181662ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tensorfieldelement_s</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a7b0d9ee71eb3d3ed3783ba97181662ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b0aadb45beae343b387da308a7ca4f"><td class="memItemLeft" align="right" valign="top"><a id="ad1b0aadb45beae343b387da308a7ca4f"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tderivativeelement_s</b> (const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;t_vector, const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;t_parent, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;t_index)</td></tr>
<tr class="separator:ad1b0aadb45beae343b387da308a7ca4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8317f47490f0af4700f1456c76e395c"><td class="memItemLeft" align="right" valign="top"><a id="ab8317f47490f0af4700f1456c76e395c"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tderivativeelement_s</b> (const <a class="el" href="classcsl_1_1Tensor.html">Tensor</a> &amp;t_vector, const <a class="el" href="classcsl_1_1Parent.html">Parent</a> &amp;t_parent, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;t_index, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;t_operand, bool t_empty)</td></tr>
<tr class="separator:ab8317f47490f0af4700f1456c76e395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e2b1182c06a2854674e98ced5c861"><td class="memTemplParams" colspan="2"><a id="a340e2b1182c06a2854674e98ced5c861"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a340e2b1182c06a2854674e98ced5c861"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classcsl_1_1TDerivativeParent.html">TDerivativeParent</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tderivative_s</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a340e2b1182c06a2854674e98ced5c861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943b563ec0e6a248ee95788d037060d5"><td class="memItemLeft" align="right" valign="top"><a id="a943b563ec0e6a248ee95788d037060d5"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InverseTaylorExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;big, size_t order)</td></tr>
<tr class="separator:a943b563ec0e6a248ee95788d037060d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d7a74167743977634628632789f105"><td class="memItemLeft" align="right" valign="top"><a id="a64d7a74167743977634628632789f105"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TaylorExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;eps, size_t order)</td></tr>
<tr class="separator:a64d7a74167743977634628632789f105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ef4e7e6f46c93d8ac1d19c503fe8bc"><td class="memItemLeft" align="right" valign="top"><a id="aa3ef4e7e6f46c93d8ac1d19c503fe8bc"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>internal_TaylorExpand</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;init, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;eps, size_t order)</td></tr>
<tr class="separator:aa3ef4e7e6f46c93d8ac1d19c503fe8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7420e1ff6f6a7d9f069bca1c6ac16f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ab7420e1ff6f6a7d9f069bca1c6ac16f5">Copy</a> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *expr)</td></tr>
<tr class="memdesc:ab7420e1ff6f6a7d9f069bca1c6ac16f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="namespacecsl.html#ab074eed4bd06ee44010c91e2d1dd05cb" title="Copy an Abstract to depth 1. ">Copy(const Expr&amp; expr)</a>.  <a href="#ab7420e1ff6f6a7d9f069bca1c6ac16f5">More...</a><br /></td></tr>
<tr class="separator:ab7420e1ff6f6a7d9f069bca1c6ac16f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b3a6d198d62535c5eaf5bc008bc69f"><td class="memItemLeft" align="right" valign="top"><a id="ac1b3a6d198d62535c5eaf5bc008bc69f"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CopySelf</b> (<a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *expr)</td></tr>
<tr class="separator:ac1b3a6d198d62535c5eaf5bc008bc69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab074eed4bd06ee44010c91e2d1dd05cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ab074eed4bd06ee44010c91e2d1dd05cb">Copy</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab074eed4bd06ee44010c91e2d1dd05cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Copy</b> an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to depth 1.  <a href="#ab074eed4bd06ee44010c91e2d1dd05cb">More...</a><br /></td></tr>
<tr class="separator:ab074eed4bd06ee44010c91e2d1dd05cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f0cf1575083e98534941e8aee6cfad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a40f0cf1575083e98534941e8aee6cfad">DeepCopy</a> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *expr)</td></tr>
<tr class="memdesc:a40f0cf1575083e98534941e8aee6cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="namespacecsl.html#af1e310aad90377d99f591def8b30336c" title="Copy an Abstract to the maximum depth. ">DeepCopy(const Expr&amp; expr)</a>.  <a href="#a40f0cf1575083e98534941e8aee6cfad">More...</a><br /></td></tr>
<tr class="separator:a40f0cf1575083e98534941e8aee6cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e310aad90377d99f591def8b30336c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#af1e310aad90377d99f591def8b30336c">DeepCopy</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:af1e310aad90377d99f591def8b30336c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Copy</b> an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to the <b>maximum</b> depth.  <a href="#af1e310aad90377d99f591def8b30336c">More...</a><br /></td></tr>
<tr class="separator:af1e310aad90377d99f591def8b30336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967916919ea8ffd29f798cbf06f1b2cd"><td class="memItemLeft" align="right" valign="top"><a id="a967916919ea8ffd29f798cbf06f1b2cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WeakDeepCopy</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a967916919ea8ffd29f798cbf06f1b2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5e3c2f5f4c6533ac74d150d29f931d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a9c5e3c2f5f4c6533ac74d150d29f931d">Refreshed</a> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *expr)</td></tr>
<tr class="memdesc:a9c5e3c2f5f4c6533ac74d150d29f931d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="namespacecsl.html#a90a30db275050c669fbe24152402c28e" title="Refreshed an Abstract and apply basic simplifications. ">Refreshed(const Expr&amp; expr)</a>.  <a href="#a9c5e3c2f5f4c6533ac74d150d29f931d">More...</a><br /></td></tr>
<tr class="separator:a9c5e3c2f5f4c6533ac74d150d29f931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a30db275050c669fbe24152402c28e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a90a30db275050c669fbe24152402c28e">Refreshed</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a90a30db275050c669fbe24152402c28e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Refreshed</b> an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and apply basic simplifications.  <a href="#a90a30db275050c669fbe24152402c28e">More...</a><br /></td></tr>
<tr class="separator:a90a30db275050c669fbe24152402c28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95bf5940e1dda061d2d9fbdd1a9fff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ae95bf5940e1dda061d2d9fbdd1a9fff8">DeepRefreshed</a> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ae95bf5940e1dda061d2d9fbdd1a9fff8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Refreshed</b> recursively an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and apply basic simplifications.  <a href="#ae95bf5940e1dda061d2d9fbdd1a9fff8">More...</a><br /></td></tr>
<tr class="separator:ae95bf5940e1dda061d2d9fbdd1a9fff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a930df32b60f9efb6a85fdad911cafc"><td class="memItemLeft" align="right" valign="top"><a id="a9a930df32b60f9efb6a85fdad911cafc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Refresh</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:a9a930df32b60f9efb6a85fdad911cafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dd32dc21f4e74403a931a696ccebc8"><td class="memItemLeft" align="right" valign="top"><a id="af9dd32dc21f4e74403a931a696ccebc8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeepRefresh</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:af9dd32dc21f4e74403a931a696ccebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8981c713ceaf99402a0b498ca11cd4ac"><td class="memItemLeft" align="right" valign="top"><a id="a8981c713ceaf99402a0b498ca11cd4ac"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vector_s</b> (int t_nElements)</td></tr>
<tr class="separator:a8981c713ceaf99402a0b498ca11cd4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10b12231ae2ec3d31e0e8f0439c68a4"><td class="memItemLeft" align="right" valign="top"><a id="ae10b12231ae2ec3d31e0e8f0439c68a4"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vector_s</b> (int t_nElements, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:ae10b12231ae2ec3d31e0e8f0439c68a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca7db78024cb9bb6324233565dbe71"><td class="memItemLeft" align="right" valign="top"><a id="aa8ca7db78024cb9bb6324233565dbe71"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vector_s</b> (int t_nElements, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;index)</td></tr>
<tr class="separator:aa8ca7db78024cb9bb6324233565dbe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee87590bd3efee965483b9d94c30e75"><td class="memItemLeft" align="right" valign="top"><a id="adee87590bd3efee965483b9d94c30e75"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vector_s</b> (const csl::vector_expr &amp;t_argument)</td></tr>
<tr class="separator:adee87590bd3efee965483b9d94c30e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1e580422f80dd19c9d838c98dc41e3"><td class="memItemLeft" align="right" valign="top"><a id="a5a1e580422f80dd19c9d838c98dc41e3"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vector_s</b> (const std::initializer_list&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;t_argument)</td></tr>
<tr class="separator:a5a1e580422f80dd19c9d838c98dc41e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1568f00f9e8ce25159f550cb8b34f2a"><td class="memItemLeft" align="right" valign="top"><a id="ad1568f00f9e8ce25159f550cb8b34f2a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_s</b> (int t_nArgs)</td></tr>
<tr class="separator:ad1568f00f9e8ce25159f550cb8b34f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9687b3d3c8d28554d2b78206c2cf6b"><td class="memItemLeft" align="right" valign="top"><a id="aea9687b3d3c8d28554d2b78206c2cf6b"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_s</b> (int t_x_nArgs, int t_y_nArgs)</td></tr>
<tr class="separator:aea9687b3d3c8d28554d2b78206c2cf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2db82502d8e742a2ec089982a9dc4f0"><td class="memItemLeft" align="right" valign="top"><a id="ae2db82502d8e742a2ec089982a9dc4f0"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_s</b> (int t_x_nArgs, int t_y_nArgs, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;index_x, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;index_y)</td></tr>
<tr class="separator:ae2db82502d8e742a2ec089982a9dc4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40b15582ed5c1b108ef5d6123c3d921"><td class="memItemLeft" align="right" valign="top"><a id="ab40b15582ed5c1b108ef5d6123c3d921"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_s</b> (int t_x_nArgs, int t_y_nArgs, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expr)</td></tr>
<tr class="separator:ab40b15582ed5c1b108ef5d6123c3d921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb43475d2e407f4dfc57db06a23f737"><td class="memItemLeft" align="right" valign="top"><a id="a6eb43475d2e407f4dfc57db06a23f737"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_s</b> (const csl::vector_expr &amp;t_argument)</td></tr>
<tr class="separator:a6eb43475d2e407f4dfc57db06a23f737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9c00b937944256df75e3d70805f079"><td class="memItemLeft" align="right" valign="top"><a id="acd9c00b937944256df75e3d70805f079"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_s</b> (const std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &gt; &amp;t_matrix)</td></tr>
<tr class="separator:acd9c00b937944256df75e3d70805f079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada127901f34826845607c80fc0503674"><td class="memItemLeft" align="right" valign="top"><a id="ada127901f34826845607c80fc0503674"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>diagonal_s</b> (const csl::vector_expr &amp;diag)</td></tr>
<tr class="separator:ada127901f34826845607c80fc0503674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e47d1c292116d12bb275fcafbe0d1a"><td class="memItemLeft" align="right" valign="top"><a id="ae4e47d1c292116d12bb275fcafbe0d1a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>identity_s</b> (int dim)</td></tr>
<tr class="separator:ae4e47d1c292116d12bb275fcafbe0d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5d02b73a3a5f3f0a331eb18b073e06"><td class="memItemLeft" align="right" valign="top"><a id="a1e5d02b73a3a5f3f0a331eb18b073e06"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>highdtensor_s</b> (const std::vector&lt; int &gt; &amp;shape)</td></tr>
<tr class="separator:a1e5d02b73a3a5f3f0a331eb18b073e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fa0837c6659c2b4971c120b3b0579e"><td class="memItemLeft" align="right" valign="top"><a id="a20fa0837c6659c2b4971c120b3b0579e"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>highdtensor_s</b> (const std::vector&lt; int &gt; &amp;shape, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;filler)</td></tr>
<tr class="separator:a20fa0837c6659c2b4971c120b3b0579e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f1e283c714e9b89494aaa003f77df8"><td class="memItemLeft" align="right" valign="top"><a id="a31f1e283c714e9b89494aaa003f77df8"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>highdtensor_s</b> (const std::initializer_list&lt; std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &gt; &gt; &amp;t_tensor)</td></tr>
<tr class="separator:a31f1e283c714e9b89494aaa003f77df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae292ffd8c883f3144ffbde88867d7df0"><td class="memItemLeft" align="right" valign="top"><a id="ae292ffd8c883f3144ffbde88867d7df0"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>highdtensor_from_args_s</b> (const std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:ae292ffd8c883f3144ffbde88867d7df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70d81c7dc91e29f2e181729dca8aa28"><td class="memItemLeft" align="right" valign="top"><a id="ae70d81c7dc91e29f2e181729dca8aa28"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vectorialtensor_s</b> (const std::vector&lt; int &gt; &amp;shape)</td></tr>
<tr class="separator:ae70d81c7dc91e29f2e181729dca8aa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd056968db6fcc45d41d89a83fdb9e2f"><td class="memItemLeft" align="right" valign="top"><a id="acd056968db6fcc45d41d89a83fdb9e2f"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vectorialtensor_s</b> (const std::vector&lt; int &gt; &amp;shape, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;filler)</td></tr>
<tr class="separator:acd056968db6fcc45d41d89a83fdb9e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac8166422b67dcd7c666146df992916"><td class="memItemLeft" align="right" valign="top"><a id="a5ac8166422b67dcd7c666146df992916"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compareString</b> (std::string_view a, std::string_view b)</td></tr>
<tr class="separator:a5ac8166422b67dcd7c666146df992916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e761dccf4e42089b38f718c55df549"><td class="memItemLeft" align="right" valign="top"><a id="aa9e761dccf4e42089b38f718c55df549"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dichoFinder</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> *&gt; const &amp;v)</td></tr>
<tr class="separator:aa9e761dccf4e42089b38f718c55df549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6134d2c9b324d2f47e5f7c563b5feea6"><td class="memItemLeft" align="right" valign="top"><a id="a6134d2c9b324d2f47e5f7c563b5feea6"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>termWithoutExponent</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:a6134d2c9b324d2f47e5f7c563b5feea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167623dea77c307c7f2c2d15f374c53b"><td class="memItemLeft" align="right" valign="top"><a id="a167623dea77c307c7f2c2d15f374c53b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, int b)</td></tr>
<tr class="separator:a167623dea77c307c7f2c2d15f374c53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919633543ba11b9ac77a3432c5c3d2a9"><td class="memItemLeft" align="right" valign="top"><a id="a919633543ba11b9ac77a3432c5c3d2a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, int b)</td></tr>
<tr class="separator:a919633543ba11b9ac77a3432c5c3d2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372075ddeceed8352f66900e22151e71"><td class="memItemLeft" align="right" valign="top"><a id="a372075ddeceed8352f66900e22151e71"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;a, double b)</td></tr>
<tr class="separator:a372075ddeceed8352f66900e22151e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6308a8941a535c68087d65491090bab5"><td class="memItemLeft" align="right" valign="top"><a id="a6308a8941a535c68087d65491090bab5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ForEachNode</b> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; init, std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f, int depth)</td></tr>
<tr class="separator:a6308a8941a535c68087d65491090bab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e1717ab07ae5bf9bbc6482c9c31717"><td class="memItemLeft" align="right" valign="top"><a id="ac5e1717ab07ae5bf9bbc6482c9c31717"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ForEachLeaf</b> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; init, std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;f, int depth)</td></tr>
<tr class="separator:ac5e1717ab07ae5bf9bbc6482c9c31717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c47d14a26425725528311106bbd295"><td class="memItemLeft" align="right" valign="top"><a id="aa9c47d14a26425725528311106bbd295"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><b>applyProperties</b> (const csl::vector_expr &amp;alternateForms)</td></tr>
<tr class="separator:aa9c47d14a26425725528311106bbd295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2525e1812b57bf23796363ebf55f3f7c"><td class="memItemLeft" align="right" valign="top"><a id="a2525e1812b57bf23796363ebf55f3f7c"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findCommonFactor</b> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> *&gt; const &amp;expressions)</td></tr>
<tr class="separator:a2525e1812b57bf23796363ebf55f3f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3541b72d49e0af883b03e5d64344739b"><td class="memItemLeft" align="right" valign="top"><a id="a3541b72d49e0af883b03e5d64344739b"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a> type)</td></tr>
<tr class="separator:a3541b72d49e0af883b03e5d64344739b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99e35d163a4fc4cee1c998d4c98ff1a"><td class="memItemLeft" align="right" valign="top"><a id="ad99e35d163a4fc4cee1c998d4c98ff1a"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, <a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a> primaryType)</td></tr>
<tr class="separator:ad99e35d163a4fc4cee1c998d4c98ff1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde4e2a389904c35c279aec94c06ebd7"><td class="memItemLeft" align="right" valign="top"><a id="afde4e2a389904c35c279aec94c06ebd7"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, const <a class="el" href="classcsl_1_1Equation.html">Equation</a> &amp;eq)</td></tr>
<tr class="separator:afde4e2a389904c35c279aec94c06ebd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b26155734c844f84cfbe63a4f5d1187"><td class="memItemLeft" align="right" valign="top"><a id="a9b26155734c844f84cfbe63a4f5d1187"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, cslEquation::Type type)</td></tr>
<tr class="separator:a9b26155734c844f84cfbe63a4f5d1187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516feebdb4dda9570ab61d47de89b6aa"><td class="memTemplParams" colspan="2"><a id="a516feebdb4dda9570ab61d47de89b6aa"></a>
template&lt;class ... T_Args&gt; </td></tr>
<tr class="memitem:a516feebdb4dda9570ab61d47de89b6aa"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, <a class="el" href="classcsl_1_1Functional.html">Functional</a>&lt; T_Args... &gt; func)</td></tr>
<tr class="separator:a516feebdb4dda9570ab61d47de89b6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbad184b8525501fb9aecfcd49e53686"><td class="memItemLeft" align="right" valign="top"><a id="afbad184b8525501fb9aecfcd49e53686"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>matchBOnA</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;B, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;tensorsInA, std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &gt; const &amp;tensorsInB)</td></tr>
<tr class="separator:afbad184b8525501fb9aecfcd49e53686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485a2bfffb2255543ab75208dacc95cc"><td class="memItemLeft" align="right" valign="top"><a id="a485a2bfffb2255543ab75208dacc95cc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>matchBOnA</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;A, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;B)</td></tr>
<tr class="separator:a485a2bfffb2255543ab75208dacc95cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151e69835322d06a4d91de11586b55ed"><td class="memItemLeft" align="right" valign="top"><a id="a151e69835322d06a4d91de11586b55ed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>isSuperFactor</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;fL, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;fR)</td></tr>
<tr class="separator:a151e69835322d06a4d91de11586b55ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af164e0d377dc6f578908ef16b9b005fb"><td class="memItemLeft" align="right" valign="top"><a id="af164e0d377dc6f578908ef16b9b005fb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nSimilar</b> (std::vector&lt; size_t &gt; const &amp;sortedA, std::vector&lt; size_t &gt; const &amp;sortedB)</td></tr>
<tr class="separator:af164e0d377dc6f578908ef16b9b005fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64184feefbeecd733d5149df83d700bc"><td class="memItemLeft" align="right" valign="top"><a id="a64184feefbeecd733d5149df83d700bc"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxSimilarity</b> (std::vector&lt; size_t &gt; const &amp;pos, <a class="el" href="classcsl_1_1linear__map.html">csl::linear_map</a>&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>, std::vector&lt; size_t &gt;&gt; const &amp;m)</td></tr>
<tr class="separator:a64184feefbeecd733d5149df83d700bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13affc44b14c7f12582935c87648668d"><td class="memItemLeft" align="right" valign="top"><a id="a13affc44b14c7f12582935c87648668d"></a>
FactorType const  *&#160;</td><td class="memItemRight" valign="bottom"><b>getBestFactor</b> (<a class="el" href="classcsl_1_1linear__map.html">csl::linear_map</a>&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>, std::vector&lt; size_t &gt;&gt; const &amp;m)</td></tr>
<tr class="separator:a13affc44b14c7f12582935c87648668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39871c03a988b657dc343381475512a6"><td class="memItemLeft" align="right" valign="top"><a id="a39871c03a988b657dc343381475512a6"></a>
std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hasRecursiveFactors</b> (FactorType const *best, <a class="el" href="classcsl_1_1linear__map.html">csl::linear_map</a>&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>, std::vector&lt; size_t &gt;&gt; const &amp;m)</td></tr>
<tr class="separator:a39871c03a988b657dc343381475512a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ce19325e0e51c27ab1545a3aef0499"><td class="memItemLeft" align="right" valign="top"><a id="ab7ce19325e0e51c27ab1545a3aef0499"></a>
<a class="el" href="classcsl_1_1linear__map.html">csl::linear_map</a>&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>, std::vector&lt; size_t &gt; &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>linear_find</b> (<a class="el" href="classcsl_1_1linear__map.html">csl::linear_map</a>&lt; <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>, std::vector&lt; size_t &gt;&gt; &amp;m, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr)</td></tr>
<tr class="separator:ab7ce19325e0e51c27ab1545a3aef0499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cbc1d0da0c812833c2b3b6e768f176"><td class="memItemLeft" align="right" valign="top"><a id="a64cbc1d0da0c812833c2b3b6e768f176"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;index)</td></tr>
<tr class="separator:a64cbc1d0da0c812833c2b3b6e768f176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ebe34e24cb298e42393118f6151e87"><td class="memItemLeft" align="right" valign="top"><a id="a60ebe34e24cb298e42393118f6151e87"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, const <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &amp;structure)</td></tr>
<tr class="separator:a60ebe34e24cb298e42393118f6151e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218927caa97681fb12412e7254063055"><td class="memItemLeft" align="right" valign="top"><a id="a218927caa97681fb12412e7254063055"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>nameTensor</b> (const string &amp;name, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;tensor, bool first)</td></tr>
<tr class="separator:a218927caa97681fb12412e7254063055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f0c6e54e962f99e680c64a3f96e2c8"><td class="memItemLeft" align="right" valign="top"><a id="a23f0c6e54e962f99e680c64a3f96e2c8"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>generateTensor</b> (const string &amp;name, const vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces)</td></tr>
<tr class="separator:a23f0c6e54e962f99e680c64a3f96e2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa281e09323b4af2997577939acf02431"><td class="memItemLeft" align="right" valign="top"><a id="aa281e09323b4af2997577939acf02431"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, const <a class="el" href="classcsl_1_1SelfContraction.html">SelfContraction</a> &amp;c)</td></tr>
<tr class="separator:aa281e09323b4af2997577939acf02431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253828d9198b95e2b1d52e8691311774"><td class="memItemLeft" align="right" valign="top"><a id="a253828d9198b95e2b1d52e8691311774"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInContraction</b> (std::vector&lt; std::array&lt; int, 4 &gt;&gt; const &amp;contractions, int iTensor, int iIndex)</td></tr>
<tr class="separator:a253828d9198b95e2b1d52e8691311774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411ab9fcb01cff165098156c3e770e10"><td class="memItemLeft" align="right" valign="top"><a id="a411ab9fcb01cff165098156c3e770e10"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, const <a class="el" href="classcsl_1_1ContractionChain.html">ContractionChain</a> &amp;c)</td></tr>
<tr class="separator:a411ab9fcb01cff165098156c3e770e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f06b9944252ae81ab8343be72e93d0"><td class="memTemplParams" colspan="2"><a id="ad3f06b9944252ae81ab8343be72e93d0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3f06b9944252ae81ab8343be72e93d0"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; pair&lt; T, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findContraction</b> (typename vector&lt; pair&lt; T, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&gt;::iterator it, typename vector&lt; pair&lt; T, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&gt;::iterator last, T element)</td></tr>
<tr class="separator:ad3f06b9944252ae81ab8343be72e93d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288bb7dd74147a1eecdbba4cff8a3838"><td class="memTemplParams" colspan="2"><a id="a288bb7dd74147a1eecdbba4cff8a3838"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a288bb7dd74147a1eecdbba4cff8a3838"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; pair&lt; T, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findContraction</b> (typename vector&lt; pair&lt; T, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&gt;::const_iterator it, typename vector&lt; pair&lt; T, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&gt;::const_iterator last, T element)</td></tr>
<tr class="separator:a288bb7dd74147a1eecdbba4cff8a3838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9563d5e20d8172b8bb4c91cf90b3ece"><td class="memItemLeft" align="right" valign="top"><a id="ac9563d5e20d8172b8bb4c91cf90b3ece"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillKeptIndices</b> (vector&lt; vector&lt; vector&lt; int &gt;&gt;&gt; &amp;keptIndices, vector&lt; size_t &gt;::const_iterator posBroken, vector&lt; size_t &gt;::const_iterator endPosBroken, vector&lt; vector&lt; int &gt;&gt; const &amp;toInsert)</td></tr>
<tr class="separator:ac9563d5e20d8172b8bb4c91cf90b3ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfba39e8ec26ed2a4e8906b5bb45f98"><td class="memItemLeft" align="right" valign="top"><a id="a9bfba39e8ec26ed2a4e8906b5bb45f98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillKeptIndices</b> (vector&lt; vector&lt; vector&lt; int &gt;&gt;&gt; &amp;keptIndices, vector&lt; size_t &gt;::const_iterator posBroken, vector&lt; size_t &gt;::const_iterator endPosBroken, vector&lt; size_t &gt; const &amp;pieces)</td></tr>
<tr class="separator:a9bfba39e8ec26ed2a4e8906b5bb45f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e4fb75fdb86c60f9984f7d220bbac4"><td class="memItemLeft" align="right" valign="top"><a id="ad2e4fb75fdb86c60f9984f7d220bbac4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillNewSpaces</b> (vector&lt; vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt;&gt; &amp;newSpace, vector&lt; size_t &gt;::const_iterator posBroken, vector&lt; size_t &gt;::const_iterator endPosBroken, vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; const &amp;fillingSpace)</td></tr>
<tr class="separator:ad2e4fb75fdb86c60f9984f7d220bbac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a98050b84ea0ea2178b8289e07a419"><td class="memItemLeft" align="right" valign="top"><a id="a51a98050b84ea0ea2178b8289e07a419"></a>
vector&lt; vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fillNewSpaces</b> (vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; const &amp;init, vector&lt; size_t &gt;::const_iterator posBroken, vector&lt; size_t &gt;::const_iterator endPosBroken, vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; const &amp;fillingSpace)</td></tr>
<tr class="separator:a51a98050b84ea0ea2178b8289e07a419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39356a8ab3da5a0b9e7efec05162af22"><td class="memItemLeft" align="right" valign="top"><a id="a39356a8ab3da5a0b9e7efec05162af22"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getBrokenName</b> (std::string const &amp;initName, std::vector&lt; std::vector&lt; int &gt;&gt; const &amp;indices)</td></tr>
<tr class="separator:a39356a8ab3da5a0b9e7efec05162af22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab115b83e97fbec6f2ac954e5ad21aa19"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ab115b83e97fbec6f2ac954e5ad21aa19">operator&lt;&lt;</a> (std::ostream &amp;fout, const <a class="el" href="classcsl_1_1TensorParent.html">TensorParent</a> &amp;i)</td></tr>
<tr class="separator:ab115b83e97fbec6f2ac954e5ad21aa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ac045f286ef7f712193aad46f01007"><td class="memItemLeft" align="right" valign="top"><a id="a92ac045f286ef7f712193aad46f01007"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillStructures</b> (vector&lt; <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &gt; &amp;toFill, const vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;indices, vector&lt; size_t &gt;::const_iterator pos, vector&lt; size_t &gt;::const_iterator end, size_t iter=0)</td></tr>
<tr class="separator:a92ac045f286ef7f712193aad46f01007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb818848ac78d1e7e0bda5b70169d34"><td class="memItemLeft" align="right" valign="top"><a id="a2bb818848ac78d1e7e0bda5b70169d34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearNullIndices</b> (vector&lt; <a class="el" href="classcsl_1_1IndexStructure.html">IndexStructure</a> &gt; &amp;toClear)</td></tr>
<tr class="separator:a2bb818848ac78d1e7e0bda5b70169d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101f11c8a5b3db0d28ed3ae31c3464b4"><td class="memItemLeft" align="right" valign="top"><a id="a101f11c8a5b3db0d28ed3ae31c3464b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>uniformizeIndices</b> (csl::vector_expr &amp;terms)</td></tr>
<tr class="separator:a101f11c8a5b3db0d28ed3ae31c3464b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070cd4d07f0a13d41eb400d0d0090ffb"><td class="memItemLeft" align="right" valign="top"><a id="a070cd4d07f0a13d41eb400d0d0090ffb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>keep_duplicates</b> (vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;vec)</td></tr>
<tr class="separator:a070cd4d07f0a13d41eb400d0d0090ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0f96dbefbb12ff881a040d2dc9498b"><td class="memItemLeft" align="right" valign="top"><a id="acf0f96dbefbb12ff881a040d2dc9498b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>contract</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;arg1, <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;arg2, <a class="el" href="classcsl_1_1Index.html">csl::Index</a> const &amp;index1, <a class="el" href="classcsl_1_1Index.html">csl::Index</a> const &amp;index2)</td></tr>
<tr class="separator:acf0f96dbefbb12ff881a040d2dc9498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884273636a36638326fb6f6c213c13c9"><td class="memItemLeft" align="right" valign="top"><a id="a884273636a36638326fb6f6c213c13c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillPosition</b> (vector&lt; vector&lt; size_t &gt;&gt; &amp;positions, size_t Nspaces)</td></tr>
<tr class="separator:a884273636a36638326fb6f6c213c13c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14d7c9e2b7029b82562aebb7a8691c3"><td class="memItemLeft" align="right" valign="top"><a id="ab14d7c9e2b7029b82562aebb7a8691c3"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBrokenExpr</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, const csl::vector_expr &amp;brokenExpr, const vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;brokenIndices, const vector&lt; <a class="el" href="classcsl_1_1Index.html">Index</a> &gt; &amp;replacement, const vector&lt; size_t &gt; &amp;positions, const size_t Nspaces)</td></tr>
<tr class="separator:ab14d7c9e2b7029b82562aebb7a8691c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8162eb402540342133f2bde749f549"><td class="memItemLeft" align="right" valign="top"><a id="a0b8162eb402540342133f2bde749f549"></a>
std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sumDummyIndices</b> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;init, std::vector&lt; std::vector&lt; size_t &gt;&gt; const &amp;posIndices, std::vector&lt; size_t &gt; const &amp;dummyIndices)</td></tr>
<tr class="separator:a0b8162eb402540342133f2bde749f549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bb44be3041543fccdc2202754cbaf4"><td class="memItemLeft" align="right" valign="top"><a id="a40bb44be3041543fccdc2202754cbaf4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sortIndices</b> (std::vector&lt; <a class="el" href="classcsl_1_1Index.html">csl::Index</a> &gt; &amp;indices, std::vector&lt; size_t &gt; &amp;positions)</td></tr>
<tr class="separator:a40bb44be3041543fccdc2202754cbaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf693bd7005436e871a7e16148c20eab"><td class="memItemLeft" align="right" valign="top"><a id="adf693bd7005436e871a7e16148c20eab"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTransposed</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces, bool applyProp)</td></tr>
<tr class="separator:adf693bd7005436e871a7e16148c20eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc2e89021aecebe2c0002f4bdd33a21"><td class="memItemLeft" align="right" valign="top"><a id="a3fc2e89021aecebe2c0002f4bdd33a21"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetHermitianConjugate</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;expression, const vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;spaces)</td></tr>
<tr class="separator:a3fc2e89021aecebe2c0002f4bdd33a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea40f7a4644fb64e77a04460ebd6288"><td class="memItemLeft" align="right" valign="top"><a id="adea40f7a4644fb64e77a04460ebd6288"></a>
<a class="el" href="classcsl_1_1IndexStructure.html">csl::IndexStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getFullStructure</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr)</td></tr>
<tr class="separator:adea40f7a4644fb64e77a04460ebd6288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea5cbedab4c45446b9ea67f165b94a2"><td class="memItemLeft" align="right" valign="top"><a id="a3ea5cbedab4c45446b9ea67f165b94a2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isTensorName</b> (std::string_view name)</td></tr>
<tr class="separator:a3ea5cbedab4c45446b9ea67f165b94a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bb6ecf2a1e9511b1ac194de8ef50ad"><td class="memItemLeft" align="right" valign="top"><a id="ab8bb6ecf2a1e9511b1ac194de8ef50ad"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, <a class="el" href="classcsl_1_1LibEval.html">LibEval</a> const &amp;eval)</td></tr>
<tr class="separator:ab8bb6ecf2a1e9511b1ac194de8ef50ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3775de045bee3b252742dfced2e20e65"><td class="memItemLeft" align="right" valign="top"><a id="a3775de045bee3b252742dfced2e20e65"></a>
<a class="el" href="classcsl_1_1LibEval.html">LibEval</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findEvalDicho</b> (int id, std::vector&lt; <a class="el" href="classcsl_1_1LibEval.html">LibEval</a> &gt;::const_iterator first, std::vector&lt; <a class="el" href="classcsl_1_1LibEval.html">LibEval</a> &gt;::const_iterator last)</td></tr>
<tr class="separator:a3775de045bee3b252742dfced2e20e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10276807a9348efd1d2d34e3e5da26"><td class="memItemLeft" align="right" valign="top"><a id="a0c10276807a9348efd1d2d34e3e5da26"></a>
<a class="el" href="classcsl_1_1LibEval.html">LibEval</a>&#160;</td><td class="memItemRight" valign="bottom"><b>exprToEval</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;expr, std::vector&lt; <a class="el" href="classcsl_1_1LibEval.html">LibEval</a> &gt; const &amp;eval)</td></tr>
<tr class="separator:a0c10276807a9348efd1d2d34e3e5da26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579164e2606cf7a43e29913d80e98a03"><td class="memItemLeft" align="right" valign="top"><a id="a579164e2606cf7a43e29913d80e98a03"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>independent</b> (<a class="el" href="classcsl_1_1LibEval.html">LibEval</a> const &amp;A, <a class="el" href="classcsl_1_1LibEval.html">LibEval</a> const &amp;B)</td></tr>
<tr class="separator:a579164e2606cf7a43e29913d80e98a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40c7ef62cc775c5f1fce6d8f8ced30b"><td class="memItemLeft" align="right" valign="top"><a id="aa40c7ef62cc775c5f1fce6d8f8ced30b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNLeafs</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr)</td></tr>
<tr class="separator:aa40c7ef62cc775c5f1fce6d8f8ced30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e497e40f183615587bc942d12489d12"><td class="memItemLeft" align="right" valign="top"><a id="a8e497e40f183615587bc942d12489d12"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, <a class="el" href="structcsl_1_1Structure.html">Structure</a> const &amp;s)</td></tr>
<tr class="separator:a8e497e40f183615587bc942d12489d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ec6f7271c0d746847725aa4f898f18"><td class="memItemLeft" align="right" valign="top"><a id="a16ec6f7271c0d746847725aa4f898f18"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constant_s</b> (string const &amp;name, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop)</td></tr>
<tr class="separator:a16ec6f7271c0d746847725aa4f898f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7168fcf3a66db5c2ee45e0064421cf77"><td class="memItemLeft" align="right" valign="top"><a id="a7168fcf3a66db5c2ee45e0064421cf77"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constant_s</b> (string const &amp;name, long double value, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop)</td></tr>
<tr class="separator:a7168fcf3a66db5c2ee45e0064421cf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ab2d9699116b9d1d35d6b0463aaf45"><td class="memItemLeft" align="right" valign="top"><a id="a08ab2d9699116b9d1d35d6b0463aaf45"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constant_s</b> (string const &amp;name, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;value, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop)</td></tr>
<tr class="separator:a08ab2d9699116b9d1d35d6b0463aaf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5f515c01394cecf90b7eb211a26375"><td class="memItemLeft" align="right" valign="top"><a id="a2e5f515c01394cecf90b7eb211a26375"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variable_s</b> (string const &amp;name, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop)</td></tr>
<tr class="separator:a2e5f515c01394cecf90b7eb211a26375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab85e44956df94d5f6718bd73eaf5964"><td class="memItemLeft" align="right" valign="top"><a id="aab85e44956df94d5f6718bd73eaf5964"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variable_s</b> (string const &amp;name, long double value, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop)</td></tr>
<tr class="separator:aab85e44956df94d5f6718bd73eaf5964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04826601497bdeef9dd0ab6abd78ac4"><td class="memItemLeft" align="right" valign="top"><a id="ab04826601497bdeef9dd0ab6abd78ac4"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variable_s</b> (string const &amp;name, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;value, <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a> prop)</td></tr>
<tr class="separator:ab04826601497bdeef9dd0ab6abd78ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f834f4204183e8e656de5ad6da2040"><td class="memItemLeft" align="right" valign="top"><a id="ae2f834f4204183e8e656de5ad6da2040"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>testSimplificationRule</b> (std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;arg)</td></tr>
<tr class="separator:ae2f834f4204183e8e656de5ad6da2040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a9c5e68399460d980c205f744a1a9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a951a9c5e68399460d980c205f744a1a9">operator&lt;&lt;</a> (std::ostream &amp;fout, const <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> &amp;parent)</td></tr>
<tr class="separator:a951a9c5e68399460d980c205f744a1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1141c4d9aa93198816311a91f03fd10f"><td class="memItemLeft" align="right" valign="top"><a id="a1141c4d9aa93198816311a91f03fd10f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>alreadyInChain</b> (size_t pos, std::vector&lt; <a class="el" href="structcsl_1_1ExpansionChain.html">ExpansionChain</a> &gt; const &amp;chains)</td></tr>
<tr class="separator:a1141c4d9aa93198816311a91f03fd10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d99f5a808203c0525237b9511a54b0d"><td class="memItemLeft" align="right" valign="top"><a id="a5d99f5a808203c0525237b9511a54b0d"></a>
<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><b>getEmitter</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;expr, ExpanderEmitter const &amp;isEmitter)</td></tr>
<tr class="separator:a5d99f5a808203c0525237b9511a54b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af17a920823f407f277d6ac9b86af82"><td class="memItemLeft" align="right" valign="top"><a id="a0af17a920823f407f277d6ac9b86af82"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>any_of</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const *emi, <a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;rec, ExpanderReceiver const &amp;isReceiver)</td></tr>
<tr class="separator:a0af17a920823f407f277d6ac9b86af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4409bd6346bf33b84350156b1db0d407"><td class="memItemLeft" align="right" valign="top"><a id="a4409bd6346bf33b84350156b1db0d407"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNTerms</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;prod, <a class="el" href="structcsl_1_1ExpansionChain.html">ExpansionChain</a> const &amp;toExpand, ExpanderReceiver const &amp;isReceiver)</td></tr>
<tr class="separator:a4409bd6346bf33b84350156b1db0d407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cb57f38089e99a76462277bfff9dae"><td class="memItemLeft" align="right" valign="top"><a id="a10cb57f38089e99a76462277bfff9dae"></a>
<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>applyExpansion</b> (<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;prod, <a class="el" href="structcsl_1_1ExpansionChain.html">ExpansionChain</a> const &amp;toExpand, ExpanderEmitter const &amp;isEmitter, ExpanderReceiver const &amp;isReceiver, bool applyRecursively)</td></tr>
<tr class="separator:a10cb57f38089e99a76462277bfff9dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51be1236a451fe3b7a9562fbe062437"><td class="memItemLeft" align="right" valign="top"><a id="ae51be1236a451fe3b7a9562fbe062437"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasCommonIndex</b> (std::vector&lt; size_t &gt; const &amp;sortedA, std::vector&lt; size_t &gt; const &amp;sortedB)</td></tr>
<tr class="separator:ae51be1236a451fe3b7a9562fbe062437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae755288ca88a0a696357183959d1132f"><td class="memItemLeft" align="right" valign="top"><a id="ae755288ca88a0a696357183959d1132f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mergeChains</b> (std::vector&lt; <a class="el" href="structcsl_1_1ExpansionChain.html">ExpansionChain</a> &gt; &amp;toExpand)</td></tr>
<tr class="separator:ae755288ca88a0a696357183959d1132f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159d36da5f74be1d91fb2fe20f4e9419"><td class="memItemLeft" align="right" valign="top"><a id="a159d36da5f74be1d91fb2fe20f4e9419"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillDigits</b> (const vector&lt; short &gt; &amp;digits, vector&lt; short &gt; &amp;receiver)</td></tr>
<tr class="separator:a159d36da5f74be1d91fb2fe20f4e9419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4aa6ca1c309870088d6d44b3c8af2d"><td class="memItemLeft" align="right" valign="top"><a id="a4a4aa6ca1c309870088d6d44b3c8af2d"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, const <a class="el" href="classcsl_1_1PropertyList.html">PropertyList</a> &amp;props)</td></tr>
<tr class="separator:a4a4aa6ca1c309870088d6d44b3c8af2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650c0bbbc95c736099f3a8113ba0e915"><td class="memItemLeft" align="right" valign="top"><a id="a650c0bbbc95c736099f3a8113ba0e915"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>suppressTerm</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init, <a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;term)</td></tr>
<tr class="separator:a650c0bbbc95c736099f3a8113ba0e915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b34c3d4a8097a6a6f7279ba9a6e6d3"><td class="memItemLeft" align="right" valign="top"><a id="a88b34c3d4a8097a6a6f7279ba9a6e6d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MakeScalarIntegral</b> (<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;init)</td></tr>
<tr class="separator:a88b34c3d4a8097a6a6f7279ba9a6e6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845ad72b9ce7fddf4d15dc6659418e81"><td class="memItemLeft" align="right" valign="top"><a id="a845ad72b9ce7fddf4d15dc6659418e81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convertScalarFuncType</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *expr, <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a> &amp;type)</td></tr>
<tr class="separator:a845ad72b9ce7fddf4d15dc6659418e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537de3243badcf319cf8c83b27890922"><td class="memItemLeft" align="right" valign="top"><a id="a537de3243badcf319cf8c83b27890922"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>valueRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a537de3243badcf319cf8c83b27890922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103202b75e3fdf16c3f4b7640091f00a"><td class="memItemLeft" align="right" valign="top"><a id="a103202b75e3fdf16c3f4b7640091f00a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>complexRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a103202b75e3fdf16c3f4b7640091f00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955431f8f58a8869edbd7689a24992fe"><td class="memItemLeft" align="right" valign="top"><a id="a955431f8f58a8869edbd7689a24992fe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>evalRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a955431f8f58a8869edbd7689a24992fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb30817e3d34173ae901c071c40f7cc5"><td class="memItemLeft" align="right" valign="top"><a id="afb30817e3d34173ae901c071c40f7cc5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>alphaRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:afb30817e3d34173ae901c071c40f7cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29d7c0bfbd2ff23a52478134913e4a0"><td class="memItemLeft" align="right" valign="top"><a id="ab29d7c0bfbd2ff23a52478134913e4a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mathRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:ab29d7c0bfbd2ff23a52478134913e4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb3cfd258f5c03e6dce5fc850ebf623"><td class="memItemLeft" align="right" valign="top"><a id="a2cb3cfd258f5c03e6dce5fc850ebf623"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sumRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *sum)</td></tr>
<tr class="separator:a2cb3cfd258f5c03e6dce5fc850ebf623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14793e965c9146ec7256ad3119b71cd7"><td class="memItemLeft" align="right" valign="top"><a id="a14793e965c9146ec7256ad3119b71cd7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prodRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *prod)</td></tr>
<tr class="separator:a14793e965c9146ec7256ad3119b71cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86629b5bad9861ab06ca37dae7e7cd2"><td class="memItemLeft" align="right" valign="top"><a id="aa86629b5bad9861ab06ca37dae7e7cd2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>powRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *pow)</td></tr>
<tr class="separator:aa86629b5bad9861ab06ca37dae7e7cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4cc44046b5181858ea2e92eb8cf446"><td class="memItemLeft" align="right" valign="top"><a id="a2d4cc44046b5181858ea2e92eb8cf446"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sumRule_inverted</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *sum)</td></tr>
<tr class="separator:a2d4cc44046b5181858ea2e92eb8cf446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe85a4826b1fb56529b277cd8b931d6"><td class="memItemLeft" align="right" valign="top"><a id="abfe85a4826b1fb56529b277cd8b931d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prodRule_inverted</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *prod)</td></tr>
<tr class="separator:abfe85a4826b1fb56529b277cd8b931d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18f3c226c51974e35e1c18a0e032efd"><td class="memItemLeft" align="right" valign="top"><a id="af18f3c226c51974e35e1c18a0e032efd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>powRule_inverted</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *pow)</td></tr>
<tr class="separator:af18f3c226c51974e35e1c18a0e032efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4d21c7f99966a80d224d6e7d072ef3"><td class="memItemLeft" align="right" valign="top"><a id="a3e4d21c7f99966a80d224d6e7d072ef3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>vectorialRule</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a3e4d21c7f99966a80d224d6e7d072ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b9f49ded09ad07397c62d9a0f596a9"><td class="memItemLeft" align="right" valign="top"><a id="a61b9f49ded09ad07397c62d9a0f596a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ruleO1</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a61b9f49ded09ad07397c62d9a0f596a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eff0894197faa1b49f66ea0517eb37"><td class="memItemLeft" align="right" valign="top"><a id="ab6eff0894197faa1b49f66ea0517eb37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compareDuoArgs</b> (const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;argA0, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;argA1, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;argB0, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;argB1)</td></tr>
<tr class="separator:ab6eff0894197faa1b49f66ea0517eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ec9cb647e506d83a37324aef7b02b9"><td class="memItemLeft" align="right" valign="top"><a id="ae3ec9cb647e506d83a37324aef7b02b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ruleO2</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:ae3ec9cb647e506d83a37324aef7b02b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ef7b818be86a845c20c3c425986a61"><td class="memItemLeft" align="right" valign="top"><a id="a07ef7b818be86a845c20c3c425986a61"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ruleO2_inverted</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a07ef7b818be86a845c20c3c425986a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2390b7f1d05f39b37dce21136b749690"><td class="memItemLeft" align="right" valign="top"><a id="a2390b7f1d05f39b37dce21136b749690"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ruleO3</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a2390b7f1d05f39b37dce21136b749690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed70767d6c87ca58b67bdad46826c711"><td class="memItemLeft" align="right" valign="top"><a id="aed70767d6c87ca58b67bdad46826c711"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ruleO4</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:aed70767d6c87ca58b67bdad46826c711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319cb7fc01ce74daf6b31504e11582cd"><td class="memItemLeft" align="right" valign="top"><a id="a319cb7fc01ce74daf6b31504e11582cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ruleO5</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a319cb7fc01ce74daf6b31504e11582cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adbeb8dd0fc23b6fb97fca690307385"><td class="memItemLeft" align="right" valign="top"><a id="a7adbeb8dd0fc23b6fb97fca690307385"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ruleO6</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a7adbeb8dd0fc23b6fb97fca690307385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0631181c111a6baa9f3d12333cf98f54"><td class="memItemLeft" align="right" valign="top"><a id="a0631181c111a6baa9f3d12333cf98f54"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ruleO7</b> (const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *A, const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *B)</td></tr>
<tr class="separator:a0631181c111a6baa9f3d12333cf98f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67aef8589845a645064fb527a7ef27b"><td class="memItemLeft" align="right" valign="top"><a id="ae67aef8589845a645064fb527a7ef27b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>selectionSort</b> (iterator first, iterator last)</td></tr>
<tr class="separator:ae67aef8589845a645064fb527a7ef27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab59f41cbf13cde6cb88928db331af6"><td class="memItemLeft" align="right" valign="top"><a id="abab59f41cbf13cde6cb88928db331af6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> (iterator first, iterator last)</td></tr>
<tr class="separator:abab59f41cbf13cde6cb88928db331af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a22c3d3c9ec01a082d2e01e5cdd75e"><td class="memItemLeft" align="right" valign="top"><a id="ab1a22c3d3c9ec01a082d2e01e5cdd75e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mergeSort</b> (iterator first, iterator last)</td></tr>
<tr class="separator:ab1a22c3d3c9ec01a082d2e01e5cdd75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30e74a9d2862583f2b165768309fc85"><td class="memItemLeft" align="right" valign="top"><a id="ab30e74a9d2862583f2b165768309fc85"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compare</b> (string_view a, string_view b)</td></tr>
<tr class="separator:ab30e74a9d2862583f2b165768309fc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecdcdbc474dfbd6b1e62bdc54b6c22a"><td class="memItemLeft" align="right" valign="top"><a id="a4ecdcdbc474dfbd6b1e62bdc54b6c22a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const string &amp;a, const string &amp;b)</td></tr>
<tr class="separator:a4ecdcdbc474dfbd6b1e62bdc54b6c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146702a236fc5f684b8f02e2870f64e3"><td class="memItemLeft" align="right" valign="top"><a id="a146702a236fc5f684b8f02e2870f64e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const string &amp;a, const string &amp;b)</td></tr>
<tr class="separator:a146702a236fc5f684b8f02e2870f64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d36e4ea4e90adc4dc7a9241ef6ff60"><td class="memItemLeft" align="right" valign="top"><a id="a84d36e4ea4e90adc4dc7a9241ef6ff60"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const string &amp;a, const string &amp;b)</td></tr>
<tr class="separator:a84d36e4ea4e90adc4dc7a9241ef6ff60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb13be470dde2d01c86b286f634408b4"><td class="memItemLeft" align="right" valign="top"><a id="afb13be470dde2d01c86b286f634408b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const string &amp;a, const string &amp;b)</td></tr>
<tr class="separator:afb13be470dde2d01c86b286f634408b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fabac6b19ca3a7a796ad43c42a66e32"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a7fabac6b19ca3a7a796ad43c42a66e32">operator&lt;&lt;</a> (std::ostream &amp;fout, const <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &amp;permutation)</td></tr>
<tr class="separator:a7fabac6b19ca3a7a796ad43c42a66e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e71f9c5536c70ec7433f566220774ca"><td class="memItemLeft" align="right" valign="top"><a id="a6e71f9c5536c70ec7433f566220774ca"></a>
vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>permutations</b> (vector&lt; int &gt; init)</td></tr>
<tr class="separator:a6e71f9c5536c70ec7433f566220774ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e37af5218572ce22681d13fec4e4eaa"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a1e37af5218572ce22681d13fec4e4eaa">operator&lt;&lt;</a> (std::ostream &amp;fout, const <a class="el" href="classcsl_1_1Symmetry.html">Symmetry</a> &amp;symmetry)</td></tr>
<tr class="separator:a1e37af5218572ce22681d13fec4e4eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145954f1ebfb826a945abe5823c5ac1f"><td class="memItemLeft" align="right" valign="top"><a id="a145954f1ebfb826a945abe5823c5ac1f"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;fout, const <a class="el" href="classcsl_1_1IndexedSymmetry.html">IndexedSymmetry</a> &amp;sym)</td></tr>
<tr class="separator:a145954f1ebfb826a945abe5823c5ac1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a65d45876773bef23c41e282961d72"><td class="memItemLeft" align="right" valign="top"><a id="ad1a65d45876773bef23c41e282961d72"></a>
vector&lt; list&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNonZeroElements_impl</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> vec)</td></tr>
<tr class="separator:ad1a65d45876773bef23c41e282961d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133394d62393a0ff2ef3ee06f65406c7"><td class="memItemLeft" align="right" valign="top"><a id="a133394d62393a0ff2ef3ee06f65406c7"></a>
vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNonZeroElements</b> (<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> vec)</td></tr>
<tr class="separator:a133394d62393a0ff2ef3ee06f65406c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e476ad740e7d1d261d2a380bbf10f8"><td class="memItemLeft" align="right" valign="top"><a id="a38e476ad740e7d1d261d2a380bbf10f8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sort_keep_sign</b> (typename std::vector&lt; int &gt;::iterator begin, typename std::vector&lt; int &gt;::iterator end)</td></tr>
<tr class="separator:a38e476ad740e7d1d261d2a380bbf10f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af537d5bf9aef49d6b819b8ad3e9463b5"><td class="memItemLeft" align="right" valign="top"><a id="af537d5bf9aef49d6b819b8ad3e9463b5"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_s</b> (const initializer_list&lt; initializer_list&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &gt; &amp;t_matrix)</td></tr>
<tr class="separator:af537d5bf9aef49d6b819b8ad3e9463b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af226f60d4468e187a080af93d1cae2f1"><td class="memItemLeft" align="right" valign="top"><a id="af226f60d4468e187a080af93d1cae2f1"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>highdtensor_s</b> (const vector&lt; int &gt; &amp;shape)</td></tr>
<tr class="separator:af226f60d4468e187a080af93d1cae2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e8c1e3c3fb7eeab12f8f9982e71fd4"><td class="memItemLeft" align="right" valign="top"><a id="a46e8c1e3c3fb7eeab12f8f9982e71fd4"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>highdtensor_s</b> (const vector&lt; int &gt; &amp;shape, const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;filler)</td></tr>
<tr class="separator:a46e8c1e3c3fb7eeab12f8f9982e71fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cdba2e21f0e536f59d3d6efa41107a"><td class="memItemLeft" align="right" valign="top"><a id="aa0cdba2e21f0e536f59d3d6efa41107a"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>highdtensor_from_args_s</b> (const csl::vector_expr &amp;t_argument)</td></tr>
<tr class="separator:aa0cdba2e21f0e536f59d3d6efa41107a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa227ac35150f5c67ff1b58a50091852c"><td class="memItemLeft" align="right" valign="top"><a id="aa227ac35150f5c67ff1b58a50091852c"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>highdtensor_s</b> (const initializer_list&lt; initializer_list&lt; initializer_list&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &gt; &gt; &amp;t_tensor)</td></tr>
<tr class="separator:aa227ac35150f5c67ff1b58a50091852c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4c715cb3d753657cea115272cd3f4d64"><td class="memItemLeft" align="right" valign="top"><a id="a4c715cb3d753657cea115272cd3f4d64"></a>
std::map&lt; std::string, std::vector&lt; <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>abbreviationData</b></td></tr>
<tr class="separator:a4c715cb3d753657cea115272cd3f4d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c85a9b160583b0827abdb1bdfc37aa"><td class="memItemLeft" align="right" valign="top"><a id="ae2c85a9b160583b0827abdb1bdfc37aa"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1TensorElement.html">TensorElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_itensor</b></td></tr>
<tr class="separator:ae2c85a9b160583b0827abdb1bdfc37aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927babc16317fc8f1f142ad3cf037a83"><td class="memItemLeft" align="right" valign="top"><a id="a927babc16317fc8f1f142ad3cf037a83"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1ISum.html">ISum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_isum</b></td></tr>
<tr class="separator:a927babc16317fc8f1f142ad3cf037a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5b80ac91ac0b40444b95b42392704e"><td class="memItemLeft" align="right" valign="top"><a id="a2c5b80ac91ac0b40444b95b42392704e"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1IProd.html">IProd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_iprod</b></td></tr>
<tr class="separator:a2c5b80ac91ac0b40444b95b42392704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8becef8429ef6949caee5d83e9c0fe"><td class="memItemLeft" align="right" valign="top"><a id="a0a8becef8429ef6949caee5d83e9c0fe"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1Constant.html">Constant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_constant</b></td></tr>
<tr class="separator:a0a8becef8429ef6949caee5d83e9c0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97f7287c060eeb8b6590d9bc91fba40"><td class="memItemLeft" align="right" valign="top"><a id="ae97f7287c060eeb8b6590d9bc91fba40"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1Variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_variable</b></td></tr>
<tr class="separator:ae97f7287c060eeb8b6590d9bc91fba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4d94ed5c06c7c985be6c377159f315"><td class="memItemLeft" align="right" valign="top"><a id="a7b4d94ed5c06c7c985be6c377159f315"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1Integer.html">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_integer</b></td></tr>
<tr class="separator:a7b4d94ed5c06c7c985be6c377159f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39c09a316ab6fd4a2b318d191a45e09"><td class="memItemLeft" align="right" valign="top"><a id="ac39c09a316ab6fd4a2b318d191a45e09"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1Float.html">Float</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_float</b></td></tr>
<tr class="separator:ac39c09a316ab6fd4a2b318d191a45e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc7e5dcba4ee20e35d80b76b651f8aa"><td class="memItemLeft" align="right" valign="top"><a id="addc7e5dcba4ee20e35d80b76b651f8aa"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1IntFraction.html">IntFraction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_intfraction</b></td></tr>
<tr class="separator:addc7e5dcba4ee20e35d80b76b651f8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140db7361d9738dc2e6877399eb6265f"><td class="memItemLeft" align="right" valign="top"><a id="a140db7361d9738dc2e6877399eb6265f"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1Complex.html">Complex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_complex</b></td></tr>
<tr class="separator:a140db7361d9738dc2e6877399eb6265f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a0e553cbdf619370d82a654e75b802"><td class="memItemLeft" align="right" valign="top"><a id="aa3a0e553cbdf619370d82a654e75b802"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1Sum.html">Sum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_sum</b></td></tr>
<tr class="separator:aa3a0e553cbdf619370d82a654e75b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ddd2dc372a534000938ec64e8ad494"><td class="memItemLeft" align="right" valign="top"><a id="a36ddd2dc372a534000938ec64e8ad494"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1Prod.html">Prod</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_prod</b></td></tr>
<tr class="separator:a36ddd2dc372a534000938ec64e8ad494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9da82d4a5b2f1ad748abd7c04cbdf63"><td class="memItemLeft" align="right" valign="top"><a id="af9da82d4a5b2f1ad748abd7c04cbdf63"></a>
csl::allocator&lt; <a class="el" href="classcsl_1_1Pow.html">Pow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_pow</b></td></tr>
<tr class="separator:af9da82d4a5b2f1ad748abd7c04cbdf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab456459b38f0d66d5f8f042102bd43a2"><td class="memItemLeft" align="right" valign="top"><a id="ab456459b38f0d66d5f8f042102bd43a2"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>maxMantisseSize</b> = 64</td></tr>
<tr class="separator:ab456459b38f0d66d5f8f042102bd43a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0149b334229f88c8c1fb1b6a48ada5"><td class="memItemLeft" align="right" valign="top"><a id="adc0149b334229f88c8c1fb1b6a48ada5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>PRECISION</b> = 100</td></tr>
<tr class="separator:adc0149b334229f88c8c1fb1b6a48ada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7892854becc51a6fa743a946c24464"><td class="memItemLeft" align="right" valign="top"><a id="a6c7892854becc51a6fa743a946c24464"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>WARN_OVERFLOW</b> = false</td></tr>
<tr class="separator:a6c7892854becc51a6fa743a946c24464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f015417e484717960b517cc3ce3602"><td class="memTemplParams" colspan="2"><a id="af2f015417e484717960b517cc3ce3602"></a>
template&lt;class T , class U , class Type , class Type2  = Type&gt; </td></tr>
<tr class="memitem:af2f015417e484717960b517cc3ce3602"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>canDecay_v</b> = <a class="el" href="structcsl_1_1canDecay.html">canDecay</a>&lt;T, U, <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">Type</a>, Type2&gt;::value</td></tr>
<tr class="separator:af2f015417e484717960b517cc3ce3602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47cb411c52614e2aca81edc2c6f97ef"><td class="memItemLeft" align="right" valign="top"><a id="ac47cb411c52614e2aca81edc2c6f97ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RANDOM_SEED</b> = false</td></tr>
<tr class="separator:ac47cb411c52614e2aca81edc2c6f97ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca17911173cc383d829dce28a06c00f4"><td class="memItemLeft" align="right" valign="top"><a id="aca17911173cc383d829dce28a06c00f4"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>NUMBER_OF_MUTATIONS</b> = 7</td></tr>
<tr class="separator:aca17911173cc383d829dce28a06c00f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737a418e19c3b62659f21070ca025b3a"><td class="memItemLeft" align="right" valign="top"><a id="a737a418e19c3b62659f21070ca025b3a"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>NATURAL_SELECTION</b> = 3</td></tr>
<tr class="separator:a737a418e19c3b62659f21070ca025b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4687acdfa532adaabedd31fe2d3cf2"><td class="memItemLeft" align="right" valign="top"><a id="abb4687acdfa532adaabedd31fe2d3cf2"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>NUMBER_OF_GENERATION</b> = 11</td></tr>
<tr class="separator:abb4687acdfa532adaabedd31fe2d3cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4491c5ff0e5ef74c12369ddecec5cf"><td class="memItemLeft" align="right" valign="top"><a id="ace4491c5ff0e5ef74c12369ddecec5cf"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>GENERATION_BEFORE_SELECTION</b> = 5</td></tr>
<tr class="separator:ace4491c5ff0e5ef74c12369ddecec5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbda9d9e75931fb6ec26bdfb14e6bb1"><td class="memItemLeft" align="right" valign="top"><a id="a7fbda9d9e75931fb6ec26bdfb14e6bb1"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a7fbda9d9e75931fb6ec26bdfb14e6bb1">SIMPLIFICATION_METHOD</a> = 1</td></tr>
<tr class="memdesc:a7fbda9d9e75931fb6ec26bdfb14e6bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which simplification method is applied. Ther used to be 2, now there is only one method. It may be useful in the future. <br /></td></tr>
<tr class="separator:a7fbda9d9e75931fb6ec26bdfb14e6bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c6baccc5af4c180975610469660a24"><td class="memItemLeft" align="right" valign="top"><a id="a66c6baccc5af4c180975610469660a24"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a66c6baccc5af4c180975610469660a24">MAX_ALTERNATE_FORMS</a> = 10</td></tr>
<tr class="memdesc:a66c6baccc5af4c180975610469660a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of alternate forms given by <a class="el" href="namespacecsl.html#a46d59a363192eb0486d9c16523f18fe4" title="Returns the alternate forms of expr by applying recursively internalRecursiveAlternateForms() MAX_REC...">getRecursiveAlternateForms()</a>. When getting alternate forms of an expression, we keep only the MAX_ALTERNATE_FORMS simpler. <br /></td></tr>
<tr class="separator:a66c6baccc5af4c180975610469660a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5e88ebf69cefa7cd3417b7a1360721"><td class="memItemLeft" align="right" valign="top"><a id="a5c5e88ebf69cefa7cd3417b7a1360721"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#a5c5e88ebf69cefa7cd3417b7a1360721">MAX_RECURSION_ALTERNATE</a> = 7</td></tr>
<tr class="memdesc:a5c5e88ebf69cefa7cd3417b7a1360721"><td class="mdescLeft">&#160;</td><td class="mdescRight">When getting alternateForms, we iterate MAX_RECURSION_ALTERNATE times (getting alternate forms of the alternate forms) in order to allow alternates that need several steps of Transformation. <br /></td></tr>
<tr class="separator:a5c5e88ebf69cefa7cd3417b7a1360721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3885c426f3cbbc274fe4ce33aae739b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#ab3885c426f3cbbc274fe4ce33aae739b">minMergeSize</a> = 10</td></tr>
<tr class="memdesc:ab3885c426f3cbbc274fe4ce33aae739b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size for a container to be sorted with <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>.  <a href="#ab3885c426f3cbbc274fe4ce33aae739b">More...</a><br /></td></tr>
<tr class="separator:ab3885c426f3cbbc274fe4ce33aae739b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be06bfad88957d4bfd2f8b9a966a418"><td class="memItemLeft" align="right" valign="top"><a id="a1be06bfad88957d4bfd2f8b9a966a418"></a>
<a class="el" href="classcsl_1_1Expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DMinko</b> = csl::constant_s(&quot;D&quot;, csl::int_s(4))</td></tr>
<tr class="separator:a1be06bfad88957d4bfd2f8b9a966a418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef525ce7226ae5fa0fc9b9f2aa4ccc5d"><td class="memItemLeft" align="right" valign="top"><a id="aef525ce7226ae5fa0fc9b9f2aa4ccc5d"></a>
const <a class="el" href="classcsl_1_1Space.html">Space</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecsl.html#aef525ce7226ae5fa0fc9b9f2aa4ccc5d">Minkowski</a> = buildMinkowski()</td></tr>
<tr class="memdesc:aef525ce7226ae5fa0fc9b9f2aa4ccc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> <img class="formulaInl" alt="$ R^{1,3} $" src="form_45.png"/> with a metric g = diag(-1,1,1,1). <br /></td></tr>
<tr class="separator:aef525ce7226ae5fa0fc9b9f2aa4ccc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a5177394069a44d1e6b4a1a05e9f73"><td class="memItemLeft" align="right" valign="top"><a id="ad6a5177394069a44d1e6b4a1a05e9f73"></a>
Vector_alloc&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_expr</b></td></tr>
<tr class="separator:ad6a5177394069a44d1e6b4a1a05e9f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for csl library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa804192228c299d8b648e4dc194cb689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa804192228c299d8b648e4dc194cb689">&#9670;&nbsp;</a></span>replacementRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecsl.html#aa804192228c299d8b648e4dc194cb689">csl::replacementRule</a> = typedef std::function&lt;std::optional&lt;<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a>&gt;(<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const&amp;, bool)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replacement rule prototype. </p>
<p>The function takes a constant expression as parameter and a boolean. If true, this boolean specifies that the rule is used only as a predicate for the moment i.e. that no calculation must be done in the return value (the optional will be used as a bool to know if a replacement must take place). If false, this function must return the result of the replacement in the std::optional&lt;csl::Expr&gt;. If no replacement is possible, return std::nullopt. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac54d9e79dc6697a8eacc07c754b11c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54d9e79dc6697a8eacc07c754b11c0e">&#9670;&nbsp;</a></span>ComplexProperty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecsl.html#ac54d9e79dc6697a8eacc07c754b11c0e">csl::ComplexProperty</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains all possible complex properties of objects. Real, purely imaginary, or complex. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac54d9e79dc6697a8eacc07c754b11c0ea10b4eb76294b70d7fd6df997ff06edb1"></a>Complex&#160;</td><td class="fielddoc"><p>complex object, <img class="formulaInl" alt="$ z^* \neq z. $" src="form_30.png"/> </p>
</td></tr>
<tr><td class="fieldname"><a id="ac54d9e79dc6697a8eacc07c754b11c0ea7f80fcc452c2f1ed2bb51b39d0864df1"></a>Real&#160;</td><td class="fielddoc"><p>real object, <img class="formulaInl" alt="$ z^* = z. $" src="form_31.png"/> </p>
</td></tr>
<tr><td class="fieldname"><a id="ac54d9e79dc6697a8eacc07c754b11c0eaf19f497d4c860d252cc1e055d0362ccc"></a>Imaginary&#160;</td><td class="fielddoc"><p>imaginary object, <img class="formulaInl" alt="$ z^* = -z. $" src="form_32.png"/> </p>
</td></tr>
</table>

</div>
</div>
<a id="a70046459ec0082db8cb97005c13c9a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70046459ec0082db8cb97005c13c9a54">&#9670;&nbsp;</a></span>PrimaryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores enumerations of types for <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> objects. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a70046459ec0082db8cb97005c13c9a54a5225763efc97aebd39e5a303fceb57ac"></a>Numerical&#160;</td><td class="fielddoc"><p>= 0. Concerns Number and <a class="el" href="classcsl_1_1IntFraction.html" title="Handles fractions of Number. ">IntFraction</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70046459ec0082db8cb97005c13c9a54ad7da1b76e5799f53a399b7a96ba67437"></a>Literal&#160;</td><td class="fielddoc"><p>= 1. Concerns <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a>, <a class="el" href="classcsl_1_1IntFactorial.html" title="Handles factorial of a Number. ">IntFactorial</a> and <a class="el" href="classcsl_1_1Imaginary.html" title="Numerical representation of i. ">Imaginary</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70046459ec0082db8cb97005c13c9a54a78216444cbb3388cc8c2f64cc44c7cd5"></a>MultiFunction&#160;</td><td class="fielddoc"><p>= 10. Concerns all scalar multi-variate functions (<a class="el" href="classcsl_1_1Sum.html" title="Handles a sum, function of multiple arguments. ">Sum</a>, <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a>, <a class="el" href="classcsl_1_1Pow.html" title="Handles the exponentiation of one Abstract wrt another. ">Pow</a>, etc). </p>
</td></tr>
<tr><td class="fieldname"><a id="a70046459ec0082db8cb97005c13c9a54a8870e734b769add08821a829f6951853"></a>ScalarFunction&#160;</td><td class="fielddoc"><p>= 20. Concerns all scalar uni-variate functions (<a class="el" href="classcsl_1_1Exp.html" title="Final specialization of AbstractFunc, the exponential function. ">Exp</a>, <a class="el" href="classcsl_1_1Log.html" title="Final specialization of AbstractFunc, the logarithm function. ">Log</a>, <a class="el" href="classcsl_1_1Cos.html" title="Final specialization of AbstractFunc, the cos function. ">Cos</a>, etc). </p>
</td></tr>
<tr><td class="fieldname"><a id="a70046459ec0082db8cb97005c13c9a54a97a447e7de95e9e2940291e17bcc4e3a"></a>Vectorial&#160;</td><td class="fielddoc"><p>= 50. Concerns <a class="el" href="classcsl_1_1Vector.html">Vector</a>, <a class="el" href="classcsl_1_1Matrix.html">Matrix</a> and <a class="el" href="classcsl_1_1HighDTensor.html">HighDTensor</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70046459ec0082db8cb97005c13c9a54a25e27f9899952c474587a6bee3ab9978"></a>Indicial&#160;</td><td class="fielddoc"><p>= 60. Concerns all indicial exprs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70046459ec0082db8cb97005c13c9a54a6f16a5f8ff5d75ab84c018adacdfcbb7"></a>Field&#160;</td><td class="fielddoc"><p>= 70. Concerns all Fields exprs. </p>
</td></tr>
</table>

</div>
</div>
<a id="ace591865c69b6315c533a1a325777312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace591865c69b6315c533a1a325777312">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum of the different types of <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> (i.e. list of all possible specializations). </p>
<p>Type of <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a>.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a9080fd7a5f0af44b585bb21b62d8b283"></a>NoType&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Arbitrary.html" title="Arbitrary object that can enter mathematical expressions. ">Arbitrary</a> <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> in comparisons </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312aa0faef0851b4294c06f2b94bb1cb2044"></a>Integer&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Integer.html" title="Handle numbers in expr. ">Integer</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a22ae0e2b89e5e3d477f988cc36d3272b"></a>Float&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Float.html" title="Handle numbers in expr. ">Float</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312aa9e4acf6d1d381d6875f480a5737b8b4"></a>IntFraction&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1IntFraction.html" title="Handles fractions of Number. ">IntFraction</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312aa79046cb7e9f609ba07c4ec22f14a862"></a>IntFactorial&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1IntFactorial.html" title="Handles factorial of a Number. ">IntFactorial</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a10b4eb76294b70d7fd6df997ff06edb1"></a>Complex&#160;</td><td class="fielddoc"><ol type="1">
<li><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Complex.html">Complex</a> </li>
</ol>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312ab87c58a6946efb3fd56cc53586d2fb78"></a>NumericalEval&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1NumericalEval.html">NumericalEval</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312af19f497d4c860d252cc1e055d0362ccc"></a>Imaginary&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Imaginary.html" title="Numerical representation of i. ">Imaginary</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Constant.html" title="Handle an object with a name and a value. ">Constant</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a47c14840d8e15331fa420b9b2f757cd9"></a>Variable&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312acad39a154bffb61175f674d6eefaf6d0"></a>Exp&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Exp.html" title="Final specialization of AbstractFunc, the exponential function. ">Exp</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312ace0be71e33226e4c1db2bcea5959f16b"></a>Log&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Log.html" title="Final specialization of AbstractFunc, the logarithm function. ">Log</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a29524358ad4c2579d7b08a21c990ce5e"></a>DiracDelta&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in Dirac Delta </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a1e34af023adeb7d5f484f8eb4b9826b6"></a>Abs&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Abs.html" title="Final specialization of AbstractFunc, the abs function. ">Abs</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312affca562be079b9e4e41ea9d6a86c582b"></a>Cos&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Cos.html" title="Final specialization of AbstractFunc, the cos function. ">Cos</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a0986d137604183312e6d3599578bc6cd"></a>Sin&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Sin.html" title="Final specialization of AbstractFunc, the sin function. ">Sin</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a1266b4e6f81e60733ec6c717e0181f60"></a>Tan&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Tan.html" title="Final specialization of AbstractFunc, the tan function. ">Tan</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a4371c3565b771b40c187487cc0190392"></a>Cosh&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Cosh.html" title="Final specialization of AbstractFunc, the cosh function. ">Cosh</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a98ed804abf4edd1f3be3fa894fa8cc3d"></a>Sinh&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Sinh.html" title="Final specialization of AbstractFunc, the sinh function. ">Sinh</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312acc132a41cab5676334f353a22a0aa5c5"></a>Tanh&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Tanh.html" title="Final specialization of AbstractFunc, the tanh function. ">Tanh</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a1c3ca8e525c0e6a47cc8489cb3155365"></a>ACos&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1ACos.html" title="Final specialization of AbstractFunc, the acos function. ">ACos</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a118d7e2878ba8789c8f86eee41c470b3"></a>ASin&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1ASin.html" title="Final specialization of AbstractFunc, the asin function. ">ASin</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312af9be9640e98f6072e8e0eaf2b418efe2"></a>ATan&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1ATan.html" title="Final specialization of AbstractFunc, the atan function. ">ATan</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a27cebb75cb5855484f7df7070b4cab73"></a>ACosh&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1ACosh.html" title="Final specialization of AbstractFunc, the acosh function. ">ACosh</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a6964cd88a53b2e4c358bcad0d9feac55"></a>ASinh&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1ASinh.html" title="Final specialization of AbstractFunc, the asinh function. ">ASinh</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a2286f4e717c6213c895da49a51aa5de7"></a>ATanh&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1ATanh.html" title="Final specialization of AbstractFunc, the atanh function. ">ATanh</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312af60357a8d17e45793298323f1b372a74"></a>Scalar&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Scalar.html">Scalar</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312ac74cc04b1519df2caf5026e94c3e8bab"></a>RealPart&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in real part. </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312ac49d71b3e882559a62d9d17009728907"></a>ImaginaryPart&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in imaginary part. </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a2ed2c32254f39662881b6eed72021250"></a>TensorElement&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1TensorElement.html" title="Specialization of Abstract for Indicial tensor. Building block carrying indices, and respecting Einst...">TensorElement</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a02e48a623b58c0b63bd2ad0e891c944e"></a>ScalarField&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1ScalarField.html">ScalarField</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a5a44d898396f28619971f227d438ef40"></a>TensorFieldElement&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1TensorFieldElement.html">TensorFieldElement</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312af575ff69fb3dc1eeb3341d4a419cada2"></a>StandardDuo&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in StandardDuo </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a607547b66dcd8e516cde5cc78739ae80"></a>StandardMult&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in StandardDuo </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a8be6d3e955290ee50c00a4bc92aa7749"></a>Pow&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Pow.html" title="Handles the exponentiation of one Abstract wrt another. ">Pow</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a362a33c23b08e4a32a4ec53fbb82cccd"></a>Prod&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312aa0ec87054b5e5b7847d0d8780a01a3d5"></a>Sum&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Sum.html" title="Handles a sum, function of multiple arguments. ">Sum</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a24ecfbe376a82f09ad48bffc6b8d6a87"></a>Polynomial&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Polynomial.html" title="Handles a polynomial, function of multiple arguments. ">Polynomial</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a70ae6e285cc14c8486e3cf5bec39d1fd"></a>Derivative&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Derivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312acc1e31375d9c49eb15a3302b96acc061"></a>Commutator&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Commutator.html" title="Object that represents a commutator or an anti-commutator, thus is derived from AbstractDuoFunc that ...">Commutator</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a45f4ce6c3306644b1efe333f4f8d6929"></a>Angle&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Angle.html" title="Handles a angle of 2 arguments. ">Angle</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a012b11265b94945f7a1390a07776e625"></a>Factorial&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Factorial.html" title="Final specialization of AbstractFunc, the factorial function. ">Factorial</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a4ea94552a2bec56a29592359a1b6069e"></a>Integral&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Integral.html">Integral</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312ad4d8fc83b4874f82d0b698683c6b9e22"></a>ScalarIntegral&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1ScalarIntegral.html">ScalarIntegral</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a7a5b7a2e7ef67739db0cf0cc4d3e5d60"></a>VectorIntegral&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1VectorIntegral.html">VectorIntegral</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a57dea6f5039281b7fee517fc43bf3110"></a>Vector&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Vector.html">Vector</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312af53df0293e169f562bc1d9a20e1d2589"></a>Matrix&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1Matrix.html">Matrix</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ace591865c69b6315c533a1a325777312a93ff2aa452bc6cbb7c3fe56cc7d196c5"></a>HighDTensor&#160;</td><td class="fielddoc"><p><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> specialized in <a class="el" href="classcsl_1_1HighDTensor.html">HighDTensor</a> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5327d368e944125c5ffa58b304051751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5327d368e944125c5ffa58b304051751">&#9670;&nbsp;</a></span>abs_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::abs_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Abs.html" title="Final specialization of AbstractFunc, the abs function. ">Abs</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an abs funtion. Then the return value is not an <a class="el" href="classcsl_1_1Abs.html" title="Final specialization of AbstractFunc, the abs function. ">Abs</a> object but something else, so we must implement a function that will create the good object. For example abs(1) returns 1 (a Number) and not abs(1) (an <a class="el" href="classcsl_1_1Abs.html" title="Final specialization of AbstractFunc, the abs function. ">Abs</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>abs</b> funtion function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Abs.html" title="Final specialization of AbstractFunc, the abs function. ">Abs</a> applied on expr </dd></dl>

</div>
</div>
<a id="a51f0625e0729c8516296eaa4e82a9928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f0625e0729c8516296eaa4e82a9928">&#9670;&nbsp;</a></span>acos_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::acos_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ACos.html" title="Final specialization of AbstractFunc, the acos function. ">ACos</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an acosonential. Then the return value is not an <a class="el" href="classcsl_1_1ACos.html" title="Final specialization of AbstractFunc, the acos function. ">ACos</a> object but something else, so we must implement a function that will create the good object. For example acos(0) returns pi/2 (a Number) and not acos(0) (a <a class="el" href="classcsl_1_1ACos.html" title="Final specialization of AbstractFunc, the acos function. ">ACos</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>acos</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1ACos.html" title="Final specialization of AbstractFunc, the acos function. ">ACos</a> applied on expr </dd></dl>

</div>
</div>
<a id="a832f3758b9ec7e3f52e554b949c8acf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832f3758b9ec7e3f52e554b949c8acf3">&#9670;&nbsp;</a></span>acosh_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::acosh_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ACosh.html" title="Final specialization of AbstractFunc, the acosh function. ">ACosh</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an acoshonential. Then the return value is not an <a class="el" href="classcsl_1_1ACosh.html" title="Final specialization of AbstractFunc, the acosh function. ">ACosh</a> object but something else, so we must implement a function that will create the good object. For example acosh(0) returns 1 (a Number) and not acosh(0) (a <a class="el" href="classcsl_1_1ACosh.html" title="Final specialization of AbstractFunc, the acosh function. ">ACosh</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>acosh</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1ACosh.html" title="Final specialization of AbstractFunc, the acosh function. ">ACosh</a> applied on expr </dd></dl>

</div>
</div>
<a id="ae89467d6317ff64a05858dca96a08479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89467d6317ff64a05858dca96a08479">&#9670;&nbsp;</a></span>addAlternateForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::addAlternateForm </td>
          <td>(</td>
          <td class="paramtype">csl::vector_expr &amp;&#160;</td>
          <td class="paramname"><em>alternateForms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>newAlternate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_factor_expand</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tried to add <b>newAlternate</b> in the set <b>alternateForms</b>. We simply test if the alternate is already present in the set <b>newAlternate</b> and add it if it is not the case. If <b>add_factor_expand</b> is set to <b>true</b>, we try to add the expanded and the factored forms of <b>newAlternate</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alternateForms</td><td>std::vector of expressions in which we add <b>newAlternate</b>. </td></tr>
    <tr><td class="paramname">newAlternate</td><td>Expression to add. </td></tr>
    <tr><td class="paramname">add_factor_expand</td><td>Boolean determining if we want to add also the factored and expanded versions of <b>newAlternate</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34e46d9db1bf2c52a11e16edb96aac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34e46d9db1bf2c52a11e16edb96aac9">&#9670;&nbsp;</a></span>AllOfLeafs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AllOfLeafs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if all of the leafs of an expression respect a certain condition given by the user. </p>
<p>If one of the leafs of <b>init</b> respects the condition <b>f</b> given by the user the function returns <b>true</b>. Else it returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches recursively. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> const&amp; as parameter and returning a boolean. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if all of the leafs of <b>init</b> respects the condition <b>f</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#ab34e46d9db1bf2c52a11e16edb96aac9" title="Tells if all of the leafs of an expression respect a certain condition given by the user...">AllOfLeafs()</a>, <a class="el" href="namespacecsl.html#aee4fb7f5bf59e525f167e3e5e1bea6ed" title="Tells if any of the nodes of an expression respect a certain condition given by the user...">AnyOfNodes()</a>, <a class="el" href="namespacecsl.html#a2a09c25d95caf5531f593f5e8a92cc99" title="Tells if all of the nodes of an expression respect a certain condition given by the user...">AllOfNodes()</a>. </dd></dl>

</div>
</div>
<a id="a2a09c25d95caf5531f593f5e8a92cc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a09c25d95caf5531f593f5e8a92cc99">&#9670;&nbsp;</a></span>AllOfNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AllOfNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if all of the nodes of an expression respect a certain condition given by the user. </p>
<p>If one of the nodes of <b>init</b> respects the condition <b>f</b> given by the user the function returns <b>true</b>. Else it returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches recursively. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> const&amp; as parameter and returning a boolean. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if all of the nodes of <b>init</b> respects the condition <b>f</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#ab34e46d9db1bf2c52a11e16edb96aac9" title="Tells if all of the leafs of an expression respect a certain condition given by the user...">AllOfLeafs()</a>, <a class="el" href="namespacecsl.html#aee4fb7f5bf59e525f167e3e5e1bea6ed" title="Tells if any of the nodes of an expression respect a certain condition given by the user...">AnyOfNodes()</a>, <a class="el" href="namespacecsl.html#a2a09c25d95caf5531f593f5e8a92cc99" title="Tells if all of the nodes of an expression respect a certain condition given by the user...">AllOfNodes()</a>. </dd></dl>

</div>
</div>
<a id="a0c725982c603dc7243b94238c7399f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c725982c603dc7243b94238c7399f17">&#9670;&nbsp;</a></span>AnyOfLeafs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AnyOfLeafs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if any of the leafs of an expression respect a certain condition given by the user. </p>
<p>If one of the leafs of <b>init</b> respects the condition <b>f</b> given by the user the function returns <b>true</b>. Else it returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches recursively. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> const&amp; as parameter and returning a boolean. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if any of the leafs of <b>init</b> respects the condition <b>f</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#ab34e46d9db1bf2c52a11e16edb96aac9" title="Tells if all of the leafs of an expression respect a certain condition given by the user...">AllOfLeafs()</a>, <a class="el" href="namespacecsl.html#aee4fb7f5bf59e525f167e3e5e1bea6ed" title="Tells if any of the nodes of an expression respect a certain condition given by the user...">AnyOfNodes()</a>, <a class="el" href="namespacecsl.html#a2a09c25d95caf5531f593f5e8a92cc99" title="Tells if all of the nodes of an expression respect a certain condition given by the user...">AllOfNodes()</a>. </dd></dl>

</div>
</div>
<a id="aee4fb7f5bf59e525f167e3e5e1bea6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4fb7f5bf59e525f167e3e5e1bea6ed">&#9670;&nbsp;</a></span>AnyOfNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::AnyOfNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if any of the nodes of an expression respect a certain condition given by the user. </p>
<p>If one of the nodes of <b>init</b> respects the condition <b>f</b> given by the user the function returns <b>true</b>. Else it returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches recursively. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> const&amp; as parameter and returning a boolean. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if any of the nodes of <b>init</b> respects the condition <b>f</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#ab34e46d9db1bf2c52a11e16edb96aac9" title="Tells if all of the leafs of an expression respect a certain condition given by the user...">AllOfLeafs()</a>, <a class="el" href="namespacecsl.html#a0c725982c603dc7243b94238c7399f17" title="Tells if any of the leafs of an expression respect a certain condition given by the user...">AnyOfLeafs()</a>, <a class="el" href="namespacecsl.html#a2a09c25d95caf5531f593f5e8a92cc99" title="Tells if all of the nodes of an expression respect a certain condition given by the user...">AllOfNodes()</a>. </dd></dl>

</div>
</div>
<a id="a36d313d19ed9c1b6e4cfbefbb7af7169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d313d19ed9c1b6e4cfbefbb7af7169">&#9670;&nbsp;</a></span>ApplyChainProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::ApplyChainProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a chain contraction property just the time of a refresh in order to apply it on one expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression on which we apply the property. </td></tr>
    <tr><td class="paramname">tensor</td><td>Indicial tensor that has the property. </td></tr>
    <tr><td class="paramname">prod</td><td>Tensors in the contraction. </td></tr>
    <tr><td class="paramname">res</td><td>Result of the contraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a36d313d19ed9c1b6e4cfbefbb7af7169" title="Declares a chain contraction property just the time of a refresh in order to apply it on one expressi...">ApplyChainProperty()</a>, AddSelfContraction() , <a class="el" href="classcsl_1_1TensorParent.html#a258388f5044e36fa76825710e67ebada" title="Adds a contraction property between an Element and another that share the parent (*this). ">TensorParent::addSelfContraction()</a>. </dd></dl>

</div>
</div>
<a id="acf713387a07a13348155f7043b55c933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf713387a07a13348155f7043b55c933">&#9670;&nbsp;</a></span>ApplySelfProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::ApplySelfProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Tensor.html">csl::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a self contraction property just the time of a refresh in order to apply it on one expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression on which we apply the property. </td></tr>
    <tr><td class="paramname">tensor</td><td>Indicial tensor that has the property. </td></tr>
    <tr><td class="paramname">A</td><td>First tensor in the contraction. </td></tr>
    <tr><td class="paramname">B</td><td>Second tensor in the contraction. </td></tr>
    <tr><td class="paramname">res</td><td>Result of the contraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a36d313d19ed9c1b6e4cfbefbb7af7169" title="Declares a chain contraction property just the time of a refresh in order to apply it on one expressi...">ApplyChainProperty()</a>, AddSelfContraction() , <a class="el" href="classcsl_1_1TensorParent.html#a258388f5044e36fa76825710e67ebada" title="Adds a contraction property between an Element and another that share the parent (*this). ">TensorParent::addSelfContraction()</a>. </dd></dl>

</div>
</div>
<a id="a178cb5ff11ecfb69f32bbdea3253712a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178cb5ff11ecfb69f32bbdea3253712a">&#9670;&nbsp;</a></span>applyThroughAbbreviations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::applyThroughAbbreviations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecsl.html#aa804192228c299d8b648e4dc194cb689">replacementRule</a> const &amp;&#160;</td>
          <td class="paramname"><em>rule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a replacement rule thoughout an expression, also entering abbreviations and replacing them if a replacement is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression in which the replacement takes place. </td></tr>
    <tr><td class="paramname">rule</td><td>Rule for the replacement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5fe6fa63f0b6cd80fd9edd625a715ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fe6fa63f0b6cd80fd9edd625a715ad">&#9670;&nbsp;</a></span>asin_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::asin_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ASin.html" title="Final specialization of AbstractFunc, the asin function. ">ASin</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an asin. Then the return value is not an <a class="el" href="classcsl_1_1ASin.html" title="Final specialization of AbstractFunc, the asin function. ">ASin</a> object but something else, so we must implement a function that will create the good object. For example asin(0) returns 0 (a Number) and not asin(0) (an <a class="el" href="classcsl_1_1ASin.html" title="Final specialization of AbstractFunc, the asin function. ">ASin</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>asin</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1ASin.html" title="Final specialization of AbstractFunc, the asin function. ">ASin</a> applied on expr </dd></dl>

</div>
</div>
<a id="a6f8d17a63615e912a201b11ce163b9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8d17a63615e912a201b11ce163b9dd">&#9670;&nbsp;</a></span>asinh_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::asinh_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ASinh.html" title="Final specialization of AbstractFunc, the asinh function. ">ASinh</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an asinh. Then the return value is not an <a class="el" href="classcsl_1_1ASinh.html" title="Final specialization of AbstractFunc, the asinh function. ">ASinh</a> object but something else, so we must implement a function that will create the good object. For example asinh(0) returns 0 (a Number) and not asinh(0) (an <a class="el" href="classcsl_1_1ASinh.html" title="Final specialization of AbstractFunc, the asinh function. ">ASinh</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>asinh</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1ASinh.html" title="Final specialization of AbstractFunc, the asinh function. ">ASinh</a> applied on expr </dd></dl>

</div>
</div>
<a id="a55a28054aa1541d982b05e4c90e22243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a28054aa1541d982b05e4c90e22243">&#9670;&nbsp;</a></span>atan_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::atan_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ATan.html" title="Final specialization of AbstractFunc, the atan function. ">ATan</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an atan. Then the return value is not an <a class="el" href="classcsl_1_1ATan.html" title="Final specialization of AbstractFunc, the atan function. ">ATan</a> object but something else, so we must implement a function that will create the good object. For example atan(0) returns 0 (a Number) and not atan(0) (a <a class="el" href="classcsl_1_1ATan.html" title="Final specialization of AbstractFunc, the atan function. ">ATan</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>atan</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1ATan.html" title="Final specialization of AbstractFunc, the atan function. ">ATan</a> applied on expr </dd></dl>

</div>
</div>
<a id="ac7d65507d0aa73726a4f0969ba1134be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d65507d0aa73726a4f0969ba1134be">&#9670;&nbsp;</a></span>atanh_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::atanh_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1ATanh.html" title="Final specialization of AbstractFunc, the atanh function. ">ATanh</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an atanh. Then the return value is not an <a class="el" href="classcsl_1_1ATanh.html" title="Final specialization of AbstractFunc, the atanh function. ">ATanh</a> object but something else, so we must implement a function that will create the good object. For example atanh(0) returns 0 (a Number) and not atanh(0) (a <a class="el" href="classcsl_1_1ATanh.html" title="Final specialization of AbstractFunc, the atanh function. ">ATanh</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>atanh</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1ATanh.html" title="Final specialization of AbstractFunc, the atanh function. ">ATanh</a> applied on expr </dd></dl>

</div>
</div>
<a id="a9c8abdf8d030cb99598167b606155f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8abdf8d030cb99598167b606155f71">&#9670;&nbsp;</a></span>callError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::callError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="error_8h.html#aa8b83bc17cf1d066a01fa3d6fb741db2">cslError::Error</a>&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays an error message depending on the error <b>error</b>, the name of the caller function <b>caller</b> and a possible specificity of the error <b>spec</b>. For example spec is the index for OutOfBound error. This function stops the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The type of error. </td></tr>
    <tr><td class="paramname">caller</td><td>The caller function. </td></tr>
    <tr><td class="paramname">spec</td><td>A printable specificity of the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d537409ca487db900cc76d286441569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d537409ca487db900cc76d286441569">&#9670;&nbsp;</a></span>callWarning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">csl::callWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="error_8h.html#a77055542ac61002c0db1fbd7e4413c84">cslError::Warning</a>&#160;</td>
          <td class="paramname"><em>warning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays a warning message depending on the warning <b>warning</b>, the name of the caller function <b>caller</b> and a possible specificity of the warning <b>spec</b>. For example spec is the dimension for InvalidDimension error. This function does not stop the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warning</td><td>The type of warning. </td></tr>
    <tr><td class="paramname">caller</td><td>The caller function. </td></tr>
    <tr><td class="paramname">spec</td><td>A printable specificity of the warning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1baa69edc83c2d90efd6f79bbdb0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1baa69edc83c2d90efd6f79bbdb0b4">&#9670;&nbsp;</a></span>CheckValidity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::CheckValidity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Abstract.html">Expr_info</a> &gt;&#160;</td>
          <td class="paramname"><em>encountered</em> = <code>std::vector&lt;<a class="el" href="classcsl_1_1Abstract.html">Expr_info</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the validity of an expression. </p>
<p>Browses the whole expression and checks that every node of the tree is valid (!= nullptr). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression to check. </td></tr>
    <tr><td class="paramname">encountered</td><td>List of expressions already checked. Should not be given by the user in general. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the expression is valid. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="ae84f9c884b931374b8cd46405ed164bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84f9c884b931374b8cd46405ed164bf">&#9670;&nbsp;</a></span>clearRedundancyAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::clearRedundancyAlternate </td>
          <td>(</td>
          <td class="paramtype">csl::vector_expr &amp;&#160;</td>
          <td class="paramname"><em>alternateForms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search and remove redundancies (equal alternate forms) in <b>alternateForms</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alternateForms</td><td>std::vector of expressions to reduce. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15620d82e51a1ba2c082a0b17ed773d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15620d82e51a1ba2c082a0b17ed773d0">&#9670;&nbsp;</a></span>Commutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Commutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of the (anit-)commutation of <b>A</b> and <b>B</b>. In most cases it returns CSL_0, and returns CSL_UNDEF else. Useful to test if two objects commute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Left hand side. </td></tr>
    <tr><td class="paramname">B</td><td>Right hand side. </td></tr>
    <tr><td class="paramname">sign</td><td>Sign of the commutator, -1 for commutation (default), 1 for anti-commutation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_0 if <b>A</b> and <b>B</b> commute. </dd>
<dd>
CSL_UNDEF else. </dd></dl>

</div>
</div>
<a id="afa314ac9077b2d18a81fa954327ab7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa314ac9077b2d18a81fa954327ab7e0">&#9670;&nbsp;</a></span>commutator_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::commutator_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_sign</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to create a <a class="el" href="classcsl_1_1Commutator.html" title="Object that represents a commutator or an anti-commutator, thus is derived from AbstractDuoFunc that ...">Commutator</a> object of <b>A</b> and <b>B</b> of sign <b>sign</b>. </p>
<p>If the result is CSL_0, this function returns CSL_0. If <b>A</b> and/or <b>B</b> are products, the functions expands the give at the end a more complicated expression but with just (anti-)commutators of single elements, expressions of type [{E,F}] with E and F neither sums nor products.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Left hand side of the <a class="el" href="classcsl_1_1Commutator.html" title="Object that represents a commutator or an anti-commutator, thus is derived from AbstractDuoFunc that ...">Commutator</a>. </td></tr>
    <tr><td class="paramname">B</td><td>Right hand side of the <a class="el" href="classcsl_1_1Commutator.html" title="Object that represents a commutator or an anti-commutator, thus is derived from AbstractDuoFunc that ...">Commutator</a>. </td></tr>
    <tr><td class="paramname">t_sign</td><td>Sign of the <a class="el" href="classcsl_1_1Commutator.html" title="Object that represents a commutator or an anti-commutator, thus is derived from AbstractDuoFunc that ...">Commutator</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[A,B] (or {A,B}) if the result is not defined (in particular not CSL_0). </dd>
<dd>
The result of [A,B] (or {A,B}) if there is special things to do. </dd></dl>

</div>
</div>
<a id="a31f687274fba7d8f4dc865a21a1901ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f687274fba7d8f4dc865a21a1901ac">&#9670;&nbsp;</a></span>comparePlaceIndependant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool csl::comparePlaceIndependant </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function that compares the elements in two vectors <b>A</b> and <b>B</b>, independently on their order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data, must have a well-defined operator==. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Left hand side. </td></tr>
    <tr><td class="paramname">B</td><td>Right hand side.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if all elements in <b>A</b> (no more no less) are present in , independently on their order. </dd></dl>

</div>
</div>
<a id="ab7420e1ff6f6a7d9f069bca1c6ac16f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7420e1ff6f6a7d9f069bca1c6ac16f5">&#9670;&nbsp;</a></span>Copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="namespacecsl.html#ab074eed4bd06ee44010c91e2d1dd05cb" title="Copy an Abstract to depth 1. ">Copy(const Expr&amp; expr)</a>. </p>
<dl class="section note"><dt>Note</dt><dd>With the apparition of shared_from_this(), this function should be removed soon. </dd></dl>

</div>
</div>
<a id="ab074eed4bd06ee44010c91e2d1dd05cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab074eed4bd06ee44010c91e2d1dd05cb">&#9670;&nbsp;</a></span>Copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Copy</b> an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to depth 1. </p>
<p><b>Copy</b> the depth 0 structure. For example the copy of cos(x+exp(y)) creates another cos function but take a reference to x+exp(y). Note that copy a <b><a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a></b> will create another with the same name. It could create misunderstanding in the following operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td><a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The copy. </dd></dl>

</div>
</div>
<a id="a3033bff78373155994cbf45ec3e71493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3033bff78373155994cbf45ec3e71493">&#9670;&nbsp;</a></span>cos_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::cos_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Cos.html" title="Final specialization of AbstractFunc, the cos function. ">Cos</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an cosonential. Then the return value is not an <a class="el" href="classcsl_1_1Cos.html" title="Final specialization of AbstractFunc, the cos function. ">Cos</a> object but something else, so we must implement a function that will create the good object. For example cos(0) returns 1 (a Number) and not cos(0) (a <a class="el" href="classcsl_1_1Cos.html" title="Final specialization of AbstractFunc, the cos function. ">Cos</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>cos</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Cos.html" title="Final specialization of AbstractFunc, the cos function. ">Cos</a> applied on expr </dd></dl>

</div>
</div>
<a id="a9f96bc23faf2e85278c67d2e77b02430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f96bc23faf2e85278c67d2e77b02430">&#9670;&nbsp;</a></span>cosh_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::cosh_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Cosh.html" title="Final specialization of AbstractFunc, the cosh function. ">Cosh</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an coshonential. Then the return value is not an <a class="el" href="classcsl_1_1Cosh.html" title="Final specialization of AbstractFunc, the cosh function. ">Cosh</a> object but something else, so we must implement a function that will create the good object. For example cosh(0) returns 1 (a Number) and not cosh(0) (a <a class="el" href="classcsl_1_1Cosh.html" title="Final specialization of AbstractFunc, the cosh function. ">Cosh</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>cosh</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Cosh.html" title="Final specialization of AbstractFunc, the cosh function. ">Cosh</a> applied on expr </dd></dl>

</div>
</div>
<a id="a40f0cf1575083e98534941e8aee6cfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f0cf1575083e98534941e8aee6cfad">&#9670;&nbsp;</a></span>DeepCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::DeepCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="namespacecsl.html#af1e310aad90377d99f591def8b30336c" title="Copy an Abstract to the maximum depth. ">DeepCopy(const Expr&amp; expr)</a>. </p>
<dl class="section note"><dt>Note</dt><dd>With the apparition of shared_from_this(), this function should be removed soon. </dd></dl>

</div>
</div>
<a id="af1e310aad90377d99f591def8b30336c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e310aad90377d99f591def8b30336c">&#9670;&nbsp;</a></span>DeepCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::DeepCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Copy</b> an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to the <b>maximum</b> depth. </p>
<p><b>Copy</b> <b>recursively</b> the entire <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The deepCopy. </dd></dl>

</div>
</div>
<a id="ae95bf5940e1dda061d2d9fbdd1a9fff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95bf5940e1dda061d2d9fbdd1a9fff8">&#9670;&nbsp;</a></span>DeepRefreshed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::DeepRefreshed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Refreshed</b> recursively an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and apply basic simplifications. </p>
<p>Apply all simplifications that take place normally at the creation of an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. For example, a sum with only one term gives just the term in question. The refresh is resursive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to refresh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The refreshed <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

</div>
</div>
<a id="a34118703c2961443732bb747369f30ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34118703c2961443732bb747369f30ac">&#9670;&nbsp;</a></span>derivative_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::derivative_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>leftOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rightOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <b>derivative</b> of <b>leftOperand</b> wrt <em>rightOperand</em>, applying basic simplifications. </p>
<p>This function possibly returns an object different from a <a class="el" href="classcsl_1_1Derivative.html" title="Handles the exponentiation of one Abstract wrt another. ">Derivative</a> object if the simplification requires so. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftOperand</td><td>Left operand. </td></tr>
    <tr><td class="paramname">rightOperand</td><td>Right operand. </td></tr>
    <tr><td class="paramname">order</td><td>Order of derivation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative of <b>leftOperand</b> wrt <b>rightOperand</b> at the order <b>order</b>. </dd></dl>

</div>
</div>
<a id="ae69cdb1c6ddfa666c766cd2edf66823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69cdb1c6ddfa666c766cd2edf66823e">&#9670;&nbsp;</a></span>dichotomyFindIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator csl::dichotomyFindIf </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Comparator.html">Comparator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template dichotomy algorithm using a comparator. </p>
<p>For the insertion of an element e, the comparator given must take one argument (of the same type as the range's elements) and return +1 if the element to insert is <b>simpler</b> than the argument, -1 if it is <b>less simple</b>, and 0 otherwise.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>Iterator type. </td></tr>
    <tr><td class="paramname"><a class="el" href="classcsl_1_1Comparator.html" title="Bunch of functions that allow to do comparisons with Arbitrary expressions or expressions with dummy ...">Comparator</a></td><td><a class="el" href="classcsl_1_1Comparator.html" title="Bunch of functions that allow to do comparisons with Arbitrary expressions or expressions with dummy ...">Comparator</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First iterator in the range. </td></tr>
    <tr><td class="paramname">last</td><td>Last iterator in the range. </td></tr>
    <tr><td class="paramname">f</td><td><a class="el" href="classcsl_1_1Comparator.html" title="Bunch of functions that allow to do comparisons with Arbitrary expressions or expressions with dummy ...">Comparator</a> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator where the element compared with $$f$$ must be inserted. </dd></dl>

</div>
</div>
<a id="a677874110c8d7d3febc7f30085273e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677874110c8d7d3febc7f30085273e6b">&#9670;&nbsp;</a></span>exp_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::exp_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Exp.html" title="Final specialization of AbstractFunc, the exponential function. ">Exp</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an exponential. Then the return value is not an <a class="el" href="classcsl_1_1Exp.html" title="Final specialization of AbstractFunc, the exponential function. ">Exp</a> object but something else, so we must implement a function that will create the good object. For example exp(0) returns 1 (a Number) and not exp(0) (an <a class="el" href="classcsl_1_1Exp.html" title="Final specialization of AbstractFunc, the exponential function. ">Exp</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>exponential</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Exp.html" title="Final specialization of AbstractFunc, the exponential function. ">Exp</a> applied on expr </dd></dl>

</div>
</div>
<a id="a5bd20a50cf5cdfbe57e3b896b980179e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd20a50cf5cdfbe57e3b896b980179e">&#9670;&nbsp;</a></span>factorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double csl::factorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the factorial of a. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>a!</b> </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>The factorial function returns a double for now and so is quickly out of bounds for exact numerical precision. The limit is between 20! and 25!. </dd></dl>

</div>
</div>
<a id="a27562270e1babd293920469862804ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27562270e1babd293920469862804ddf">&#9670;&nbsp;</a></span>FindIfLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::FindIfLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches and returns an expression in another. </p>
<p>If one of the leafs of <b>init</b> compares to <b>value</b> successfully using the condition <b>f</b> given by the user the function returns it. Else it returns nullptr. Beware that in this case the result is invalid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> as parameter and returning a boolean. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first leaf to respect the condition if found. </dd>
<dd>
nullptr else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a16030249dd9a145214dad11c6c698c75" title="Searches and returns an expression in another. ">FindNode()</a>, <a class="el" href="namespacecsl.html#ae25492ddb894bb646ca12868bbd5e54d" title="Searches and returns an expression in another. ">FindLeaf()</a>, <a class="el" href="namespacecsl.html#af08b277cdb6f9d098af7640035563e5d" title="Searches and returns an expression in another. ">FindIfNode()</a>. </dd></dl>

</div>
</div>
<a id="af08b277cdb6f9d098af7640035563e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08b277cdb6f9d098af7640035563e5d">&#9670;&nbsp;</a></span>FindIfNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::FindIfNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches and returns an expression in another. </p>
<p>If one of the nodes of <b>init</b> compares to <b>value</b> successfully using the condition <b>f</b> given by the user the function returns it. Else it returns nullptr. Beware that in this case the result is invalid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> as parameter and returning a boolean. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first node to respect the condition if found. </dd>
<dd>
nullptr else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a16030249dd9a145214dad11c6c698c75" title="Searches and returns an expression in another. ">FindNode()</a>, <a class="el" href="namespacecsl.html#ae25492ddb894bb646ca12868bbd5e54d" title="Searches and returns an expression in another. ">FindLeaf()</a>, <a class="el" href="namespacecsl.html#a27562270e1babd293920469862804ddf" title="Searches and returns an expression in another. ">FindIfLeaf()</a>. </dd></dl>

</div>
</div>
<a id="ae25492ddb894bb646ca12868bbd5e54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25492ddb894bb646ca12868bbd5e54d">&#9670;&nbsp;</a></span>FindLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::FindLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches and returns an expression in another. </p>
<p>If one of the leafs of <b>init</b> compares to <b>value</b> successfully the function returns it. Else it returns nullptr. Beware that in this case the result is invalid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches. </td></tr>
    <tr><td class="paramname">value</td><td>Sub-expression to find. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first leaf to compare to <b>value</b> if found. </dd>
<dd>
nullptr else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a16030249dd9a145214dad11c6c698c75" title="Searches and returns an expression in another. ">FindNode()</a>, <a class="el" href="namespacecsl.html#a27562270e1babd293920469862804ddf" title="Searches and returns an expression in another. ">FindIfLeaf()</a>, <a class="el" href="namespacecsl.html#af08b277cdb6f9d098af7640035563e5d" title="Searches and returns an expression in another. ">FindIfNode()</a>. </dd></dl>

</div>
</div>
<a id="a16030249dd9a145214dad11c6c698c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16030249dd9a145214dad11c6c698c75">&#9670;&nbsp;</a></span>FindNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::FindNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches and returns an expression in another. </p>
<p>If one of the nodes of <b>init</b> compares to <b>value</b> successfully the function returns it. Else it returns nullptr. Beware that in this case the result is invalid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches. </td></tr>
    <tr><td class="paramname">value</td><td>Sub-expression to find. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first node to compare to <b>value</b> if found. </dd>
<dd>
nullptr else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#ae25492ddb894bb646ca12868bbd5e54d" title="Searches and returns an expression in another. ">FindLeaf()</a>, <a class="el" href="namespacecsl.html#af08b277cdb6f9d098af7640035563e5d" title="Searches and returns an expression in another. ">FindIfNode()</a>, <a class="el" href="namespacecsl.html#a27562270e1babd293920469862804ddf" title="Searches and returns an expression in another. ">FindIfLeaf()</a>. </dd></dl>

</div>
</div>
<a id="af9f72de45510b266cb259a69d11cbf14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f72de45510b266cb259a69d11cbf14">&#9670;&nbsp;</a></span>FirstOfLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::FirstOfLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if any of the leafs of an expression respect a certain condition given by the user. The condition function may apply on the go on the expression found. </p>
<p>If one of the leafs of <b>init</b> respects the condition <b>f</b> given by the user the function returns <b>true</b>. Else it returns false. Once one node has been found, the function stops completely. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches recursively. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp; as parameter and returning a boolean. May modify the content of the expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if any of the leafs of <b>init</b> respects the condition <b>f</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#af9f72de45510b266cb259a69d11cbf14" title="Tells if any of the leafs of an expression respect a certain condition given by the user...">FirstOfLeaf()</a>. </dd></dl>

</div>
</div>
<a id="abe86be4e2295c35823a965faf12bb0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe86be4e2295c35823a965faf12bb0c7">&#9670;&nbsp;</a></span>FirstOfNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::FirstOfNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if any of the nodes of an expression respect a certain condition given by the user. The condition function may apply on the go on the expression found. </p>
<p>If one of the nodes of <b>init</b> respects the condition <b>f</b> given by the user the function returns <b>true</b>. Else it returns false. Once one node has been found, the function stops completely. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression in which the function searches recursively. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp; as parameter and returning a boolean. May modify the content of the expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if any of the nodes of <b>init</b> respects the condition <b>f</b>. </dd>
<dd>
<b>False</b> else. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#af9f72de45510b266cb259a69d11cbf14" title="Tells if any of the leafs of an expression respect a certain condition given by the user...">FirstOfLeaf()</a>. </dd></dl>

</div>
</div>
<a id="af74bfbc9faa2de7d49f5d37403795b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74bfbc9faa2de7d49f5d37403795b73">&#9670;&nbsp;</a></span>ForEachLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::ForEachLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a user function on each leaf of an expression. The expression may be modified. </p>
<p>This algorithm browses the whole expression applying <b>f</b> to each leaf. If the user function <b>f</b> does not modify the leafs, consider using <a class="el" href="namespacecsl.html#a795b923fd042a73265a04f5fa551362b" title="Visits all leafs of an expression, applying a function on it without modifying it. ">VisitEachLeaf()</a> instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression to browse. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp; (may or may not modify it) as parameter. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a8bbe21d8979e1d4fa2e9242a34c397be" title="Applies a user function on each node of an expression. The expression may be modified. ">ForEachNode()</a>, <a class="el" href="namespacecsl.html#af1844d0ef7e9f50ccd490096c4f1ff21" title="Applies a user function on each node of an expression. The expression may be modified. ">ForEachNodeCut()</a>, <a class="el" href="namespacecsl.html#aba0af68b54eefa2d567faed146678ad7" title="Applies a user function on each node of an expression. The expression may be modified. If it is, the expression is refreshed. ">Transform()</a>. </dd></dl>

</div>
</div>
<a id="a8bbe21d8979e1d4fa2e9242a34c397be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbe21d8979e1d4fa2e9242a34c397be">&#9670;&nbsp;</a></span>ForEachNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::ForEachNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a user function on each node of an expression. The expression may be modified. </p>
<p>This algorithm browses the whole expression applying <b>f</b> to each node. If the user function <b>f</b> does not modify the nodes, consider using <a class="el" href="namespacecsl.html#ab32d8a121c108b533a4e746a10d737ba" title="Visits all nodes of an expression, applying a function on it without modifying it. ">VisitEachNode()</a> instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression to browse. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp; (may or may not modify it) as parameter. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#af74bfbc9faa2de7d49f5d37403795b73" title="Applies a user function on each leaf of an expression. The expression may be modified. ">ForEachLeaf()</a>, <a class="el" href="namespacecsl.html#af1844d0ef7e9f50ccd490096c4f1ff21" title="Applies a user function on each node of an expression. The expression may be modified. ">ForEachNodeCut()</a>, <a class="el" href="namespacecsl.html#aba0af68b54eefa2d567faed146678ad7" title="Applies a user function on each node of an expression. The expression may be modified. If it is, the expression is refreshed. ">Transform()</a>. </dd></dl>

</div>
</div>
<a id="af1844d0ef7e9f50ccd490096c4f1ff21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1844d0ef7e9f50ccd490096c4f1ff21">&#9670;&nbsp;</a></span>ForEachNodeCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::ForEachNodeCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a user function on each node of an expression. The expression may be modified. </p>
<p>This algorithm browses the whole expression applying <b>f</b> to each node. If the user function <b>f</b> does not modify the nodes, consider using <a class="el" href="namespacecsl.html#abfb7fdd6c18bd8a98bfa3674e4bebefb" title="Visits all nodes of an expression, applying a function on it without modifying it. When the user function returns true on one node, the underlying branch (if there is) is not explored. ">VisitEachNodeCut()</a> instead. The user function must return a boolean. If true, the algorithm stops on the node (other branches are still explored). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression to browse. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp; (may or may not modify it) as parameter. Must return a boolean that tells if the algorithm must stop to search in that branch, if that boolean is true. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#af74bfbc9faa2de7d49f5d37403795b73" title="Applies a user function on each leaf of an expression. The expression may be modified. ">ForEachLeaf()</a>, <a class="el" href="namespacecsl.html#a8bbe21d8979e1d4fa2e9242a34c397be" title="Applies a user function on each node of an expression. The expression may be modified. ">ForEachNode()</a>, <a class="el" href="namespacecsl.html#abfb7fdd6c18bd8a98bfa3674e4bebefb" title="Visits all nodes of an expression, applying a function on it without modifying it. When the user function returns true on one node, the underlying branch (if there is) is not explored. ">VisitEachNodeCut()</a>. </dd></dl>

</div>
</div>
<a id="adb8fb620d09d80258c0c3d0c2a72340a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8fb620d09d80258c0c3d0c2a72340a">&#9670;&nbsp;</a></span>fraction_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::fraction_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>leftOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rightOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <b>fraction</b> of the two operands, applying basic simplifications. </p>
<p>This function possibly returns an object different from a Fraction object if the simplification requires so. For example 1/(x^(-1)) -&gt; x that is a <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftOperand</td><td>Left operand. </td></tr>
    <tr><td class="paramname">rightOperand</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fraction of <b>leftOperand</b> and <b>rightOperand</b>. </dd></dl>

</div>
</div>
<a id="aea0f20d9be8ac9b5c26fdcbbcc74dfaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0f20d9be8ac9b5c26fdcbbcc74dfaf">&#9670;&nbsp;</a></span>generateTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::generateTensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classcsl_1_1Space.html">Space</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a tensor of name <b>name</b> that lives in a list of spaces, filled with variables given by <a class="el" href="namespacecsl.html#ab17fb7de179f8643818e2eb85c4adda8" title="Fills an tensor with variables of the same name with the numbers correponding to their place in the t...">nameTensor()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the tensor. </td></tr>
    <tr><td class="paramname">spaces</td><td>List of spaces in which the tensor lives (just to get the dimensions).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> that is the generated tensor. </dd></dl>

</div>
</div>
<a id="a46d59a363192eb0486d9c16523f18fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d59a363192eb0486d9c16523f18fe4">&#9670;&nbsp;</a></span>getRecursiveAlternateForms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::getRecursiveAlternateForms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the alternate forms of <b>expr</b> by applying recursively <a class="el" href="namespacecsl.html#a49e7a13843443f95754c860cb4e92173" title="Calculates and return all alternate forms of expr, by getting (once) alternate forms of the possible ...">internalRecursiveAlternateForms()</a> MAX_RECURSION_ALTERNATE times: take alternates, then alternates of the alternates etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression from which we search alternates. </td></tr>
    <tr><td class="paramname">depth</td><td>Recursion depth transmitted to <a class="el" href="namespacecsl.html#a49e7a13843443f95754c860cb4e92173" title="Calculates and return all alternate forms of expr, by getting (once) alternate forms of the possible ...">internalRecursiveAlternateForms()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::vector of expressions containing alternates of <b>expr</b>. </dd></dl>

</div>
</div>
<a id="a6fe98d1ad16fa3c08f8a35317438fcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe98d1ad16fa3c08f8a35317438fcb1">&#9670;&nbsp;</a></span>getSpan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; csl::getSpan </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates all permutations spanned by an ensemble of initial Permutations <b>init</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initial permutations in a std::vector of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All permutations spanned by the initial vector <b>Init</b> in the form of a another vector of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> objects. </dd></dl>

</div>
</div>
<a id="a67a9246a8bb37b33f7117f1e1eb571f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a9246a8bb37b33f7117f1e1eb571f9">&#9670;&nbsp;</a></span>getSpan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::getSpan </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>spanned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds an element in an already complete set of permutations. It assumes that the std::vector <b>spanned</b> is already complete by itself and modifies it by adding all the permutations spanned by itself and the new permutation <b>element</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spanned</td><td>Initial set of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> objects, must be already complete. It is modified during the call of the function. </td></tr>
    <tr><td class="paramname">element</td><td><a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65b6337073b66a62d69827fd9246f092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b6337073b66a62d69827fd9246f092">&#9670;&nbsp;</a></span>hasWeakDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::hasWeakDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">csl::Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a true value for a given predicate in an expression, considering also sub-expressions encapsulated by abbreviations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression in which the search is done. </td></tr>
    <tr><td class="paramname">predicate</td><td>Boolean predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if on sub-expression checks the predicate. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a88fe2378efd87d7bc05ba13dbb35fa9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fe2378efd87d7bc05ba13dbb35fa9e">&#9670;&nbsp;</a></span>internal_factorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long int csl::internal_factorial </td>
          <td>(</td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the factorial of a. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>a!</b> </dd></dl>

</div>
</div>
<a id="a776ff8b234198c45db2d6233508ad558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776ff8b234198c45db2d6233508ad558">&#9670;&nbsp;</a></span>internal_PGCD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csl::internal_PGCD </td>
          <td>(</td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the PGCD of a and b. </p>
<p>This function is called only by PGCD(int a, int b) that do the nexessary checks on a and b before the calculation. Then the algorithm implemented in <a class="el" href="namespacecsl.html#a776ff8b234198c45db2d6233508ad558" title="Returns the PGCD of a and b. ">internal_PGCD()</a> is Euclid's (recursive). The separation of the cjeck function <a class="el" href="namespacecsl.html#a8c9bbef2158b7cb97a7d45e8739e01d5" title="Returns the PGCD of a and b. ">PGCD()</a> and the calculation function <a class="el" href="namespacecsl.html#a776ff8b234198c45db2d6233508ad558" title="Returns the PGCD of a and b. ">internal_PGCD()</a> allows to check only once <em>a</em> and <em>b</em> since the algorithm is recursive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PGCD(a,b) </dd></dl>

</div>
</div>
<a id="a49e7a13843443f95754c860cb4e92173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e7a13843443f95754c860cb4e92173">&#9670;&nbsp;</a></span>internalRecursiveAlternateForms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">csl::vector_expr csl::internalRecursiveAlternateForms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and return all alternate forms of <b>expr</b>, by getting (once) alternate forms of the possible arguments of <b>expr</b>, and then the specific alternates of expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression from which we get alternate forms. </td></tr>
    <tr><td class="paramname">depth</td><td>Recursion depth (default = -1, we take the alternate forms of all the recursion tree). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of expressions containing the alternate forms of <b>expr</b>. </dd></dl>

</div>
</div>
<a id="a7fbc14af6671615ab035d1c56fdcc02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbc14af6671615ab035d1c56fdcc02a">&#9670;&nbsp;</a></span>intfactorial_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::intfactorial_s </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><b>Initializer</b> of the <a class="el" href="classcsl_1_1IntFactorial.html" title="Handles factorial of a Number. ">IntFactorial</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IntFactorial(value) if value &gt; 2 </dd>
<dd>
Number(value) else </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function can be used to return a Symbol. The Symbol constructor Symbol::Symbol(const Expr&amp;) is implemented and allows to put the return value of this function in a Symbol. </dd></dl>

</div>
</div>
<a id="a77a31d3871e8136ab04e15368528c846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a31d3871e8136ab04e15368528c846">&#9670;&nbsp;</a></span>log_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::log_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Log.html" title="Final specialization of AbstractFunc, the logarithm function. ">Log</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an logarithm. Then the return value is not an <a class="el" href="classcsl_1_1Log.html" title="Final specialization of AbstractFunc, the logarithm function. ">Log</a> object but something else, so we must implement a function that will create the good object. For example log(1) returns 0 (a Number) and not log(1) (a <a class="el" href="classcsl_1_1Log.html" title="Final specialization of AbstractFunc, the logarithm function. ">Log</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>logarithm</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Log.html" title="Final specialization of AbstractFunc, the logarithm function. ">Log</a> applied on expr </dd></dl>

</div>
</div>
<a id="a769c039db45134ce7cbdd918da92273b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769c039db45134ce7cbdd918da92273b">&#9670;&nbsp;</a></span>MemorySizeOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t csl::MemorySizeOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an estimate of the total memory that an expression takes. </p>
<p>This function is not exact. It should be extended. The problem is that it is not possible for class with pointers to determine automatically the size of all elements and pointed elements. It has to be hard coded. This function ignores all pointed elements that are not accessible by the <a class="el" href="classcsl_1_1Abstract.html#ac33a42309d629d47bfdbede4e152414e">Abstract::getArgument()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>Expression from which we measure the size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total (recursive) size in bytes of the expression tree, ignoring all non-Expr pointed elements. </dd></dl>

</div>
</div>
<a id="a1c48c85e78f6b663a82bd7e100ad68d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c48c85e78f6b663a82bd7e100ad68d0">&#9670;&nbsp;</a></span>mergeSort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::mergeSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the merge sort algorithm <img class="formulaInl" alt="$ \mathcal{O}(N\log N) $" src="form_40.png"/> on a container. </p>
<p>This function is recursive, calling a merge sort on parts of the container. Once the size of these parts are bellow <a class="el" href="namespacecsl.html#ab3885c426f3cbbc274fe4ce33aae739b" title="Minimum size for a container to be sorted with mergeSort(). ">minMergeSize</a>, <a class="el" href="namespacecsl.html#adcde11ad745cfee42e9efa83d145031a" title="Applies the selection sort algorithm  on a container. ">selectionSort()</a> is called instead. For <a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a> (the case for the <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> type) the optimal size is around 10. This means that with less than 10 elements, <a class="el" href="namespacecsl.html#adcde11ad745cfee42e9efa83d145031a" title="Applies the selection sort algorithm  on a container. ">selectionSort()</a> is still faster that <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>. Above, the <img class="formulaInl" alt="$ \mathcal{O}(N\log N) $" src="form_40.png"/> complexity of <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a> is of course better and better with large <img class="formulaInl" alt="$ N $" src="form_41.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argument</td><td>Container to sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4d5f0bc5267d581906fe5a40f3dcce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d5f0bc5267d581906fe5a40f3dcce1">&#9670;&nbsp;</a></span>mergeSort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::mergeSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the merge sort algorithm <img class="formulaInl" alt="$ \mathcal{O}(N\log N) $" src="form_40.png"/> on a container. </p>
<p>This function is recursive, calling a merge sort on parts of the container. Once the size of these parts are bellow <a class="el" href="namespacecsl.html#ab3885c426f3cbbc274fe4ce33aae739b" title="Minimum size for a container to be sorted with mergeSort(). ">minMergeSize</a>, <a class="el" href="namespacecsl.html#adcde11ad745cfee42e9efa83d145031a" title="Applies the selection sort algorithm  on a container. ">selectionSort()</a> is called instead. For <a class="el" href="classstd_1_1shared__ptr.html">std::shared_ptr</a> (the case for the <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> type) the optimal size is around 10. This means that with less than 10 elements, <a class="el" href="namespacecsl.html#adcde11ad745cfee42e9efa83d145031a" title="Applies the selection sort algorithm  on a container. ">selectionSort()</a> is still faster that <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>. Above, the <img class="formulaInl" alt="$ \mathcal{O}(N\log N) $" src="form_40.png"/> complexity of <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a> is of course better and better with large <img class="formulaInl" alt="$ N $" src="form_41.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element (.begin()). </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the last element (.end()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1186b8efe45b2ea34ffcf8e0de69238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1186b8efe45b2ea34ffcf8e0de69238">&#9670;&nbsp;</a></span>minus_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::minus_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>leftOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rightOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <b>sum</b> of the two operands (with a minus sign), applying basic simplifications. </p>
<p>This function possibly returns an object different from a <a class="el" href="classcsl_1_1Sum.html" title="Handles a sum, function of multiple arguments. ">Sum</a> object if the simplification requires so. For example 0+x -&gt; x that is a <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a>. The Minus object does not exists, this function applies leftOperand + (-1*rightOperand). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftOperand</td><td>Left operand. </td></tr>
    <tr><td class="paramname">rightOperand</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of <b>leftOperand</b> and <b>rightOperand</b>. </dd></dl>

</div>
</div>
<a id="ab17fb7de179f8643818e2eb85c4adda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17fb7de179f8643818e2eb85c4adda8">&#9670;&nbsp;</a></span>nameTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::nameTensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an tensor with variables of the same name with the numbers correponding to their place in the tensor. Allows for example to name elements of a vector <img class="formulaInl" alt="$ V $" src="form_33.png"/>: <img class="formulaInl" alt="$ \left( V_0,V_1,V_2,V_3\right)$" src="form_34.png"/>. </p>
<p>The parameter first is due to the recursive nature of the function. It allows to know if the call of <a class="el" href="namespacecsl.html#ab17fb7de179f8643818e2eb85c4adda8" title="Fills an tensor with variables of the same name with the numbers correponding to their place in the t...">nameTensor()</a> is the user's (first = true) or from another <a class="el" href="namespacecsl.html#ab17fb7de179f8643818e2eb85c4adda8" title="Fills an tensor with variables of the same name with the numbers correponding to their place in the t...">nameTensor()</a>'s call (first = false). This parameter should then not be given by the user, but let to its default value <b>true</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the elements. </td></tr>
    <tr><td class="paramname">tensor</td><td><a class="el" href="classcsl_1_1Tensor.html">Tensor</a> to fill (the <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> is modified in the function). </td></tr>
    <tr><td class="paramname">first</td><td>This parameter should not be given by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7239c266a7391f8a652b83e65d927f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7239c266a7391f8a652b83e65d927f4a">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Index.html">Index</a> csl::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator!, unary operator on <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> that change the free property of the <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td><a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A free <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> similar to <b>index</b> if it is dummy. </dd>
<dd>
A dummy <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> similar to <b>index</b> if it is free. </dd></dl>

</div>
</div>
<a id="a51da3cbce74c766bb1aff63488113698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51da3cbce74c766bb1aff63488113698">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut function that allows to use arithmetic operator * with <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> (== shared_ptr&lt;Abstract&gt;). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>const <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp;. </td></tr>
    <tr><td class="paramname">b</td><td>const <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expression result of a*b. </dd></dl>

</div>
</div>
<a id="ae8258f8706933e1c10c973c721cd6151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8258f8706933e1c10c973c721cd6151">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Index.html">Index</a> csl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator+, unary operator on <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> that returns a similar <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> with sign = 1 if the <a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> is signed, i.e. an <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index similar to <b>index</b> with a sign 1 i.e. a up <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a>. </dd></dl>

</div>
</div>
<a id="a4214d96bf84e933c268cf30c85ef5065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4214d96bf84e933c268cf30c85ef5065">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut function that allows to use arithmetic operator + with <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> (== shared_ptr&lt;Abstract&gt;). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>const <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp; . </td></tr>
    <tr><td class="paramname">b</td><td>const <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expression result of a+b. </dd></dl>

</div>
</div>
<a id="aa060a7f29c77b51682733901c7a24d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa060a7f29c77b51682733901c7a24d04">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Index.html">Index</a> csl::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Index.html">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator-, unary operator on <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> that returns a similar <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> with sign = 0 if the <a class="el" href="classcsl_1_1Space.html" title="Vector space that has a name, a dimension, a delta tensor and possibly a non-trivial metric...">Space</a> is signed, i.e. an <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a> to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index similar to <b>index</b> with a sign 0 i.e. a down <a class="el" href="classcsl_1_1Index.html" title="Index object that is used for indicial objects. ">Index</a>. </dd></dl>

</div>
</div>
<a id="a8c85cf9cc27a2f9ea69c28fed0243a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c85cf9cc27a2f9ea69c28fed0243a66">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut function that allows to use arithmetic operator - with <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> (== shared_ptr&lt;Abstract&gt;). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>const <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp;. </td></tr>
    <tr><td class="paramname">b</td><td>const <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expression result of a-b. </dd></dl>

</div>
</div>
<a id="a75e84d94b9caf4662aa30a5c6aa36a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e84d94b9caf4662aa30a5c6aa36a63">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut function that allows to use arithmetic operator / with <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> (== shared_ptr&lt;Abstract&gt;). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>const <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp;. </td></tr>
    <tr><td class="paramname">b</td><td>const <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expression result of a/b. </dd></dl>

</div>
</div>
<a id="ad68e55a1e260433cbafab69addbb53c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68e55a1e260433cbafab69addbb53c4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; csl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312">csl::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the name of a given <a class="el" href="namespacecsl.html#ace591865c69b6315c533a1a325777312" title="Enum of the different types of Abstract (i.e. list of all possible specializations). ">csl::Type</a> in order to be readable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fout</td><td>Out stream in which the type is send. </td></tr>
    <tr><td class="paramname">type</td><td>Type to display. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>fout</b> </dd></dl>

</div>
</div>
<a id="a073cd06df1b6c4e0efb497d67d87e275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073cd06df1b6c4e0efb497d67d87e275">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; csl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54">csl::PrimaryType</a>&#160;</td>
          <td class="paramname"><em>primaryType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the name of a given <a class="el" href="namespacecsl.html#a70046459ec0082db8cb97005c13c9a54" title="Stores enumerations of types for Abstract objects. ">csl::PrimaryType</a> in order to be readable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fout</td><td>Out stream in which the type is send. </td></tr>
    <tr><td class="paramname">type</td><td>PrimaryType to display. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>fout</b> </dd></dl>

</div>
</div>
<a id="a7fabac6b19ca3a7a796ad43c42a66e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fabac6b19ca3a7a796ad43c42a66e32">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; csl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fout</td><td>Output flux. </td></tr>
    <tr><td class="paramname">permutation</td><td><a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> to diplay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified flux <b>fout</b>. </dd></dl>

</div>
</div>
<a id="a1e37af5218572ce22681d13fec4e4eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e37af5218572ce22681d13fec4e4eaa">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; csl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Symmetry.html">Symmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>symmetry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fout</td><td>Output flux. </td></tr>
    <tr><td class="paramname">permutation</td><td><a class="el" href="classcsl_1_1Symmetry.html" title="Handles the full symmetry properties of an TensorElement, i.e. a vector of Permutation objects...">Symmetry</a> to diplay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified flux <b>fout</b>. </dd></dl>

</div>
</div>
<a id="a951a9c5e68399460d980c205f744a1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951a9c5e68399460d980c205f744a1a9">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; csl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1AbstractParent.html">AbstractParent</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; fout , const <a class="el" href="classcsl_1_1AbstractParent.html" title="Base class for all parents (indicial, fields etc). All parents derive from this class. ">AbstractParent</a>&amp; p) </p>

</div>
</div>
<a id="ab115b83e97fbec6f2ac954e5ad21aa19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab115b83e97fbec6f2ac954e5ad21aa19">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; csl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1TensorParent.html">TensorParent</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; fout, const <a class="el" href="classcsl_1_1TensorParent.html" title="Parent of an indicial object, allows to generate them (TensorElement). ">TensorParent</a>&amp; p) </p>

</div>
</div>
<a id="ad90b89dc5d8450e4ce9538431f80925b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90b89dc5d8450e4ce9538431f80925b">&#9670;&nbsp;</a></span>partialComparePlaceIndependant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool csl::partialComparePlaceIndependant </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function that compares the elements in two vectors <b>A</b> and <b>B</b>, independently on their order, <b>A</b> can be bigger, this function determines if all elements in <b>B</b> are present in <b>A</b>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data, must have a well-defined operator==. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Left hand side. </td></tr>
    <tr><td class="paramname">B</td><td>Right hand side.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if all elements in <b>B</b> (and possibly more) are present in <b>A</b> independently on their order. </dd></dl>

</div>
</div>
<a id="ad16a083cc7c50de69d67b66c20e030f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16a083cc7c50de69d67b66c20e030f2">&#9670;&nbsp;</a></span>permutations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; csl::permutations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all permutations (int the form of vectors of integers) of n elements, n beeing the size of <b>init</b>. The vector <b>init</b> must contain all integers between 0 and n-1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initial set of n integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All the permutations of n elements in simple vectors of integers. </dd></dl>

</div>
</div>
<a id="ae19f782449354ccd37f8af92891e4647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19f782449354ccd37f8af92891e4647">&#9670;&nbsp;</a></span>permutations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; csl::permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all permutations (int the form of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> objects) of n elements, n beeing the size of <b>init</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initial <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> of n elements, can be identity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All the permutations of n elements in <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> objects. </dd></dl>

</div>
</div>
<a id="a8c9bbef2158b7cb97a7d45e8739e01d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9bbef2158b7cb97a7d45e8739e01d5">&#9670;&nbsp;</a></span>PGCD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csl::PGCD </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the PGCD of a and b. </p>
<p>If <em>a</em> and <em>b</em> are integers ( <em>a</em> == floor(<em>a</em>) and also for <em>b</em>) this function calls PGCD(int a, int b). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PGCD(a,b) if <em>a</em> and <em>b</em> are integers. </dd>
<dd>
<b>1</b> else. </dd></dl>

</div>
</div>
<a id="a293f777248d9b27ff737fef8d51bb544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293f777248d9b27ff737fef8d51bb544">&#9670;&nbsp;</a></span>PGCD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long int csl::PGCD </td>
          <td>(</td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the PGCD of a and b. </p>
<p>Proceeds to verifications on <em>a</em> and <em>b</em> (sign, non zero, etc) and calls internal_PGCD(int a, int b) if everythiong is Ok. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PGCD(a,b) </dd></dl>

</div>
</div>
<a id="a39a4d5d0b5daeb571db05ae3bb2d36e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a4d5d0b5daeb571db05ae3bb2d36e4">&#9670;&nbsp;</a></span>pow_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::pow_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>leftOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rightOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <b>exponentiation</b> of the two operands, applying basic simplifications. </p>
<p>This function possibly returns an object different from a <a class="el" href="classcsl_1_1Pow.html" title="Handles the exponentiation of one Abstract wrt another. ">Pow</a> object if the simplification requires so. For example x^1 -&gt; x that is a <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftOperand</td><td>Left operand. </td></tr>
    <tr><td class="paramname">rightOperand</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exponentiation of <b>leftOperand</b> and <b>rightOperand</b>. </dd></dl>

</div>
</div>
<a id="aab212e3a250819d11a12e4ad019a3b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab212e3a250819d11a12e4ad019a3b7e">&#9670;&nbsp;</a></span>printVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::printVector </td>
          <td>(</td>
          <td class="paramtype">const csl::vector_expr &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display a vector of expressions. Useful in debug. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>std::vector of expressions to display. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8a7809aa1495de26d449b25c5676215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a7809aa1495de26d449b25c5676215">&#9670;&nbsp;</a></span>prod_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::prod_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>leftOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rightOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>explicitProd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <b>product</b> of the two operands, applying basic simplifications. </p>
<p>This function possibly returns an object different from a <a class="el" href="classcsl_1_1Prod.html" title="Handles a product, function of multiple arguments. ">Prod</a> object if the simplification requires so. For example 1*x -&gt; x that is a <a class="el" href="classcsl_1_1Variable.html" title="Handle an object with a name and a value. ">Variable</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftOperand</td><td>Left operand. </td></tr>
    <tr><td class="paramname">rightOperand</td><td>Right operand. </td></tr>
    <tr><td class="paramname">explicitProd</td><td>If <b>true</b> <a class="el" href="classcsl_1_1Prod.html#a6fd5885a37a7e6492ec7777121e23944" title="Merge identical terms. ">Prod::mergeTerms()</a> is not called and no simplification is done concerning the reordering/merging of terms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of <b>leftOperand</b> and <b>rightOperand</b>. </dd></dl>

</div>
</div>
<a id="a045a1acfa56caebfe583aea20e4222ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045a1acfa56caebfe583aea20e4222ea">&#9670;&nbsp;</a></span>reduceAlternate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::reduceAlternate </td>
          <td>(</td>
          <td class="paramtype">csl::vector_expr &amp;&#160;</td>
          <td class="paramname"><em>alternateForms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces the number of elements in <b>alternateForms</b> to MAX_ALTERNATE_FORMS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alternateForms</td><td>std::vector of expressions to reduce. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad292d5ba73b91dee12de72e4c96996b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad292d5ba73b91dee12de72e4c96996b3">&#9670;&nbsp;</a></span>reducePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::reducePermutation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Permutation.html">Permutation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a vector of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> objects and erase the redundant ones, i.e. the permutations present several times in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutation</td><td>std::vector of <a class="el" href="classcsl_1_1Permutation.html" title="Handles a std::vector of integers that represents the permutation of n indices, with a possible symme...">Permutation</a> to reduce (modified during the call of the function). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c5e3c2f5f4c6533ac74d150d29f931d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5e3c2f5f4c6533ac74d150d29f931d">&#9670;&nbsp;</a></span>Refreshed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Refreshed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Abstract.html">Abstract</a> *&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="namespacecsl.html#a90a30db275050c669fbe24152402c28e" title="Refreshed an Abstract and apply basic simplifications. ">Refreshed(const Expr&amp; expr)</a>. </p>
<dl class="section note"><dt>Note</dt><dd>With the apparition of shared_from_this(), this function should be removed soon. </dd></dl>

</div>
</div>
<a id="a90a30db275050c669fbe24152402c28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a30db275050c669fbe24152402c28e">&#9670;&nbsp;</a></span>Refreshed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Refreshed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Refreshed</b> an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> and apply basic simplifications. </p>
<p>Apply all simplifications that take place normally at the creation of an <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. For example, a sum with only one term gives just the term in question. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a> to refresh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The refreshed <a class="el" href="classcsl_1_1Abstract.html" title="Root class of the inheritance tree of abstracts. ">Abstract</a>. </dd></dl>

</div>
</div>
<a id="abc696cee24297cc1ca72e9ce5cfae806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc696cee24297cc1ca72e9ce5cfae806">&#9670;&nbsp;</a></span>ruleToPredicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto csl::ruleToPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecsl.html#aa804192228c299d8b648e4dc194cb689">replacementRule</a> const &amp;&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a replacementRule into a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule</td><td>The replacement rule to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A lambda expression that calls the rule with a the "predicate" specification (meaning that the rule should not calculate the result of the replacement) and simply returns the boolean value of the returned optional. </dd></dl>

</div>
</div>
<a id="adcde11ad745cfee42e9efa83d145031a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcde11ad745cfee42e9efa83d145031a">&#9670;&nbsp;</a></span>selectionSort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::selectionSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the selection sort algorithm <img class="formulaInl" alt="$ \mathcal{O}(N^2) $" src="form_39.png"/> on a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argument</td><td>Container to sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa60374eb375314f6f7c661a35c01e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa60374eb375314f6f7c661a35c01e67">&#9670;&nbsp;</a></span>selectionSort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::selectionSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the selection sort algorithm <img class="formulaInl" alt="$ \mathcal{O}(N^2) $" src="form_39.png"/> on a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element (.begin()). </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the last element (.end()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62ae14b0bc1a6b3f7e9138421b2b8360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ae14b0bc1a6b3f7e9138421b2b8360">&#9670;&nbsp;</a></span>sgn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long int csl::sgn </td>
          <td>(</td>
          <td class="paramtype">long long int&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sign of a. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sign(a) </dd></dl>

</div>
</div>
<a id="a36cdda72e72136f4b0afec1d865361c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cdda72e72136f4b0afec1d865361c5">&#9670;&nbsp;</a></span>sgn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csl::sgn </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sign of a. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sign(a) </dd></dl>

</div>
</div>
<a id="ad27c8d3dd60c235e3e804b97790110ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27c8d3dd60c235e3e804b97790110ab">&#9670;&nbsp;</a></span>Simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::Simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Simplifies</b> <b>expr</b> depending on its type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to reduce. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of simplification. Default=1: <b>max depth</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The simplified expression. </dd></dl>

</div>
</div>
<a id="a5f030b62fc81f11147493796bfa30b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f030b62fc81f11147493796bfa30b54">&#9670;&nbsp;</a></span>sin_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::sin_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Sin.html" title="Final specialization of AbstractFunc, the sin function. ">Sin</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an sin. Then the return value is not an <a class="el" href="classcsl_1_1Sin.html" title="Final specialization of AbstractFunc, the sin function. ">Sin</a> object but something else, so we must implement a function that will create the good object. For example sin(0) returns 0 (a Number) and not sin(0) (an <a class="el" href="classcsl_1_1Sin.html" title="Final specialization of AbstractFunc, the sin function. ">Sin</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>sin</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Sin.html" title="Final specialization of AbstractFunc, the sin function. ">Sin</a> applied on expr </dd></dl>

</div>
</div>
<a id="a2aab7af831ac14498b23ac3daa80d1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aab7af831ac14498b23ac3daa80d1d5">&#9670;&nbsp;</a></span>sinh_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::sinh_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Sinh.html" title="Final specialization of AbstractFunc, the sinh function. ">Sinh</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an sinh. Then the return value is not an <a class="el" href="classcsl_1_1Sinh.html" title="Final specialization of AbstractFunc, the sinh function. ">Sinh</a> object but something else, so we must implement a function that will create the good object. For example sinh(0) returns 0 (a Number) and not sinh(0) (an <a class="el" href="classcsl_1_1Sinh.html" title="Final specialization of AbstractFunc, the sinh function. ">Sinh</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>sinh</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Sinh.html" title="Final specialization of AbstractFunc, the sinh function. ">Sinh</a> applied on expr </dd></dl>

</div>
</div>
<a id="a30af37876f8c6102a9a0ffcb83c78f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30af37876f8c6102a9a0ffcb83c78f13">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::sort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a container using <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argument</td><td>Container to sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a038131f4648d3a85d7f66956b9a052f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038131f4648d3a85d7f66956b9a052f9">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::sort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcsl_1_1Expr.html">Expr</a> &gt;::iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a container using <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first element (.begin()). </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing to the last element (.end()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbaab772a8fb873c65e06d079e73cd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaab772a8fb873c65e06d079e73cd06">&#9670;&nbsp;</a></span>tan_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::tan_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Tan.html" title="Final specialization of AbstractFunc, the tan function. ">Tan</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an tan. Then the return value is not an <a class="el" href="classcsl_1_1Tan.html" title="Final specialization of AbstractFunc, the tan function. ">Tan</a> object but something else, so we must implement a function that will create the good object. For example tan(0) returns 0 (a Number) and not tan(0) (a <a class="el" href="classcsl_1_1Tan.html" title="Final specialization of AbstractFunc, the tan function. ">Tan</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>tan</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Tan.html" title="Final specialization of AbstractFunc, the tan function. ">Tan</a> applied on expr </dd></dl>

</div>
</div>
<a id="a8a0975103bcda47f0e7a335677ba8e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0975103bcda47f0e7a335677ba8e1f">&#9670;&nbsp;</a></span>tanh_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::tanh_s </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Creates</b> an object of type <a class="el" href="classcsl_1_1Tanh.html" title="Final specialization of AbstractFunc, the tanh function. ">Tanh</a> acting on <b>expr</b>. </p>
<p>As all the outside-class functions, this one take into account the fact that the final object could not be an tanh. Then the return value is not an <a class="el" href="classcsl_1_1Tanh.html" title="Final specialization of AbstractFunc, the tanh function. ">Tanh</a> object but something else, so we must implement a function that will create the good object. For example tanh(0) returns 0 (a Number) and not tanh(0) (a <a class="el" href="classcsl_1_1Tanh.html" title="Final specialization of AbstractFunc, the tanh function. ">Tanh</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Argment of the <b>tanh</b> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcsl_1_1Tanh.html" title="Final specialization of AbstractFunc, the tanh function. ">Tanh</a> applied on expr </dd></dl>

</div>
</div>
<a id="aba0af68b54eefa2d567faed146678ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0af68b54eefa2d567faed146678ad7">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool csl::Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a user function on each node of an expression. The expression may be modified. If it is, the expression is refreshed. </p>
<p>This algorithm browses the whole expression applying <b>f</b> to each node. The user function must return true if the expression has to be refreshed after the transformation, false else. If you do not want to refresh the expression (powerful but heavy) consider using <a class="el" href="namespacecsl.html#a8bbe21d8979e1d4fa2e9242a34c397be" title="Applies a user function on each node of an expression. The expression may be modified. ">ForEachNode()</a> instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression to browse. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a>&amp; (may or may not modify it) as parameter. Must return a boolean, true if the expression requires a refresh after the call, false else. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a8bbe21d8979e1d4fa2e9242a34c397be" title="Applies a user function on each node of an expression. The expression may be modified. ">ForEachNode()</a>, <a class="el" href="namespacecsl.html#a9c5e3c2f5f4c6533ac74d150d29f931d" title="See Refreshed(const Expr&amp; expr). ">Refreshed()</a>, <a class="el" href="namespacecsl.html#ae95bf5940e1dda061d2d9fbdd1a9fff8" title="Refreshed recursively an Abstract and apply basic simplifications. ">DeepRefreshed()</a>. </dd></dl>

</div>
</div>
<a id="a795b923fd042a73265a04f5fa551362b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795b923fd042a73265a04f5fa551362b">&#9670;&nbsp;</a></span>VisitEachLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::VisitEachLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visits all leafs of an expression, applying a function on it without modifying it. </p>
<p>This algorithm browses all the leafs of <b>init</b> applying <b>f</b> each time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression to browse. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> const&amp; as parameter and returning nothing. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#ab32d8a121c108b533a4e746a10d737ba" title="Visits all nodes of an expression, applying a function on it without modifying it. ">VisitEachNode()</a>, <a class="el" href="namespacecsl.html#abfb7fdd6c18bd8a98bfa3674e4bebefb" title="Visits all nodes of an expression, applying a function on it without modifying it. When the user function returns true on one node, the underlying branch (if there is) is not explored. ">VisitEachNodeCut()</a>. </dd></dl>

</div>
</div>
<a id="ab32d8a121c108b533a4e746a10d737ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32d8a121c108b533a4e746a10d737ba">&#9670;&nbsp;</a></span>VisitEachNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::VisitEachNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visits all nodes of an expression, applying a function on it without modifying it. </p>
<p>This algorithm browses the whole expression applying <b>f</b> to each node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression to browse. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> const&amp; as parameter and returning nothing. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a795b923fd042a73265a04f5fa551362b" title="Visits all leafs of an expression, applying a function on it without modifying it. ">VisitEachLeaf()</a>, <a class="el" href="namespacecsl.html#abfb7fdd6c18bd8a98bfa3674e4bebefb" title="Visits all nodes of an expression, applying a function on it without modifying it. When the user function returns true on one node, the underlying branch (if there is) is not explored. ">VisitEachNodeCut()</a>. </dd></dl>

</div>
</div>
<a id="abfb7fdd6c18bd8a98bfa3674e4bebefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb7fdd6c18bd8a98bfa3674e4bebefb">&#9670;&nbsp;</a></span>VisitEachNodeCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csl::VisitEachNodeCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classcsl_1_1Expr.html">Expr</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visits all nodes of an expression, applying a function on it without modifying it. When the user function returns true on one node, the underlying branch (if there is) is not explored. </p>
<p>This algorithm browses the whole expression applying <b>f</b> to each node. The user function must return a boolean. If true, the algorithm stops on the node (other branches are still explored). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Expression to browse. </td></tr>
    <tr><td class="paramname">f</td><td>std::function (can be a c++ lambda expression) taking an <a class="el" href="classcsl_1_1Expr.html" title="Expression type/. ">Expr</a> const&amp; as parameter and returning a boolean telling if the algorithm must stop on that branch. </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion in the search (default = -1, full recursion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecsl.html#a795b923fd042a73265a04f5fa551362b" title="Visits all leafs of an expression, applying a function on it without modifying it. ">VisitEachLeaf()</a>, <a class="el" href="namespacecsl.html#ab32d8a121c108b533a4e746a10d737ba" title="Visits all nodes of an expression, applying a function on it without modifying it. ">VisitEachNode()</a>. </dd></dl>

</div>
</div>
<a id="ab82c5a52247dd5ef84518d51deade500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82c5a52247dd5ef84518d51deade500">&#9670;&nbsp;</a></span>WeakCommutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcsl_1_1Expr.html">Expr</a> csl::WeakCommutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcsl_1_1Expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of the (anit-)commutation of <b>A</b> and <b>B</b>. In most cases it returns CSL_0, and returns CSL_UNDEF else. Useful to test if two objects commute. In the special of this function, <b>A</b> is an object that is not commutable (attribute Abstract::commutable) and <b>B</b> is commutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Left hand side. </td></tr>
    <tr><td class="paramname">B</td><td>Right hand side. </td></tr>
    <tr><td class="paramname">sign</td><td>Sign of the commutator, -1 for commutation (default), 1 for anti-commutation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CSL_0 if <b>A</b> and <b>B</b> commute. </dd>
<dd>
CSL_UNDEF else. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab3885c426f3cbbc274fe4ce33aae739b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3885c426f3cbbc274fe4ce33aae739b">&#9670;&nbsp;</a></span>minMergeSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t csl::minMergeSize = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum size for a container to be sorted with <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>. </p>
<p>For smaller containers, <a class="el" href="namespacecsl.html#adcde11ad745cfee42e9efa83d145031a" title="Applies the selection sort algorithm  on a container. ">selectionSort()</a> is called instead, even trying to use specifically <a class="el" href="namespacecsl.html#a1c48c85e78f6b663a82bd7e100ad68d0" title="Applies the merge sort algorithm  on a container. ">mergeSort()</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
