<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MARTY: mty::SemiSimpleAlgebra Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/Slashed.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image.png" href="../../../logo-marty.png"/>
<link href="style_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
      <a href="https://marty.in2p3.fr"><img alt="Logo" src="Logo1.svg" height=100px/></a></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">
       Documentation of <i><b>MARTY</b></i>
   </div>
   <div id="projectbrief">
       <it>A <b>M</b>odern <b>AR</b>tificial <b>T</b>heoretical 
       ph<b>Y</b>sicist</it>
   </div>
  </td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemty.html">mty</a></li><li class="navelem"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html">SemiSimpleAlgebra</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">mty::SemiSimpleAlgebra Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class for all semi-simple Lie algebras.  
 <a href="classmty_1_1SemiSimpleAlgebra.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="semiSimpleAlgebra_8h_source.html">semiSimpleAlgebra.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mty::SemiSimpleAlgebra:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmty_1_1SemiSimpleAlgebra__inherit__graph.svg" width="344" height="494"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a08429df3b2869d35ef2f5399a679c520"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a08429df3b2869d35ef2f5399a679c520">SemiSimpleAlgebra</a> (int t_l)</td></tr>
<tr class="memdesc:a08429df3b2869d35ef2f5399a679c520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with one parameter.  <a href="#a08429df3b2869d35ef2f5399a679c520">More...</a><br /></td></tr>
<tr class="separator:a08429df3b2869d35ef2f5399a679c520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528476431b2a6c2db45667be258d4de4"><td class="memItemLeft" align="right" valign="top"><a id="a528476431b2a6c2db45667be258d4de4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a528476431b2a6c2db45667be258d4de4">~SemiSimpleAlgebra</a> ()</td></tr>
<tr class="memdesc:a528476431b2a6c2db45667be258d4de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a528476431b2a6c2db45667be258d4de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08445d84837a3ee0818e999a8e3afa84"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a08445d84837a3ee0818e999a8e3afa84">getQuadraticCasimir</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;irrep) const</td></tr>
<tr class="memdesc:a08445d84837a3ee0818e999a8e3afa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression (symbolic, rational number) of the quadratic Casimir operator for a representation.  <a href="#a08445d84837a3ee0818e999a8e3afa84">More...</a><br /></td></tr>
<tr class="separator:a08445d84837a3ee0818e999a8e3afa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e39ef348b8e127f4021efb0c9ab1fd5"><td class="memItemLeft" align="right" valign="top"><a id="a6e39ef348b8e127f4021efb0c9ab1fd5"></a>
virtual <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getIndex</b> (const <a class="el" href="classmty_1_1Irrep.html">Irrep</a> &amp;irrep, size_t n) const</td></tr>
<tr class="separator:a6e39ef348b8e127f4021efb0c9ab1fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a9a01df2e34c751d96a8d7ed448606"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmty_1_1Irrep.html">Irrep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a88a9a01df2e34c751d96a8d7ed448606">highestWeightRep</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;highestWeight, bool mult=true) const</td></tr>
<tr class="memdesc:a88a9a01df2e34c751d96a8d7ed448606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the highest weight representation. Determines all states with their multiplicities and returns the corresponding <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a> object. Overriden in R algebra.  <a href="#a88a9a01df2e34c751d96a8d7ed448606">More...</a><br /></td></tr>
<tr class="separator:a88a9a01df2e34c751d96a8d7ed448606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c838647f859770f69d7a1ebc3f4b25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmty_1_1Irrep.html">Irrep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#ae2c838647f859770f69d7a1ebc3f4b25">highestWeightRep</a> (const std::vector&lt; int &gt; &amp;highestWeight, bool mult=true) const</td></tr>
<tr class="memdesc:ae2c838647f859770f69d7a1ebc3f4b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the highest weight representation. Determines all states with their multiplicities and returns the corresponding <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a> object. Overriden in R algebra.  <a href="#ae2c838647f859770f69d7a1ebc3f4b25">More...</a><br /></td></tr>
<tr class="separator:ae2c838647f859770f69d7a1ebc3f4b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fd976502d861fc07ea61739c154e99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmty_1_1Irrep.html">Irrep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a49fd976502d861fc07ea61739c154e99">getTrivialRep</a> () const</td></tr>
<tr class="memdesc:a49fd976502d861fc07ea61739c154e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trivial representation of the algebra. Overriden in R algebra.  <a href="#a49fd976502d861fc07ea61739c154e99">More...</a><br /></td></tr>
<tr class="separator:a49fd976502d861fc07ea61739c154e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24200a3ce37c7de85685afe1d8f43f6a"><td class="memItemLeft" align="right" valign="top"><a id="a24200a3ce37c7de85685afe1d8f43f6a"></a>
virtual <a class="el" href="classmty_1_1Irrep.html">Irrep</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getDefiningRep</b> () const</td></tr>
<tr class="separator:a24200a3ce37c7de85685afe1d8f43f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b115c5f8711fd19ec740f3b72cc2535"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmty_1_1SumIrrep.html">SumIrrep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a6b115c5f8711fd19ec740f3b72cc2535">tensorProduct</a> (const <a class="el" href="classmty_1_1Irrep.html">Irrep</a> &amp;<a class="el" href="classmty_1_1algebra_1_1A.html">A</a>, const <a class="el" href="classmty_1_1Irrep.html">Irrep</a> &amp;<a class="el" href="classmty_1_1algebra_1_1B.html">B</a>, bool mult=true) const</td></tr>
<tr class="memdesc:a6b115c5f8711fd19ec740f3b72cc2535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the product of two <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a> in the algebra. The result is decomposed in a sum of irreducible representations, stored in a <a class="el" href="classmty_1_1SumIrrep.html" title="Contains a sum of Irrep (irreducible representation) of a given SemiSimpleAlgebra. ">SumIrrep</a>. Overriden in the R algebra.  <a href="#a6b115c5f8711fd19ec740f3b72cc2535">More...</a><br /></td></tr>
<tr class="separator:a6b115c5f8711fd19ec740f3b72cc2535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac020594ec47ad8ec26a4ab7d639f1202"><td class="memItemLeft" align="right" valign="top"><a id="ac020594ec47ad8ec26a4ab7d639f1202"></a>
virtual <a class="el" href="classmty_1_1SumIrrep.html">SumIrrep</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tensorProduct</b> (const <a class="el" href="classmty_1_1SumIrrep.html">SumIrrep</a> &amp;<a class="el" href="classmty_1_1algebra_1_1A.html">A</a>, const <a class="el" href="classmty_1_1Irrep.html">Irrep</a> &amp;<a class="el" href="classmty_1_1algebra_1_1B.html">B</a>, bool mult=true) const</td></tr>
<tr class="separator:ac020594ec47ad8ec26a4ab7d639f1202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b26f9216bb204ba7858546e049ea88"><td class="memItemLeft" align="right" valign="top"><a id="a41b26f9216bb204ba7858546e049ea88"></a>
virtual <a class="el" href="classmty_1_1SumIrrep.html">SumIrrep</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tensorProduct</b> (const <a class="el" href="classmty_1_1Irrep.html">Irrep</a> &amp;<a class="el" href="classmty_1_1algebra_1_1A.html">A</a>, const <a class="el" href="classmty_1_1SumIrrep.html">SumIrrep</a> &amp;<a class="el" href="classmty_1_1algebra_1_1B.html">B</a>, bool mult=true) const</td></tr>
<tr class="separator:a41b26f9216bb204ba7858546e049ea88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbd8240dfad0eb04aff4cc288db2dc1"><td class="memItemLeft" align="right" valign="top"><a id="a6fbd8240dfad0eb04aff4cc288db2dc1"></a>
<a class="el" href="classmty_1_1SumIrrep.html">SumIrrep</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tensorProduct</b> (const <a class="el" href="classmty_1_1SumIrrep.html">SumIrrep</a> &amp;<a class="el" href="classmty_1_1algebra_1_1A.html">A</a>, const <a class="el" href="classmty_1_1SumIrrep.html">SumIrrep</a> &amp;<a class="el" href="classmty_1_1algebra_1_1B.html">B</a>, bool mult=true) const</td></tr>
<tr class="separator:a6fbd8240dfad0eb04aff4cc288db2dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f57c0b5a49af2a8474fdef58da9538c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a4f57c0b5a49af2a8474fdef58da9538c">sortRep</a> (std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; &amp;rep, std::vector&lt; int &gt; &amp;mult) const</td></tr>
<tr class="memdesc:a4f57c0b5a49af2a8474fdef58da9538c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts by modifing input paramaters a set of <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> with their multiplicities. One state is considered "bigger" than another if the sum of its dinkin labels is bigger. Overriden in the R algebra.  <a href="#a4f57c0b5a49af2a8474fdef58da9538c">More...</a><br /></td></tr>
<tr class="separator:a4f57c0b5a49af2a8474fdef58da9538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9236993d9c52d7d8814401436d9d02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a5c9236993d9c52d7d8814401436d9d02">getOrderL</a> () const</td></tr>
<tr class="memdesc:a5c9236993d9c52d7d8814401436d9d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the order of the algebra, i.e. the number of simple roots <b>l</b>.  <a href="#a5c9236993d9c52d7d8814401436d9d02">More...</a><br /></td></tr>
<tr class="separator:a5c9236993d9c52d7d8814401436d9d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576f5c44114980964d3688ec710e54f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemty_1_1algebra.html#a6a408a40adf4bdcbb2de53ae0917062a">algebra::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a576f5c44114980964d3688ec710e54f1">getType</a> () const =0</td></tr>
<tr class="memdesc:a576f5c44114980964d3688ec710e54f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function overriden in derived classes.  <a href="#a576f5c44114980964d3688ec710e54f1">More...</a><br /></td></tr>
<tr class="separator:a576f5c44114980964d3688ec710e54f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6ca6c984a49944b59b0b949ca245551c"><td class="memItemLeft" align="right" valign="top"><a id="a6ca6c984a49944b59b0b949ca245551c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a6ca6c984a49944b59b0b949ca245551c">init</a> ()</td></tr>
<tr class="memdesc:a6ca6c984a49944b59b0b949ca245551c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization function called in derived classes to initialize the cartan matrix, the Weyl group and the norms of simple roots. <br /></td></tr>
<tr class="separator:a6ca6c984a49944b59b0b949ca245551c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca87a7cb7f2dc2b7d534cad69d42774"><td class="memItemLeft" align="right" valign="top"><a id="a5ca87a7cb7f2dc2b7d534cad69d42774"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a5ca87a7cb7f2dc2b7d534cad69d42774">setCartanMatrix</a> ()=0</td></tr>
<tr class="memdesc:a5ca87a7cb7f2dc2b7d534cad69d42774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function overriden in derived classes. Initializes the Cartan matrix specifically to the given semi-simple Lie algebra. <br /></td></tr>
<tr class="separator:a5ca87a7cb7f2dc2b7d534cad69d42774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e65a608faddab538f9ec73a69692cfc"><td class="memItemLeft" align="right" valign="top"><a id="a1e65a608faddab538f9ec73a69692cfc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a1e65a608faddab538f9ec73a69692cfc">setSquaredNorm</a> ()=0</td></tr>
<tr class="memdesc:a1e65a608faddab538f9ec73a69692cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function overriden in derived classes. Initializes norms of simple roots specifically to the given semi-simple Lie algebra. <br /></td></tr>
<tr class="separator:a1e65a608faddab538f9ec73a69692cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed5474daa7b7292c97499a2a276b0dc"><td class="memItemLeft" align="right" valign="top"><a id="a0ed5474daa7b7292c97499a2a276b0dc"></a>
virtual <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getEta</b> () const</td></tr>
<tr class="separator:a0ed5474daa7b7292c97499a2a276b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a05112dc753491ad590f22e6aec5a1612"><td class="memItemLeft" align="right" valign="top"><a id="a05112dc753491ad590f22e6aec5a1612"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a05112dc753491ad590f22e6aec5a1612">l</a></td></tr>
<tr class="memdesc:a05112dc753491ad590f22e6aec5a1612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of the semi-simple algebra, i.e. number of simple roots. <br /></td></tr>
<tr class="separator:a05112dc753491ad590f22e6aec5a1612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7ba151cd190383663b1ab77b2d445b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a8f7ba151cd190383663b1ab77b2d445b">rho</a></td></tr>
<tr class="memdesc:a8f7ba151cd190383663b1ab77b2d445b"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::vector of size <b>l</b>. Particular root (half-sum of simple roots) useful in calculations.  <a href="#a8f7ba151cd190383663b1ab77b2d445b">More...</a><br /></td></tr>
<tr class="separator:a8f7ba151cd190383663b1ab77b2d445b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1613618ad6be9ea31643922f1cedff6c"><td class="memItemLeft" align="right" valign="top"><a id="a1613618ad6be9ea31643922f1cedff6c"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a1613618ad6be9ea31643922f1cedff6c">absoluteNorms</a></td></tr>
<tr class="memdesc:a1613618ad6be9ea31643922f1cedff6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute norms of simple roots used in the computation of the quadratic Casimir operator. See <a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a08445d84837a3ee0818e999a8e3afa84" title="Returns the expression (symbolic, rational number) of the quadratic Casimir operator for a representa...">SemiSimpleAlgebra::getQuadraticCasimir()</a>. <br /></td></tr>
<tr class="separator:a1613618ad6be9ea31643922f1cedff6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd98963d6d3c5a536267529a4a2c60c"><td class="memItemLeft" align="right" valign="top"><a id="a4fd98963d6d3c5a536267529a4a2c60c"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a4fd98963d6d3c5a536267529a4a2c60c">squaredNorm</a></td></tr>
<tr class="memdesc:a4fd98963d6d3c5a536267529a4a2c60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::vector of integers of size <b>l</b>. Contains squared norms of all simple roots. <br /></td></tr>
<tr class="separator:a4fd98963d6d3c5a536267529a4a2c60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca8e06e270dbb72139e494cde8a5dbe"><td class="memItemLeft" align="right" valign="top"><a id="a9ca8e06e270dbb72139e494cde8a5dbe"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a9ca8e06e270dbb72139e494cde8a5dbe">positiveRoots</a></td></tr>
<tr class="memdesc:a9ca8e06e270dbb72139e494cde8a5dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all positive roots in a std::vector. Each positive root is a std::vector of integers of size <b>l:</b> dinkin labels in co-root space. <br /></td></tr>
<tr class="separator:a9ca8e06e270dbb72139e494cde8a5dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb7df0522ee6aea21d3e540d25e457a"><td class="memItemLeft" align="right" valign="top"><a id="aacb7df0522ee6aea21d3e540d25e457a"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#aacb7df0522ee6aea21d3e540d25e457a">cartanMatrix</a></td></tr>
<tr class="memdesc:aacb7df0522ee6aea21d3e540d25e457a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cartan matrix of the algebra. <br /></td></tr>
<tr class="separator:aacb7df0522ee6aea21d3e540d25e457a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f221731862eaae617f45cb219c8530"><td class="memItemLeft" align="right" valign="top"><a id="a41f221731862eaae617f45cb219c8530"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a41f221731862eaae617f45cb219c8530">rootMetric</a></td></tr>
<tr class="memdesc:a41f221731862eaae617f45cb219c8530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metric for roots in co-root space, i.e. metrix to apply in order to compute scalar dot between roots expressed with their dinkin labels. <br /></td></tr>
<tr class="separator:a41f221731862eaae617f45cb219c8530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf01c47b378082944e6d98b166d870c"><td class="memItemLeft" align="right" valign="top"><a id="a3cf01c47b378082944e6d98b166d870c"></a>
<a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a3cf01c47b378082944e6d98b166d870c">symbolicRho</a></td></tr>
<tr class="memdesc:a3cf01c47b378082944e6d98b166d870c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic version of the half-sum of simple roots (see <b>positiveRoots</b>). Contains the factor 1/2 that positiveRoots does not. <br /></td></tr>
<tr class="separator:a3cf01c47b378082944e6d98b166d870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb05c4a72c9d16ed16994057e7b7983"><td class="memItemLeft" align="right" valign="top"><a id="a3fb05c4a72c9d16ed16994057e7b7983"></a>
<a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a3fb05c4a72c9d16ed16994057e7b7983">symbolicCartan</a></td></tr>
<tr class="memdesc:a3fb05c4a72c9d16ed16994057e7b7983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic version of the cartan matrix. <br /></td></tr>
<tr class="separator:a3fb05c4a72c9d16ed16994057e7b7983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98c68e1832512d74e3f67c5199c6312"><td class="memItemLeft" align="right" valign="top"><a id="af98c68e1832512d74e3f67c5199c6312"></a>
<a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#af98c68e1832512d74e3f67c5199c6312">inverseCartan</a></td></tr>
<tr class="memdesc:af98c68e1832512d74e3f67c5199c6312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse cartan matrix. <br /></td></tr>
<tr class="separator:af98c68e1832512d74e3f67c5199c6312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac165b358e852e5adfacba2be3b7d468d"><td class="memItemLeft" align="right" valign="top"><a id="ac165b358e852e5adfacba2be3b7d468d"></a>
<a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#ac165b358e852e5adfacba2be3b7d468d">symbolicMetric</a></td></tr>
<tr class="memdesc:ac165b358e852e5adfacba2be3b7d468d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic metric in root space. i.e. different from <b>rootMetric</b> that is the metric in co-root space. <br /></td></tr>
<tr class="separator:ac165b358e852e5adfacba2be3b7d468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b9e8d3082b2ea00601ae26c59e4d4b"><td class="memItemLeft" align="right" valign="top"><a id="a57b9e8d3082b2ea00601ae26c59e4d4b"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a57b9e8d3082b2ea00601ae26c59e4d4b">symbolicRoots</a></td></tr>
<tr class="memdesc:a57b9e8d3082b2ea00601ae26c59e4d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic version of <b>positiveRoots</b>, each root is a <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Vector.html">csl::Vector</a> of <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Integer.html">csl::Integer</a> in co-root space (dinkin labels). <br /></td></tr>
<tr class="separator:a57b9e8d3082b2ea00601ae26c59e4d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47413b0fc354145adf28b42753899a08"><td class="memItemLeft" align="right" valign="top"><a id="a47413b0fc354145adf28b42753899a08"></a>
csl::vector_expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a47413b0fc354145adf28b42753899a08">symbolicSquaredNorms</a></td></tr>
<tr class="memdesc:a47413b0fc354145adf28b42753899a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic version of <b>squaredNorm</b>. <br /></td></tr>
<tr class="separator:a47413b0fc354145adf28b42753899a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c92eb6d42fdfd7fb14a202aa9d50e1"><td class="memItemLeft" align="right" valign="top"><a id="a49c92eb6d42fdfd7fb14a202aa9d50e1"></a>
std::vector&lt; std::pair&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>, <a class="el" href="classmty_1_1Irrep.html">Irrep</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>irreps</b></td></tr>
<tr class="separator:a49c92eb6d42fdfd7fb14a202aa9d50e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67899733c277cad4a381f9e77a64cf05"><td class="memItemLeft" align="right" valign="top"><a id="a67899733c277cad4a381f9e77a64cf05"></a>
std::vector&lt; <a class="el" href="structmty_1_1IndexData.html">IndexData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>indices</b></td></tr>
<tr class="separator:a67899733c277cad4a381f9e77a64cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9b9baf0bf3d8b79436ccd56b1b7d2676"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a9b9baf0bf3d8b79436ccd56b1b7d2676">isOnWall</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state) const</td></tr>
<tr class="memdesc:a9b9baf0bf3d8b79436ccd56b1b7d2676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a state is on a wall of the root lattice, i.e. if one of the coefficients if the simple roots basis (one of the dinkin labels) is zero.  <a href="#a9b9baf0bf3d8b79436ccd56b1b7d2676">More...</a><br /></td></tr>
<tr class="separator:a9b9baf0bf3d8b79436ccd56b1b7d2676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb228e4a5fdd3b08e23b8c81dc98742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a8bb228e4a5fdd3b08e23b8c81dc98742">toDominantWeylChamber</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state, int &amp;sign) const</td></tr>
<tr class="memdesc:a8bb228e4a5fdd3b08e23b8c81dc98742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflects a given state in the dominant Weyl chamber.  <a href="#a8bb228e4a5fdd3b08e23b8c81dc98742">More...</a><br /></td></tr>
<tr class="separator:a8bb228e4a5fdd3b08e23b8c81dc98742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd304629a2f6445da72ca29cc3219d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#afdcd304629a2f6445da72ca29cc3219d">weylReflection</a> (int simpleRoot, const std::vector&lt; int &gt; &amp;root) const</td></tr>
<tr class="memdesc:afdcd304629a2f6445da72ca29cc3219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflects a root with respect to one simple root.  <a href="#afdcd304629a2f6445da72ca29cc3219d">More...</a><br /></td></tr>
<tr class="separator:afdcd304629a2f6445da72ca29cc3219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b50c98c6d5651542a867169644ea48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#ac5b50c98c6d5651542a867169644ea48">weylReflection</a> (int simpleRoot, const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state) const</td></tr>
<tr class="memdesc:ac5b50c98c6d5651542a867169644ea48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflects a state with respect to one simple root.  <a href="#ac5b50c98c6d5651542a867169644ea48">More...</a><br /></td></tr>
<tr class="separator:ac5b50c98c6d5651542a867169644ea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86ace73b55c129b67b5a0227aff3f6b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#af86ace73b55c129b67b5a0227aff3f6b">weylReflection</a> (int simpleRoot1, int simpleRoot2) const</td></tr>
<tr class="memdesc:af86ace73b55c129b67b5a0227aff3f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflects a simple root with respect to another.  <a href="#af86ace73b55c129b67b5a0227aff3f6b">More...</a><br /></td></tr>
<tr class="separator:af86ace73b55c129b67b5a0227aff3f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13d03bd035103b4dbe3bb067399502f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#ad13d03bd035103b4dbe3bb067399502f">invertCartanMatrix</a> ()</td></tr>
<tr class="memdesc:ad13d03bd035103b4dbe3bb067399502f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the Cartan matrix using csl's matrix inversion and stores it in the member \b inverseCartan.  <a href="#ad13d03bd035103b4dbe3bb067399502f">More...</a><br /></td></tr>
<tr class="separator:ad13d03bd035103b4dbe3bb067399502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac33d15d20f0d4b1987d2206884b270c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#aac33d15d20f0d4b1987d2206884b270c">generateWeylGroup</a> ()</td></tr>
<tr class="memdesc:aac33d15d20f0d4b1987d2206884b270c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the Weyl group of reflection from the simple roots.  <a href="#aac33d15d20f0d4b1987d2206884b270c">More...</a><br /></td></tr>
<tr class="separator:aac33d15d20f0d4b1987d2206884b270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86d766a1920af5bd048f8d5cf05f131"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#aa86d766a1920af5bd048f8d5cf05f131">convertState</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state) const</td></tr>
<tr class="memdesc:aa86d766a1920af5bd048f8d5cf05f131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a state in co-root space (<a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> with dinkin labels) into an expression (csl <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>), Vector of coefficients in root space.  <a href="#aa86d766a1920af5bd048f8d5cf05f131">More...</a><br /></td></tr>
<tr class="separator:aa86d766a1920af5bd048f8d5cf05f131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31653fa80eacf51cde61805b6efe371d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a31653fa80eacf51cde61805b6efe371d">comparatorHighest</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;<a class="el" href="classmty_1_1algebra_1_1A.html">A</a>, const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;<a class="el" href="classmty_1_1algebra_1_1B.html">B</a>) const</td></tr>
<tr class="memdesc:a31653fa80eacf51cde61805b6efe371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>.  <a href="#a31653fa80eacf51cde61805b6efe371d">More...</a><br /></td></tr>
<tr class="separator:a31653fa80eacf51cde61805b6efe371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132aed8295ce39c26ec3c12a1a297031"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a132aed8295ce39c26ec3c12a1a297031">computeScalarDot</a> (const <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> &amp;rootA, const <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> &amp;rootB) const</td></tr>
<tr class="memdesc:a132aed8295ce39c26ec3c12a1a297031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar dot of two roots in root-space.  <a href="#a132aed8295ce39c26ec3c12a1a297031">More...</a><br /></td></tr>
<tr class="separator:a132aed8295ce39c26ec3c12a1a297031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a08f33456db7b57556d4823bab1b8d"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#af7a08f33456db7b57556d4823bab1b8d">computeSquaredNorm</a> (const <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> &amp;root) const</td></tr>
<tr class="memdesc:af7a08f33456db7b57556d4823bab1b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the squared norm of a root, see <a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a132aed8295ce39c26ec3c12a1a297031" title="Computes the scalar dot of two roots in root-space. ">computeScalarDot()</a>.  <a href="#af7a08f33456db7b57556d4823bab1b8d">More...</a><br /></td></tr>
<tr class="separator:af7a08f33456db7b57556d4823bab1b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67cd31edab8d99343267c7699307867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#ab67cd31edab8d99343267c7699307867">applyAnnihilationOperator</a> (int annihilator, const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state) const</td></tr>
<tr class="memdesc:ab67cd31edab8d99343267c7699307867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the annihilation operator of a simple root on an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> and returns the resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>.  <a href="#ab67cd31edab8d99343267c7699307867">More...</a><br /></td></tr>
<tr class="separator:ab67cd31edab8d99343267c7699307867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54df2613b7db7c598b804ee8d862abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#ad54df2613b7db7c598b804ee8d862abc">applyAnnihilationOperator</a> (const std::vector&lt; int &gt; &amp;root, const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state) const</td></tr>
<tr class="memdesc:ad54df2613b7db7c598b804ee8d862abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the annihilation operator of a root on an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> and returns the resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>.  <a href="#ad54df2613b7db7c598b804ee8d862abc">More...</a><br /></td></tr>
<tr class="separator:ad54df2613b7db7c598b804ee8d862abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8150f6739dbe7eae58aaa33038e782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a8e8150f6739dbe7eae58aaa33038e782">applyCreationOperator</a> (int creator, const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state) const</td></tr>
<tr class="memdesc:a8e8150f6739dbe7eae58aaa33038e782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the creation operator of a simple root on an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> and returns the resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>.  <a href="#a8e8150f6739dbe7eae58aaa33038e782">More...</a><br /></td></tr>
<tr class="separator:a8e8150f6739dbe7eae58aaa33038e782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad5a0d6cb86750149d06b72f7c1c21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a6ad5a0d6cb86750149d06b72f7c1c21a">applyCreationOperator</a> (const std::vector&lt; int &gt; &amp;root, const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state) const</td></tr>
<tr class="memdesc:a6ad5a0d6cb86750149d06b72f7c1c21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the creation operator of a root on an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> and returns the resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>.  <a href="#a6ad5a0d6cb86750149d06b72f7c1c21a">More...</a><br /></td></tr>
<tr class="separator:a6ad5a0d6cb86750149d06b72f7c1c21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e55621f6710d8810ccee0e7c3bf3a4b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a8e55621f6710d8810ccee0e7c3bf3a4b">getSingleChain</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state, int direction) const</td></tr>
<tr class="memdesc:a8e55621f6710d8810ccee0e7c3bf3a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the root chain starting from <b>states</b> and applying annihilation operator of the simple root number <br />
 direction.  <a href="#a8e55621f6710d8810ccee0e7c3bf3a4b">More...</a><br /></td></tr>
<tr class="separator:a8e55621f6710d8810ccee0e7c3bf3a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651d9b5597ea0edc4d9b71c3108a80a4"><td class="memItemLeft" align="right" valign="top"><a id="a651d9b5597ea0edc4d9b71c3108a80a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getSingleChainExperimental</b> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state, std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; &amp;states, std::vector&lt; std::vector&lt; bool &gt;&gt; &amp;directionExplored, int direction) const</td></tr>
<tr class="separator:a651d9b5597ea0edc4d9b71c3108a80a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08b41d39e4deb84c1e252e7d95710b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#ac08b41d39e4deb84c1e252e7d95710b1">getRootChain</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;highestWeightState, std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; states=std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt;(0), std::vector&lt; std::vector&lt; bool &gt; &gt; directions=std::vector&lt; std::vector&lt; bool &gt; &gt;(0)) const</td></tr>
<tr class="memdesc:ac08b41d39e4deb84c1e252e7d95710b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complete root chain (with all simple roots) starting from a highest weight <b>highestWeightState</b>.  <a href="#ac08b41d39e4deb84c1e252e7d95710b1">More...</a><br /></td></tr>
<tr class="separator:ac08b41d39e4deb84c1e252e7d95710b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57469135b5120e58f9f3f48c6fbbf6c"><td class="memItemLeft" align="right" valign="top"><a id="aa57469135b5120e58f9f3f48c6fbbf6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getRootChainExperimental</b> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;highestWeightState, std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; &amp;states, std::vector&lt; std::vector&lt; bool &gt; &gt; &amp;directions) const</td></tr>
<tr class="separator:aa57469135b5120e58f9f3f48c6fbbf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271ad4635ef21500976847a2820fdee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a271ad4635ef21500976847a2820fdee2">computeMultiplicity</a> (std::vector&lt; int &gt; &amp;<a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a3dabc2ca62085ee19c9a75797bccd250">multiplicities</a>, const std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; &amp;rep, const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state) const</td></tr>
<tr class="memdesc:a271ad4635ef21500976847a2820fdee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the multiplicity of the state <b>state</b>.  <a href="#a271ad4635ef21500976847a2820fdee2">More...</a><br /></td></tr>
<tr class="separator:a271ad4635ef21500976847a2820fdee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dabc2ca62085ee19c9a75797bccd250"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a3dabc2ca62085ee19c9a75797bccd250">multiplicities</a> (std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; &amp;rep) const</td></tr>
<tr class="memdesc:a3dabc2ca62085ee19c9a75797bccd250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the multiplicities of the states in <b>rep</b>, where <b>rep</b> is a complete set of <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>.  <a href="#a3dabc2ca62085ee19c9a75797bccd250">More...</a><br /></td></tr>
<tr class="separator:a3dabc2ca62085ee19c9a75797bccd250"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aae4d1dfd5a4b28cbc9cadb14038ce4b5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#aae4d1dfd5a4b28cbc9cadb14038ce4b5">isPositiveRoot</a> (const std::vector&lt; int &gt; &amp;root)</td></tr>
<tr class="memdesc:aae4d1dfd5a4b28cbc9cadb14038ce4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given root is a positive root (i.e. only positive dinkin labels).  <a href="#aae4d1dfd5a4b28cbc9cadb14038ce4b5">More...</a><br /></td></tr>
<tr class="separator:aae4d1dfd5a4b28cbc9cadb14038ce4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102b64632d6e55ca7e384e72520687fd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a102b64632d6e55ca7e384e72520687fd">isPositiveWeight</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;state)</td></tr>
<tr class="memdesc:a102b64632d6e55ca7e384e72520687fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given state is a positive state (i.e. only positive dinkin labels).  <a href="#a102b64632d6e55ca7e384e72520687fd">More...</a><br /></td></tr>
<tr class="separator:a102b64632d6e55ca7e384e72520687fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011954e6430884bd64347d1c110b7a37"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a011954e6430884bd64347d1c110b7a37">addWeights</a> (const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;<a class="el" href="classmty_1_1algebra_1_1A.html">A</a>, const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;<a class="el" href="classmty_1_1algebra_1_1B.html">B</a>)</td></tr>
<tr class="memdesc:a011954e6430884bd64347d1c110b7a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the dinkin labels of two states and returns the resulting state.  <a href="#a011954e6430884bd64347d1c110b7a37">More...</a><br /></td></tr>
<tr class="separator:a011954e6430884bd64347d1c110b7a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ade2bb4eb37ab85daa6d94402a1a2e482"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1SemiSimpleAlgebra.html#ade2bb4eb37ab85daa6d94402a1a2e482">operator&lt;&lt;</a> (std::ostream &amp;fout, const <a class="el" href="classmty_1_1SemiSimpleAlgebra.html">SemiSimpleAlgebra</a> &amp;algebra)</td></tr>
<tr class="memdesc:ade2bb4eb37ab85daa6d94402a1a2e482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of operator&lt;&lt; for <a class="el" href="classmty_1_1SemiSimpleAlgebra.html" title="Abstract base class for all semi-simple Lie algebras. ">SemiSimpleAlgebra</a>. Displays exhaustively members of the object.  <a href="#ade2bb4eb37ab85daa6d94402a1a2e482">More...</a><br /></td></tr>
<tr class="separator:ade2bb4eb37ab85daa6d94402a1a2e482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class for all semi-simple Lie algebras. </p>
<p>This class implements almost all calculations (getting representation from highest weight, product of representations...) except the initialization of the cartan matrix and the norms of simple roots, that is overriden in derived classes, specializations of semi simple Lie algebras. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a08429df3b2869d35ef2f5399a679c520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08429df3b2869d35ef2f5399a679c520">&#9670;&nbsp;</a></span>SemiSimpleAlgebra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mty::SemiSimpleAlgebra::SemiSimpleAlgebra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with one parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_l</td><td>Number of simple roots, or rank, of the algebra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a011954e6430884bd64347d1c110b7a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011954e6430884bd64347d1c110b7a37">&#9670;&nbsp;</a></span>addWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> mty::SemiSimpleAlgebra::addWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the dinkin labels of two states and returns the resulting state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> in the sum. </td></tr>
    <tr><td class="paramname">B</td><td>Second <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> in the sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of <b>A</b> and <b>B</b>. </dd></dl>

</div>
</div>
<a id="ab67cd31edab8d99343267c7699307867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67cd31edab8d99343267c7699307867">&#9670;&nbsp;</a></span>applyAnnihilationOperator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> mty::SemiSimpleAlgebra::applyAnnihilationOperator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>annihilator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the annihilation operator of a simple root on an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> and returns the resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annihilator</td><td>Integer number of the simple root. </td></tr>
    <tr><td class="paramname">state</td><td>State on which the annihilation operator is applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </dd></dl>

</div>
</div>
<a id="ad54df2613b7db7c598b804ee8d862abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54df2613b7db7c598b804ee8d862abc">&#9670;&nbsp;</a></span>applyAnnihilationOperator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> mty::SemiSimpleAlgebra::applyAnnihilationOperator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the annihilation operator of a root on an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> and returns the resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root from which we take the annihilation operator. </td></tr>
    <tr><td class="paramname">state</td><td>State on which the annihilation operator is applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </dd></dl>

</div>
</div>
<a id="a8e8150f6739dbe7eae58aaa33038e782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8150f6739dbe7eae58aaa33038e782">&#9670;&nbsp;</a></span>applyCreationOperator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> mty::SemiSimpleAlgebra::applyCreationOperator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>creator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the creation operator of a simple root on an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> and returns the resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">creator</td><td>Integer number of the simple root. </td></tr>
    <tr><td class="paramname">state</td><td>State on which the creation operator is applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </dd></dl>

</div>
</div>
<a id="a6ad5a0d6cb86750149d06b72f7c1c21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad5a0d6cb86750149d06b72f7c1c21a">&#9670;&nbsp;</a></span>applyCreationOperator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> mty::SemiSimpleAlgebra::applyCreationOperator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the creation operator of a root on an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> and returns the resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root from which we take the creation operator. </td></tr>
    <tr><td class="paramname">state</td><td>State on which the creation operator is applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </dd></dl>

</div>
</div>
<a id="a31653fa80eacf51cde61805b6efe371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31653fa80eacf51cde61805b6efe371d">&#9670;&nbsp;</a></span>comparatorHighest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mty::SemiSimpleAlgebra::comparatorHighest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </p>
<p>One <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> is considered greater than another if the sum of its labels is greater. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> to compare. </td></tr>
    <tr><td class="paramname">B</td><td>Second <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if A is greater than or equal to B. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a271ad4635ef21500976847a2820fdee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271ad4635ef21500976847a2820fdee2">&#9670;&nbsp;</a></span>computeMultiplicity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mty::SemiSimpleAlgebra::computeMultiplicity </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the multiplicity of the state <b>state</b>. </p>
<p>The multiplicity of the state depends on those of highest weight states. This function is then recursive and calculates on the go the multiplicities it needs if they have not been alreadt calculated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiplicities</td><td>std::vector of integers containing multiplicities. It is modified during the run, replacing the default -1 by the computed multiplicities. </td></tr>
    <tr><td class="paramname">rep</td><td>Set of all <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> in the representation. </td></tr>
    <tr><td class="paramname">state</td><td><a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> of which we compute the multiplicity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a132aed8295ce39c26ec3c12a1a297031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132aed8295ce39c26ec3c12a1a297031">&#9670;&nbsp;</a></span>computeScalarDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> mty::SemiSimpleAlgebra::computeScalarDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rootA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rootB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar dot of two roots in root-space. </p>
<p>The scalar dot depends on the Cartan matrix and norms of simple roots. <b>rootA</b> and <b>rootB</b> must be <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Vector.html">csl::Vector</a> of csl::Integers, coordinates of the roots in root space (not in co-root space i.e. dinkin labels). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootA</td><td>First root in the scalar dot. </td></tr>
    <tr><td class="paramname">rootB</td><td>Second root in the scalar dot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The geometrical scalar dot between <b>rootA</b> and <b>rootB</b>. </dd></dl>

</div>
</div>
<a id="af7a08f33456db7b57556d4823bab1b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a08f33456db7b57556d4823bab1b8d">&#9670;&nbsp;</a></span>computeSquaredNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> mty::SemiSimpleAlgebra::computeSquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the squared norm of a root, see <a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a132aed8295ce39c26ec3c12a1a297031" title="Computes the scalar dot of two roots in root-space. ">computeScalarDot()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root in the form of a <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Vector.html">csl::Vector</a> of <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Integer.html">csl::Integer</a>, labels in root space (not co-root space i.e. dinkin labels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The squared norm of <b>root</b> in a csl Expr. </dd></dl>

</div>
</div>
<a id="aa86d766a1920af5bd048f8d5cf05f131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86d766a1920af5bd048f8d5cf05f131">&#9670;&nbsp;</a></span>convertState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> mty::SemiSimpleAlgebra::convertState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a state in co-root space (<a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> with dinkin labels) into an expression (csl <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>), Vector of coefficients in root space. </p>
<p>This function actually converts the std::vector of integers into a <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Vector.html">csl::Vector</a> of <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Integer.html">csl::Integer</a>, and apply the inverse cartan matrix in order to go from co-root space to root space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td><a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Vector.html">csl::Vector</a> expression of the root space-equivalent of <b>state</b>. </dd></dl>

</div>
</div>
<a id="aac33d15d20f0d4b1987d2206884b270c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac33d15d20f0d4b1987d2206884b270c">&#9670;&nbsp;</a></span>generateWeylGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mty::SemiSimpleAlgebra::generateWeylGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the Weyl group of reflection from the simple roots. </p>
<p>The weyl group is stored by keeping all positive roots in memory in the member <b>positiveRoots</b>. Any weyl reflection (composition of weyl reflections for simple roots) is the weyl reflection wrt one single positive root. Having all positive roots is then equivalent to have all weyl reflections. </p>

</div>
</div>
<a id="a5c9236993d9c52d7d8814401436d9d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9236993d9c52d7d8814401436d9d02">&#9670;&nbsp;</a></span>getOrderL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mty::SemiSimpleAlgebra::getOrderL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the order of the algebra, i.e. the number of simple roots <b>l</b>. </p>
<dl class="section return"><dt>Returns</dt><dd><b>l</b> </dd></dl>

</div>
</div>
<a id="a08445d84837a3ee0818e999a8e3afa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08445d84837a3ee0818e999a8e3afa84">&#9670;&nbsp;</a></span>getQuadraticCasimir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> mty::SemiSimpleAlgebra::getQuadraticCasimir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>irrep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the expression (symbolic, rational number) of the quadratic Casimir operator for a representation. </p>
<p>The <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> <b>irrep</b> must be the highest-weight state of the representation from which we want to compute the Casimir. The quadratic Casimir is defined from the generators of the representation \( T^A(\mathcal{R}) \) by </p><p class="formulaDsp">
\[ \mbox{Tr}(T(\mathcal{R})^AT(\mathcal{R})^B) \equiv C_2(\mathcal{R}) \delta ^{AB}. \]
</p>
<p> Its expression in terms of the highest weight is </p><p class="formulaDsp">
\[ C_2 = \sum _{i, j}\mathcal{N}_i\cdot (a_i+2)G_{ij}a_j, \]
</p>
<p> with \( a_i \) dynkin labels of the highest weight state, \( G_{ij} \) the inverse Cartan matrix, and \( \mathcal{N}_i \) a normalization factor coming from the absolute norm of the simple root \( i \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irrep</td><td>Highest weight state of the representation from which we want the Casimir. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symbolic expression of the Casimir, a rational number. </dd></dl>

</div>
</div>
<a id="ac08b41d39e4deb84c1e252e7d95710b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08b41d39e4deb84c1e252e7d95710b1">&#9670;&nbsp;</a></span>getRootChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; mty::SemiSimpleAlgebra::getRootChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>highestWeightState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt;&#160;</td>
          <td class="paramname"><em>states</em> = <code>std::vector&lt;<a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a>&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; bool &gt; &gt;&#160;</td>
          <td class="paramname"><em>directions</em> = <code>std::vector&lt;std::vector&lt;bool&gt;&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complete root chain (with all simple roots) starting from a highest weight <b>highestWeightState</b>. </p>
<p>Some directions (simple roots) are not computed because they already have been explored. This function is recursive and calls itself again for all new states. If a state has been found along the direction d, then this direction will not be explored again getting the root chains recursively for this state. The new states are added in the std::vector <b>states</b> (copied at the beginning of the function), and this std::vector is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">highestWeightState</td><td>Initial state of the root chains. </td></tr>
    <tr><td class="paramname">states</td><td>Current set of stated found in the irrep. </td></tr>
    <tr><td class="paramname">directions</td><td>Set of already explored directions (along simple roots) for the state <b>highestWeightState</b>, that we do not compute again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A modified copy of <b>states</b>, where new states have been added. </dd></dl>

</div>
</div>
<a id="a8e55621f6710d8810ccee0e7c3bf3a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e55621f6710d8810ccee0e7c3bf3a4b">&#9670;&nbsp;</a></span>getSingleChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; mty::SemiSimpleAlgebra::getSingleChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the root chain starting from <b>states</b> and applying annihilation operator of the simple root number <br />
 direction. </p>
<p>If the eigenvalue of <b>state</b> wrt the simple root number <b>direction</b> is E, we apply the annihilation until we get a state of eigenvalue -E. We have then set of states of eigenvalues (for a sl(2,C) module): { E, E-2, E-4, ..., -E }. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Initial state (highest weight) of the chain. </td></tr>
    <tr><td class="paramname">direction</td><td>Number of the simple root applied in chain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of generated <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> in the chain in a std::vector. </dd></dl>

</div>
</div>
<a id="a49fd976502d861fc07ea61739c154e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fd976502d861fc07ea61739c154e99">&#9670;&nbsp;</a></span>getTrivialRep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1Irrep.html">mty::Irrep</a> mty::SemiSimpleAlgebra::getTrivialRep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the trivial representation of the algebra. Overriden in R algebra. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a>, trivial representation (dimension 1). </dd></dl>

<p>Reimplemented in <a class="el" href="classmty_1_1algebra_1_1R.html#a2d1733767a6bc7549161a2941d42e8e4">mty::algebra::R</a>.</p>

</div>
</div>
<a id="a576f5c44114980964d3688ec710e54f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576f5c44114980964d3688ec710e54f1">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemty_1_1algebra.html#a6a408a40adf4bdcbb2de53ae0917062a">algebra::Type</a> mty::SemiSimpleAlgebra::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function overriden in derived classes. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of the algebra, see the enum <a class="el" href="namespacemty_1_1algebra.html#a6a408a40adf4bdcbb2de53ae0917062a" title="Different types of semi-simple Lie algebras. ">algebra::Type</a>. </dd></dl>

<p>Implemented in <a class="el" href="classmty_1_1algebra_1_1G2.html#a42cd038a1844e100f5b5ec974b9b769e">mty::algebra::G2</a>, <a class="el" href="classmty_1_1algebra_1_1F4.html#a609d1fa96cb4a37074b5b20be0ea8d1b">mty::algebra::F4</a>, <a class="el" href="classmty_1_1algebra_1_1E8.html#a7f86ff2a6077ea1f8e7b9614c5733cda">mty::algebra::E8</a>, <a class="el" href="classmty_1_1algebra_1_1E7.html#ae90749b7cc0cd53a6e15d0fe1432d9a0">mty::algebra::E7</a>, <a class="el" href="classmty_1_1algebra_1_1E6.html#a913f345b3e17f8a505561bae1dc6311f">mty::algebra::E6</a>, <a class="el" href="classmty_1_1algebra_1_1D.html#a0c872ad597fba8edbd79fcff0bdefd88">mty::algebra::D</a>, <a class="el" href="classmty_1_1algebra_1_1C.html#a0b43ab4ab15929cdde844d56d068ab54">mty::algebra::C</a>, <a class="el" href="classmty_1_1algebra_1_1B.html#ad8f1a12874ff5bcab60e57076686e993">mty::algebra::B</a>, <a class="el" href="classmty_1_1algebra_1_1A.html#adbd5e004524619ff2d0f2fd5c3f60aa7">mty::algebra::A</a>, and <a class="el" href="classmty_1_1algebra_1_1R.html#ac427eaa24ff0852402b68f2dae79a8ab">mty::algebra::R</a>.</p>

</div>
</div>
<a id="a88a9a01df2e34c751d96a8d7ed448606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a9a01df2e34c751d96a8d7ed448606">&#9670;&nbsp;</a></span>highestWeightRep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1Irrep.html">mty::Irrep</a> mty::SemiSimpleAlgebra::highestWeightRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>highestWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mult</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the highest weight representation. Determines all states with their multiplicities and returns the corresponding <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a> object. Overriden in R algebra. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">highestWeight</td><td><a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> highest weight of the representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a> of highest weight <b>highestWeight</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classmty_1_1algebra_1_1R.html#ab2195fccaa79ebf1988a4a7be7050d15">mty::algebra::R</a>.</p>

</div>
</div>
<a id="ae2c838647f859770f69d7a1ebc3f4b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c838647f859770f69d7a1ebc3f4b25">&#9670;&nbsp;</a></span>highestWeightRep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1Irrep.html">mty::Irrep</a> mty::SemiSimpleAlgebra::highestWeightRep </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>highestWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mult</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the highest weight representation. Determines all states with their multiplicities and returns the corresponding <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a> object. Overriden in R algebra. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">highestWeight</td><td>std::vector of integers, labels of the representation's highest weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a> of highest weight <b>highestWeight</b>. </dd></dl>

<p>Reimplemented in <a class="el" href="classmty_1_1algebra_1_1R.html#aa163053f165fb067e31fadc33360152a">mty::algebra::R</a>.</p>

</div>
</div>
<a id="ad13d03bd035103b4dbe3bb067399502f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13d03bd035103b4dbe3bb067399502f">&#9670;&nbsp;</a></span>invertCartanMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mty::SemiSimpleAlgebra::invertCartanMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the Cartan matrix using csl's matrix inversion and stores it in the member \b inverseCartan. </p>
<dl class="section note"><dt>Note</dt><dd>This function actually initializes also other csl <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> member variables. </dd></dl>

</div>
</div>
<a id="a9b9baf0bf3d8b79436ccd56b1b7d2676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9baf0bf3d8b79436ccd56b1b7d2676">&#9670;&nbsp;</a></span>isOnWall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mty::SemiSimpleAlgebra::isOnWall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a state is on a wall of the root lattice, i.e. if one of the coefficients if the simple roots basis (one of the dinkin labels) is zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td><a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if <b>state</b> is on a wall. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="aae4d1dfd5a4b28cbc9cadb14038ce4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4d1dfd5a4b28cbc9cadb14038ce4b5">&#9670;&nbsp;</a></span>isPositiveRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mty::SemiSimpleAlgebra::isPositiveRoot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given root is a positive root (i.e. only positive dinkin labels). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root from which we test the positivity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the root is positive. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a102b64632d6e55ca7e384e72520687fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102b64632d6e55ca7e384e72520687fd">&#9670;&nbsp;</a></span>isPositiveWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mty::SemiSimpleAlgebra::isPositiveWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given state is a positive state (i.e. only positive dinkin labels). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>State from which we test the positivity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>True</b> if the state is positive. </dd>
<dd>
<b>False</b> else. </dd></dl>

</div>
</div>
<a id="a3dabc2ca62085ee19c9a75797bccd250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dabc2ca62085ee19c9a75797bccd250">&#9670;&nbsp;</a></span>multiplicities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; mty::SemiSimpleAlgebra::multiplicities </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the multiplicities of the states in <b>rep</b>, where <b>rep</b> is a complete set of <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>Set of all the states in the representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The multiplicities for each states in a std::vector of integers. </dd></dl>

</div>
</div>
<a id="a4f57c0b5a49af2a8474fdef58da9538c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f57c0b5a49af2a8474fdef58da9538c">&#9670;&nbsp;</a></span>sortRep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mty::SemiSimpleAlgebra::sortRep </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts by modifing input paramaters a set of <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> with their multiplicities. One state is considered "bigger" than another if the sum of its dinkin labels is bigger. Overriden in the R algebra. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>std::vector of <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> to sort, modified during the run. </td></tr>
    <tr><td class="paramname">mult</td><td>multiplicities of the states, sorted at the same time to keep the one to one correspondance between states and multiplicities. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classmty_1_1algebra_1_1R.html#a5818785411f48f0c4ba102f6622d3080">mty::algebra::R</a>.</p>

</div>
</div>
<a id="a6b115c5f8711fd19ec740f3b72cc2535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b115c5f8711fd19ec740f3b72cc2535">&#9670;&nbsp;</a></span>tensorProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1SumIrrep.html">mty::SumIrrep</a> mty::SemiSimpleAlgebra::tensorProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1Irrep.html">Irrep</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1Irrep.html">Irrep</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mult</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the product of two <a class="el" href="classmty_1_1Irrep.html" title="Handles the irreducible representation of a given semi-simple algebra. ">Irrep</a> in the algebra. The result is decomposed in a sum of irreducible representations, stored in a <a class="el" href="classmty_1_1SumIrrep.html" title="Contains a sum of Irrep (irreducible representation) of a given SemiSimpleAlgebra. ">SumIrrep</a>. Overriden in the R algebra. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First representation in the product. </td></tr>
    <tr><td class="paramname">B</td><td>Second representation in the product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classmty_1_1SumIrrep.html" title="Contains a sum of Irrep (irreducible representation) of a given SemiSimpleAlgebra. ">SumIrrep</a>, sum of irreducible representations result of the product. </dd></dl>

<p>Reimplemented in <a class="el" href="classmty_1_1algebra_1_1R.html#a7c5e4dae32aa1f93d750f979085e8151">mty::algebra::R</a>.</p>

</div>
</div>
<a id="a8bb228e4a5fdd3b08e23b8c81dc98742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb228e4a5fdd3b08e23b8c81dc98742">&#9670;&nbsp;</a></span>toDominantWeylChamber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> mty::SemiSimpleAlgebra::toDominantWeylChamber </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflects a given state in the dominant Weyl chamber. </p>
<p>The dominant Weyl chamber is the space where all states are positive states (see <a class="el" href="classmty_1_1SemiSimpleAlgebra.html#a102b64632d6e55ca7e384e72520687fd" title="Checks if a given state is a positive state (i.e. only positive dinkin labels). ">isPositiveWeight()</a>). This function returns the (only) state in the dominant Weyl chamber that is equivalent to <b>state</b> to a Weyl reflection, i.e. to the application of an element of the Weyl group. If the state is positive, it is itself, else the function operates a series of Weyl reflections until it finds the corresponding positive state. The sign of the Transformation is one if the number of reflections linking the two states is even, -1 else. The sign is stored in <b>sign</b> during the run of the function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Initial <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </td></tr>
    <tr><td class="paramname">sign</td><td>Integer modified during the run, stores the sign of the Transformation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>, reflection of <b>state</b> in the dominant Weyl chamber. </dd></dl>

</div>
</div>
<a id="afdcd304629a2f6445da72ca29cc3219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcd304629a2f6445da72ca29cc3219d">&#9670;&nbsp;</a></span>weylReflection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; mty::SemiSimpleAlgebra::weylReflection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simpleRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflects a root with respect to one simple root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simpleRoot,an</td><td>integer specifying the number of the simple root. </td></tr>
    <tr><td class="paramname">root</td><td>Root to reflect, a std::vector of integers labels of the root. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reflected root, also a std::vector of integers. </dd></dl>

</div>
</div>
<a id="ac5b50c98c6d5651542a867169644ea48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b50c98c6d5651542a867169644ea48">&#9670;&nbsp;</a></span>weylReflection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> mty::SemiSimpleAlgebra::weylReflection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simpleRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1AlgebraState.html">AlgebraState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflects a state with respect to one simple root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simpleRoot,an</td><td>integer specifying the number of the simple root. </td></tr>
    <tr><td class="paramname">state</td><td><a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a> to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reflected state, also an <a class="el" href="classmty_1_1AlgebraState.html" title="Class inherited from std::vector&lt;int&gt;, dynkin labels for a state of a semi-simple algebra (see docume...">AlgebraState</a>. </dd></dl>

</div>
</div>
<a id="af86ace73b55c129b67b5a0227aff3f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86ace73b55c129b67b5a0227aff3f6b">&#9670;&nbsp;</a></span>weylReflection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; mty::SemiSimpleAlgebra::weylReflection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simpleRoot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simpleRoot2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflects a simple root with respect to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reflector</td><td>Simple root (integer) wrt which the reflexion is done. </td></tr>
    <tr><td class="paramname">reflected</td><td>Simple root (integer) reflected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reflected root, in the form of a std::vector of integers. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ade2bb4eb37ab85daa6d94402a1a2e482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2bb4eb37ab85daa6d94402a1a2e482">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmty_1_1SemiSimpleAlgebra.html">SemiSimpleAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>algebra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of operator&lt;&lt; for <a class="el" href="classmty_1_1SemiSimpleAlgebra.html" title="Abstract base class for all semi-simple Lie algebras. ">SemiSimpleAlgebra</a>. Displays exhaustively members of the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fout</td><td>Output flux. </td></tr>
    <tr><td class="paramname">algebra</td><td><a class="el" href="classmty_1_1SemiSimpleAlgebra.html" title="Abstract base class for all semi-simple Lie algebras. ">SemiSimpleAlgebra</a> to display. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified output flux. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a8f7ba151cd190383663b1ab77b2d445b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7ba151cd190383663b1ab77b2d445b">&#9670;&nbsp;</a></span>rho</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; mty::SemiSimpleAlgebra::rho</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::vector of size <b>l</b>. Particular root (half-sum of simple roots) useful in calculations. </p>
<p>In order to be able to store it in a simple std::vector of integers, the 1/2 factor is discarded in this member, it corresponds then strictly to 2*rho in standard conventions. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="semiSimpleAlgebra_8h_source.html">semiSimpleAlgebra.h</a></li>
<li>src/semiSimpleAlgebra.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
