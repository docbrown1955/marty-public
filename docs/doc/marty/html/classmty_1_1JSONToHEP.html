<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MARTY: mty::JSONToHEP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/Slashed.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
<link rel="icon" type="image.png" href="../../../logo-marty.png"/>
<link href="style_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
      <a href="https://marty.in2p3.fr"><img alt="Logo" src="Logo1.svg" height=100px/></a></td>
  <td id="projectalign" style="padding-left: 1.5em;">
   <div id="projectname">
       Documentation of <i><b>MARTY</b></i>
   </div>
   <div id="projectbrief">
       <it>A <b>M</b>odern <b>AR</b>tificial <b>T</b>heoretical 
       ph<b>Y</b>sicist</it>
   </div>
  </td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemty.html">mty</a></li><li class="navelem"><a class="el" href="classmty_1_1JSONToHEP.html">JSONToHEP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">mty::JSONToHEP Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Reads a file in .json format containing data of a model and returns the corresponding <a class="el" href="classmty_1_1Model.html" title="Contains all objects in the theory. In particular QuantumField objects, Gauge, Flavor, Particle... ">Model</a> object via its only static public function readModel.  
 <a href="classmty_1_1JSONToHEP.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="jsonToPhysics_8h_source.html">jsonToPhysics.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a60f68f37dfe149df0ab5a548c126d777"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classmty_1_1Model.html">Model</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#a60f68f37dfe149df0ab5a548c126d777">readModel</a> (std::string const &amp;nameFile)</td></tr>
<tr class="memdesc:a60f68f37dfe149df0ab5a548c126d777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a file in .json format containing data of a model and returns the corresponding <a class="el" href="classmty_1_1Model.html" title="Contains all objects in the theory. In particular QuantumField objects, Gauge, Flavor, Particle... ">Model</a> object.  <a href="#a60f68f37dfe149df0ab5a548c126d777">More...</a><br /></td></tr>
<tr class="separator:a60f68f37dfe149df0ab5a548c126d777"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aee06e116de8d65455b2c93ac68605fdc"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classmty_1_1Gauge.html">Gauge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#aee06e116de8d65455b2c93ac68605fdc">readGauge</a> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *tree)</td></tr>
<tr class="memdesc:aee06e116de8d65455b2c93ac68605fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the gauge in the root node of the <a class="el" href="namespaceJSON.html" title="Contains all objects related to JSON reading / writing. ">JSON</a> tree and returns it.  <a href="#aee06e116de8d65455b2c93ac68605fdc">More...</a><br /></td></tr>
<tr class="separator:aee06e116de8d65455b2c93ac68605fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef45566673df4d06cac0d1541c2b9dd"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classmty_1_1Flavor.html">Flavor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#a4ef45566673df4d06cac0d1541c2b9dd">readFlavor</a> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *tree)</td></tr>
<tr class="memdesc:a4ef45566673df4d06cac0d1541c2b9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the flavor in the root node of the <a class="el" href="namespaceJSON.html" title="Contains all objects related to JSON reading / writing. ">JSON</a> tree and returns it.  <a href="#a4ef45566673df4d06cac0d1541c2b9dd">More...</a><br /></td></tr>
<tr class="separator:a4ef45566673df4d06cac0d1541c2b9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6ae4c6aafe5b6edbf52aa2ccccf6a4"><td class="memItemLeft" align="right" valign="top"><a id="adb6ae4c6aafe5b6edbf52aa2ccccf6a4"></a>
static std::vector&lt; <a class="el" href="classmty_1_1QuantumNumber.html">QuantumNumber</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readQuantumNumbers</b> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *tree)</td></tr>
<tr class="separator:adb6ae4c6aafe5b6edbf52aa2ccccf6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aefa7425eb8383ca9ace0f75ff1ef33"><td class="memItemLeft" align="right" valign="top">static <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#a2aefa7425eb8383ca9ace0f75ff1ef33">readGaugeCoupling</a> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *couplingNode)</td></tr>
<tr class="memdesc:a2aefa7425eb8383ca9ace0f75ff1ef33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the gauge coupling in a group <a class="el" href="classNode.html">Node</a> and returns the corresponding csl <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>.  <a href="#a2aefa7425eb8383ca9ace0f75ff1ef33">More...</a><br /></td></tr>
<tr class="separator:a2aefa7425eb8383ca9ace0f75ff1ef33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac393c572fd42e1e655b9a1e59c5d750e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classstd_1_1shared__ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classmty_1_1QuantumFieldParent.html">QuantumFieldParent</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#ac393c572fd42e1e655b9a1e59c5d750e">readField</a> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *tree, <a class="el" href="classmty_1_1Gauge.html">Gauge</a> *gauge, <a class="el" href="classmty_1_1Flavor.html">Flavor</a> *flavor, <a class="el" href="classmty_1_1Model.html">Model</a> *model, std::vector&lt; <a class="el" href="classmty_1_1QuantumNumber.html">QuantumNumber</a> &gt; const &amp;qNumbers)</td></tr>
<tr class="memdesc:ac393c572fd42e1e655b9a1e59c5d750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the fields of the model in the root <a class="el" href="classNode.html">Node</a> of the <a class="el" href="namespaceJSON.html" title="Contains all objects related to JSON reading / writing. ">JSON</a> tree and returns it in the form of a std::vector of QuantumFieldParent*. The parents are newly allocated and only raw pointers are returned.  <a href="#ac393c572fd42e1e655b9a1e59c5d750e">More...</a><br /></td></tr>
<tr class="separator:ac393c572fd42e1e655b9a1e59c5d750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ae3a10f976411aed47de2fbca5bd7"><td class="memItemLeft" align="right" valign="top"><a id="aa10ae3a10f976411aed47de2fbca5bd7"></a>
static std::vector&lt; std::pair&lt; std::string, <a class="el" href="classJSON_1_1Node.html">JSON::Node</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readYukawaNodes</b> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *fields)</td></tr>
<tr class="separator:aa10ae3a10f976411aed47de2fbca5bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062f27c67322fef92e9e67dcb29e9266"><td class="memItemLeft" align="right" valign="top"><a id="a062f27c67322fef92e9e67dcb29e9266"></a>
static <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>interpretYukawaCoupling</b> (<a class="el" href="classmty_1_1Model.html">Model</a> *model, std::string const &amp;nameScalar, <a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *node)</td></tr>
<tr class="separator:a062f27c67322fef92e9e67dcb29e9266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5af396296986670249ca19d280a572d"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#ac5af396296986670249ca19d280a572d">stringToDinkinLabels</a> (std::string const &amp;str)</td></tr>
<tr class="memdesc:ac5af396296986670249ca19d280a572d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Little helper function that converts a string to a vector of int, corresponding to the dinkin labels of a given representation.  <a href="#ac5af396296986670249ca19d280a572d">More...</a><br /></td></tr>
<tr class="separator:ac5af396296986670249ca19d280a572d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f234275db0a40cfd637f1dba551fe89"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmty_1_1GaugeIrrep.html">GaugeIrrep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#a2f234275db0a40cfd637f1dba551fe89">readIrrep</a> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *node, <a class="el" href="classmty_1_1Gauge.html">Gauge</a> *gauge)</td></tr>
<tr class="memdesc:a2f234275db0a40cfd637f1dba551fe89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the irreducible representation of a particle in its <a class="el" href="classNode.html">Node</a>.  <a href="#a2f234275db0a40cfd637f1dba551fe89">More...</a><br /></td></tr>
<tr class="separator:a2f234275db0a40cfd637f1dba551fe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb8132ee62c91fded2eda97db0594c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmty_1_1FlavorIrrep.html">FlavorIrrep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#acbb8132ee62c91fded2eda97db0594c3">readFlavorIrrep</a> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *node, <a class="el" href="classmty_1_1Flavor.html">Flavor</a> *flavor)</td></tr>
<tr class="memdesc:acbb8132ee62c91fded2eda97db0594c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the irreducible representation of a particle in its <a class="el" href="classNode.html">Node</a>.  <a href="#acbb8132ee62c91fded2eda97db0594c3">More...</a><br /></td></tr>
<tr class="separator:acbb8132ee62c91fded2eda97db0594c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d43be13d69f2ffa6a046e67a5ba974c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmty_1_1JSONToHEP.html#a3d43be13d69f2ffa6a046e67a5ba974c">readMass</a> (<a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *massNode, <a class="el" href="classmty_1_1QuantumFieldParent.html">QuantumFieldParent</a> *field)</td></tr>
<tr class="memdesc:a3d43be13d69f2ffa6a046e67a5ba974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the mass in a field <a class="el" href="classNode.html">Node</a> and returns the corresponding csl <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>.  <a href="#a3d43be13d69f2ffa6a046e67a5ba974c">More...</a><br /></td></tr>
<tr class="separator:a3d43be13d69f2ffa6a046e67a5ba974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Reads a file in .json format containing data of a model and returns the corresponding <a class="el" href="classmty_1_1Model.html" title="Contains all objects in the theory. In particular QuantumField objects, Gauge, Flavor, Particle... ">Model</a> object via its only static public function readModel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nameFile</td><td>The name of the .json file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classmty_1_1Model.html" title="Contains all objects in the theory. In particular QuantumField objects, Gauge, Flavor, Particle... ">Model</a> filled with the data. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac393c572fd42e1e655b9a1e59c5d750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac393c572fd42e1e655b9a1e59c5d750e">&#9670;&nbsp;</a></span>readField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classstd_1_1shared__ptr.html">shared_ptr</a>&lt; <a class="el" href="classmty_1_1QuantumFieldParent.html">QuantumFieldParent</a> &gt; &gt; mty::JSONToHEP::readField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmty_1_1Gauge.html">Gauge</a> *&#160;</td>
          <td class="paramname"><em>gauge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmty_1_1Flavor.html">Flavor</a> *&#160;</td>
          <td class="paramname"><em>flavor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmty_1_1Model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmty_1_1QuantumNumber.html">QuantumNumber</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>qNumbers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the fields of the model in the root <a class="el" href="classNode.html">Node</a> of the <a class="el" href="namespaceJSON.html" title="Contains all objects related to JSON reading / writing. ">JSON</a> tree and returns it in the form of a std::vector of QuantumFieldParent*. The parents are newly allocated and only raw pointers are returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Root <a class="el" href="classNode.html">Node</a> of the file. </td></tr>
    <tr><td class="paramname">gauge</td><td>Pointer the the model's gauge to initialize the fields. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::vector of QuantumFieldParent* containing the particles. </dd></dl>

</div>
</div>
<a id="a4ef45566673df4d06cac0d1541c2b9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef45566673df4d06cac0d1541c2b9dd">&#9670;&nbsp;</a></span>readFlavor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classmty_1_1Flavor.html">Flavor</a> &gt; mty::JSONToHEP::readFlavor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the flavor in the root node of the <a class="el" href="namespaceJSON.html" title="Contains all objects related to JSON reading / writing. ">JSON</a> tree and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Pointer to to root <a class="el" href="classNode.html">Node</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer to a newly allocated <a class="el" href="classmty_1_1Flavor.html">Flavor</a>. </dd></dl>

</div>
</div>
<a id="acbb8132ee62c91fded2eda97db0594c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb8132ee62c91fded2eda97db0594c3">&#9670;&nbsp;</a></span>readFlavorIrrep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1FlavorIrrep.html">FlavorIrrep</a> mty::JSONToHEP::readFlavorIrrep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmty_1_1Flavor.html">Flavor</a> *&#160;</td>
          <td class="paramname"><em>flavor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the irreducible representation of a particle in its <a class="el" href="classNode.html">Node</a>. </p>
<p>For each group, the set of dinkin labels (or numerator and denominator for U(1)) must be given. If not, the trivial representation is supposed for this group. The representation is then created at the gauge level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="classNode.html">Node</a> of the representation. </td></tr>
    <tr><td class="paramname">gauge</td><td>Pointer to the gauge to initialize properly the representations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classmty_1_1GaugeIrrep.html">GaugeIrrep</a> read in the file. </dd></dl>

</div>
</div>
<a id="aee06e116de8d65455b2c93ac68605fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee06e116de8d65455b2c93ac68605fdc">&#9670;&nbsp;</a></span>readGauge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classmty_1_1Gauge.html">Gauge</a> &gt; mty::JSONToHEP::readGauge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the gauge in the root node of the <a class="el" href="namespaceJSON.html" title="Contains all objects related to JSON reading / writing. ">JSON</a> tree and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Pointer to to root <a class="el" href="classNode.html">Node</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer to a newly allocated <a class="el" href="classmty_1_1Gauge.html">Gauge</a>. </dd></dl>

</div>
</div>
<a id="a2aefa7425eb8383ca9ace0f75ff1ef33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aefa7425eb8383ca9ace0f75ff1ef33">&#9670;&nbsp;</a></span>readGaugeCoupling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a> mty::JSONToHEP::readGaugeCoupling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *&#160;</td>
          <td class="paramname"><em>couplingNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the gauge coupling in a group <a class="el" href="classNode.html">Node</a> and returns the corresponding csl <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">couplingNode</td><td>Pointer to the coupling <a class="el" href="classNode.html">Node</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expression (aka <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>) corresponding to the coupling. </dd></dl>

</div>
</div>
<a id="a2f234275db0a40cfd637f1dba551fe89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f234275db0a40cfd637f1dba551fe89">&#9670;&nbsp;</a></span>readIrrep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmty_1_1GaugeIrrep.html">GaugeIrrep</a> mty::JSONToHEP::readIrrep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmty_1_1Gauge.html">Gauge</a> *&#160;</td>
          <td class="paramname"><em>gauge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the irreducible representation of a particle in its <a class="el" href="classNode.html">Node</a>. </p>
<p>For each group, the set of dinkin labels (or numerator and denominator for U(1)) must be given. If not, the trivial representation is supposed for this group. The representation is then created at the gauge level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="classNode.html">Node</a> of the representation. </td></tr>
    <tr><td class="paramname">gauge</td><td>Pointer to the gauge to initialize properly the representations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classmty_1_1GaugeIrrep.html">GaugeIrrep</a> read in the file. </dd></dl>

</div>
</div>
<a id="a3d43be13d69f2ffa6a046e67a5ba974c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d43be13d69f2ffa6a046e67a5ba974c">&#9670;&nbsp;</a></span>readMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mty::JSONToHEP::readMass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJSON_1_1Node.html">JSON::Node</a> *&#160;</td>
          <td class="paramname"><em>massNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmty_1_1QuantumFieldParent.html">QuantumFieldParent</a> *&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the mass in a field <a class="el" href="classNode.html">Node</a> and returns the corresponding csl <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">massNode</td><td>Pointer to the mass <a class="el" href="classNode.html">Node</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expression (aka <a class="elRef" doxygen="/home/uhlrich/Bureau/MARTY/newlife/marty-dev/csl/csl.tag:../../csl/html/" href="../../csl/html/classcsl_1_1Expr.html">csl::Expr</a>) corresponding to the mass. </dd></dl>

</div>
</div>
<a id="a60f68f37dfe149df0ab5a548c126d777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f68f37dfe149df0ab5a548c126d777">&#9670;&nbsp;</a></span>readModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classmty_1_1Model.html">Model</a> &gt; mty::JSONToHEP::readModel </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>nameFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a file in .json format containing data of a model and returns the corresponding <a class="el" href="classmty_1_1Model.html" title="Contains all objects in the theory. In particular QuantumField objects, Gauge, Flavor, Particle... ">Model</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nameFile</td><td>The name of the .json file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classmty_1_1Model.html" title="Contains all objects in the theory. In particular QuantumField objects, Gauge, Flavor, Particle... ">Model</a> filled with the data. </dd></dl>

</div>
</div>
<a id="ac5af396296986670249ca19d280a572d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5af396296986670249ca19d280a572d">&#9670;&nbsp;</a></span>stringToDinkinLabels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; mty::JSONToHEP::stringToDinkinLabels </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Little helper function that converts a string to a vector of int, corresponding to the dinkin labels of a given representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::vector of int containing the labels. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="jsonToPhysics_8h_source.html">jsonToPhysics.h</a></li>
<li>src/jsonToPhysics.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
