<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Getting Started (MARTY)</title>
        <meta charset="utf-8"/>
        <meta name="HandheldFriendly" content="true" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=100%;">
        <meta name="description" content="MARTY is an open-source code for automated calculations in High-Energy Physics. Within a large variety of BSM models, make it calculate amplitudes, cross-sections and Wilson coefficients up to the 1-loop level." />
        <link rel="stylesheet" type="text/css" href="style/style.css" title="default">
        <link rel="stylesheet" type="text/css" href="style/style_cpp.css" title="default">
        <link rel="icon" type="image/png" href="images/logo-marty.png"/>
    </head>
    <body id="top">
        <div id="page">
            <div id="banner-container">
                <div id="banner">
                  <a style="text-decoration: none;" href="index.html">
                 <img id="logo" src="images/MARTY - Border with text - BLACK.png"/>
                  </a>
                    <ul id="menu">
                        <li><img class="dot" src="images/circle-blue.png"/> <span class="learn"><a href="learn.html">   LEARN</a></span></li>
                        <li><img class="dot" src="images/circle-green.png"/><span class="downl"><a href="download.html">   DOWNLOAD</a><span/></li>
                        <li><img class="dot" src="images/circle-red.png"/>  <span class="publi"><a href="publications.html">   PUBLICATIONS</a></span></li>
                        <li><img class="dot" src="images/circle-black.png"/><span class="conta"><a href="contact.html">   CONTACT</a></span></li>
                    </ul>
                </div>
            </div>


<div class="bannerlearn">
    <h1 style="font-weight: normal; font-size: 28pt;">
        Getting Started
    </h1>
</div>
<div id="content" >

<div style="width: 95%; margin: 0 auto;">
<h2>Include <i>MARTY</i> in C++ programs</h2>
<p>For the samples presented here to work, one must have downloaded and
installed <i>MARTY</i>, for example following 
<a href="download.html" title="Setup MARTY">instructions given on the download page.</a>
We must here include the main header file of marty. All the library will be included in it,
including the <i>CSL</i> library. <code><span class="keyword">using namespace</span></code> 
instructions are not necessary, but will prevent us to write 
<code><span class="std">std</span>::</code> in front of objects from the C++ standard library, 
<code><span class="mty">mty</span>::</code> in from of those in <i>MARTY</i>,
and <code><span class="csl">csl</span>::</code> for <i>CSL</i>.</p>
<pre>
 <code>
  <span class="comment">// My first program with MARTY</span>
  <span class="preprocessor">#include &lt;marty.h&gt;</span>

  <span class="keyword">using namespace</span> <span class="std">std</span>;
  <span class="keyword">using namespace</span> <span class="mty">mty</span>;
  <span class="keyword">using namespace</span> <span class="csl">csl</span>;

  <span class="keyword">int</span> main () {

    <span class="std">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="std">endl</span>;
    
    <span class="keyword">return</span> <span class="number">0</span>;
  }
 </code>
</pre>

<h2>Compile a MARTY program</h2>

<p>Let's now compile the code written in main.cpp:</p>
<pre>
 <code>
    g++ -std=c++17 -c main.cpp -o main.o 
 </code>
</pre>
<p>In case <i>MARTY</i> is installed in a non-standard path,
    the compiler will need to know where to find the header file (marty.h) 
except proper environment variables are already set (see <a href="download.html">installation instructions</a>):</p>
<pre>
 <code>
    g++ -std=c++17 -c main.cpp -o main.o -I&lt;marty-install-path&gt;/include
 </code>
</pre>
<p>One must then link the compiled file to the <i>MARTY</i> libraries in order to get the 
final executable. This gives:</p>
<pre>
 <code>
    g++ -std=c++17 -o main.x main.o -lmarty 
 </code>
</pre>
<p>In case <i>MARTY</i> and/or <i>CSL</i> are installed in a non-standard path,
the compiler needs to know where to find the library files (.so files)
except if proper environment variables are already set (see <a href="download.html">installation instructions</a>):</p>
<pre>
 <code>
    g++ -std=c++17 -o main.x main.o -L&lt;marty-install-path&gt;/lib -lmarty 
 </code>
</pre>
<p>We are now ready to execute the compiled program:</p>
<pre>
 <code>
  ./main.x
 </code>
</pre>
<p>If <i>MARTY</i> and <i>CSL</i> are not installed in a standard path, one 
needs to tell the dynamic linker where to find the libraries by specifying 
LD_LIBRARY_PATH except if proper environment variables are already set (see <a href="download.html">installation instructions</a>)</p>
<p>On Linux:</p>
<pre>
 <code>
  export LD_LIBRARY_PATH=&lt;marty-install-path&gt;/lib && ./main.x 
 </code>
</pre>
<p>On Mac:</p>
<pre>
 <code>
  export DYLD_LIBRARY_PATH=&lt;marty-install-path&gt;/lib && ./main.x 
 </code>
</pre>

<h2>A first toy model example</h2>
<p>One may download the file corresponding to this example by <a download href="code/gettingStarted.cpp">clicking here</a>.</p>

<p>In the main.cpp, let's create with a toy model SU(2)<sub>L</sub>xU(1)<sub>Y</sub> that breaks into a 
U(1)<sub>em</sub> gauge. Let's consider only four Weyl fermions, Q<sub>L</sub>, U<sub>R</sub>,
and D<sub>R</sub>. The irreducible representations are:</p>
<ul>
    <li>Q<sub>L</sub>: (2, 1/6) SU(2) doublet with hypercharge 1/6</li>
    <li>U<sub>R</sub>: (1, 2/3) SU(2) singlet with hypercharge 2/3</li>
    <li>D<sub>R</sub>: (1, -1/3) SU(2) singlet with hypercharge -1/3</li>
</ul>

<h3>Model building</h3>
<p>First, we have to create the model and the gauge:</p>
<pre>
 <code>
  <span class="mty">Model</span> toyModel;
  toyModel.addGaugedGroup(<span class="mty">group</span>::<span class="mty">Type</span>::<span class="mty">SU</span>, <span class="string">"L"</span>, 2);
  toyModel.addGaugedGroup(<span class="mty">group</span>::<span class="mty">Type</span>::<span class="mty">U1</span>, <span class="string">"Y"</span>);
  toyModel.init();
 </code>
</pre>
<p>We simply add the two gauged group one after the other. Once the gauge is complete,
the model must be initialized with <code>init()</code> before adding matter content.
Let's now name our vector bosons to follow conventions we like taking into account
the fact that <i>MARTY</i> set default boson names A_&lt;group-name&gt;:</p>
<pre>
 <code>
  toyModel.renameParticle(<span class="string">"A_L"</span>, <span class="string">"W"</span>);
  toyModel.renameParticle(<span class="string">"A_Y"</span>, <span class="string">"B"</span>);
 </code>
</pre>

<p>Now the matter content, the four Weyl fermions:</p>
<pre>
 <code>
  <span class="mty">Particle</span> Q_L = <span class="mty">weylfermion_s</span>(<span class="string">"Q_L"</span>, toyModel, <span class="mty">Chirality</span>::<span class="mty">Left</span>);
  <span class="mty">Particle</span> u_R = <span class="mty">weylfermion_s</span>(<span class="string">"u_R"</span>, toyModel, <span class="mty">Chirality</span>::<span class="mty">Right</span>);
  <span class="mty">Particle</span> d_R = <span class="mty">weylfermion_s</span>(<span class="string">"d_R"</span>, toyModel, <span class="mty">Chirality</span>::<span class="mty">Right</span>);

  Q_L-&gt;setGroupRep(<span class="string">"L"</span>, {1});
  Q_L-&gt;setGroupRep(<span class="string">"Y"</span>, {1, 6});
  u_R-&gt;setGroupRep(<span class="string">"Y"</span>, {2, 3});
  d_R-&gt;setGroupRep(<span class="string">"Y"</span>, {-1, 3});
 </code>
</pre>
<p>Several things to note here. First, one can see that when creating the fermions, one 
must give the model and the chirality (not for a Dirac fermion). Then, the representations
must be given for each group (if not trivial). This works with the fractional 
charge for U(1), and dinkyn labels for the other groups. Numerator and denominator 
of the U(1) charge are given separately in braces, to match the syntax for dinkyn 
labels also given between braces (only one label here for SU(2)). For Su(2), the
doublet representation has label 1, the triplet has label 2 etc. Once the representation
of a particle is complete, it may be added to the model to initialize its kinetic (and possibly
mass) term automatically.</p>
<pre>
 <code>
  toyModel.addParticle(Q_L);
  toyModel.addParticle(u_R);
  toyModel.addParticle(d_R);
 </code>
</pre>
<p>We can now display the model in the terminal using standard output:</p>
<pre>
 <code>
  <span class="std">cout</span> &lt;&lt; toyModel &lt;&lt; <span class="std">endl</span>;
 </code>
</pre>
<h3>Model breaking</h3>
<p>Let's now break the symmetry. For U(1)<sub>Y</sub> then SU(2)<sub>L</sub>:</p>
<pre>
 <code>
  toyModel.breakGaugeSymmetry(<span class="string">"Y"</span>);
  toyModel.breakGaugeSymmetry(<span class="string">"L"</span>);
 </code>
</pre>
<p>Breaking the hypercharge symmetry does basically nothing but telling <i>MARTY</i>
that future interaction terms may violate it. Breaking the SU(2) symmetry does
more. It breaks all tensors in SU(2)<sub>L</sub> representations. In particular,
the doublet Q<sub>L</sub> is broken in Q<sub>L1</sub> and Q<sub>L2</sub> (the 
names are chosen automatically, adding _1 _2 _3... to broken fields names). We 
rename then the broken left quarks to u<sub>L</sub> and d<sub>L</sub>:</p>
<pre>
 <code>
  toyModel.renameParticle(<span class="string">"Q_L_1"</span>, <span class="string">"u_L"</span>);
  toyModel.renameParticle(<span class="string">"Q_L_2"</span>, <span class="string">"d_L"</span>);
 </code>
</pre>
<h4>Simulating a Higgs mechanism</h4>
<p>Here we do not want to have a complete Higgs mechanism, juste to add mass terms 
ourselves. A Higgs mechanism can be implemented as well and one may found examples
in the <a href="learn.html" title="Learn MARTY">manual</a>. This will in
particular introduce a bit of <i>CSL</i>, how to create mathematical expressions.</p>

<p>First, we needed to simulate the rotation between B and W<sup>3</sup> that gives
the photon A and the Z boson as well as the linear combination of W<sup>1</sup>
and W<sup>2</sup> giving W<sup>+</sup>:</p>
<pre>
 <code>
  <span class="mty">Particle</span> W_1 = toyModel.getParticle("W_1");
  <span class="mty">Particle</span> W_2 = toyModel.getParticle("W_2");
  <span class="mty">Particle</span> F_W_1 = W_1-&gt;getFieldStrength();
  <span class="mty">Particle</span> F_W_2 = W_2-&gt;getFieldStrength();
  <span class="mty">Particle</span> W = W_1-&gt;generateSimilar(<span class="string">"W"</span>);
  W-&gt;setSelfConjugate(false); // W is complex, not W_1
  <span class="csl">Index </span>mu = <span class="csl">MinkowskiIndex</span>();
  <span class="csl">Index </span>nu = <span class="csl">MinkowskiIndex</span>();
  <span class="comment">// W_1 goes to (W+ + W-) / sqrt(2)</span>
  toyModel.replace(W_1, (W(mu) + <span class="csl">GetComplexConjugate</span>(W(mu))) / <span class="csl">sqrt_s</span>(2));
  <span class="comment">// Same for the field strength F_W</span>
  toyModel.replace(F_W_1, (W({mu, nu}) + <span class="csl">GetComplexConjugate</span>(W({mu, nu}))) / <span class="csl">sqrt_s</span>(2));
  <span class="comment">// W_2 goes to i*(W+ - W-) / sqrt(2)</span>
  toyModel.replace(W_2, <span class="csl">CSL_I</span> * (W(mu) - <span class="csl">GetComplexConjugate</span>(W(mu))) / <span class="csl">sqrt_s</span>(2));
  <span class="comment">// Same for the field strength F_W</span>
  toyModel.replace(F_W_2, <span class="csl">CSL_I</span> * (W({mu, nu}) - <span class="csl">GetComplexConjugate</span>(W({mu, nu}))) / <span class="csl">sqrt_s</span>(2));

  <span class="csl">Expr</span> thetaW = <span class="csl">constant_s</span>(<span class="string">"thetaW"</span>);
  <span class="csl">Expr</span> cW = <span class="csl">cos_s</span>(thetaW);
  <span class="csl">Expr</span> sW = <span class="csl">sin_s</span>(thetaW);
  <span class="comment">// We give the rotation matrix explicitly here, between double curly braces</span>
  toyModel.rotateFields(
          {<span class="string">"W_3"</span>, <span class="string">"B"</span>},
          {<span class="string">"Z"</span>  , <span class="string">"A"</span>},
          {{cW,  sW},
           {-sW, cW}}
          );

  <span class="csl">Expr</span> e = <span class="csl">constant_s</span>(<span class="string">"e"</span>);
  <span class="csl">Expr</span> g_Y = toyModel.getScalarCoupling(<span class="string">"g_Y"</span>);
  <span class="csl">Expr</span> g_L = toyModel.getScalarCoupling(<span class="string">"g_L"</span>);
  toyModel.replace(g_Y, e / cW);
  toyModel.replace(g_L, e / sW);
 </code>
</pre>
<p>There is here already a bit of work with expressions and tensors. It is on purpose, 
to help the reader to quickly get good habits on the symbolic manipulations in 
<i>CSL</i>. In particular, when we introduce W<sup>+</sup>, we have to get
indices in the Minkowski space to use it with the Particle objects between 
parentheses, and curly braces if there is more than one index. We also just saw 
how to get symbolic functions, sums, products, the imaginary i, constants, and 
how to store expressions in variables.</p>
<pre>
 <code>
  <span class="csl">Expr</span> M_W = <span class="csl">constant_s</span>(<span class="string">"M_W"</span>);
  <span class="csl">Expr</span> m_u = <span class="csl">constant_s</span>(<span class="string">"m_u"</span>);
  <span class="csl">Expr</span> m_d = <span class="csl">constant_s</span>(<span class="string">"m_d"</span>);

  toyModel.addBosonicMass(<span class="string">"W"</span>, M_W);
  toyModel.addFermionicMass(<span class="string">"u_L"</span>, <span class="string">"u_R"</span>, m_u);
  toyModel.addFermionicMass(<span class="string">"d_L"</span>, <span class="string">"d_R"</span>, m_d);
 </code>
</pre>
<p>This is a good bit of work ! Now let's refresh the model to let <i>MARTY</i>
    do some simplifications in the Lagrangian and see what is inside our 
    particle physics model:</p>
<pre>
 <code>
  toyModel.refresh();
  <span class="std">cout</span> &lt;&lt; toyModel &lt;&lt; <span class="std">endl</span>;
 </code>
</pre>

<h3>Calculations</h3>
<h4>Feynman rules</h4>
<p>This part is really simple. Feynman rules are calculated automatically when 
launching a computation if they have not already been calculated. One may still
get them explicitly, displaying them on the terminal and showing the diagrams in
<i>GRAFED</i>:</p>
<pre>
 <code>
  <span class="keyword">auto</span> rules = toyModel.getFeynmanRules();
  <span class="mty">Display</span>(rules); <span class="comment">// Displays expressions in terminal</span>
  <span class="mty">Show</span>(rules); <span class="comment">// Shows diagrams in the application</span>
 </code>
</pre>
<h4>Amplitude</h4>
<p>Let's now apply our model to a physical calculation, the uu&#772;&rarr;dd&#773;
transition. This process is interesting because all the vector bosons participate
to the it. To calculate an amplitude, <i>MARTY</i> needs field insertions, and
a perturbation theory order. Let's consider the tree-level to simplify the 
example. Keep in mind that the rest of the code would be the same for other
insertions or at one-loop. </p>
<pre>
 <code>
  <span class="keyword">auto</span> res = toyModel.<span class="mty">computeAmplitude</span>(
        <span class="mty">Order</span>::<span class="mty">TreeLevel</span>,
        {<span class="mty">Incoming</span>(<span class="string">"u"</span>), <span class="mty">Incoming</span>(<span class="mty">AntiPart</span>(<span class="string">"u"</span>)),
        <span class="mty">Outgoing</span>(<span class="string">"d"</span>), <span class="mty">Outgoing</span>(<span class="mty">AntiPart</span>(<span class="string">"d"</span>))}
        );
 </code>
</pre>
<p>We gave the order, the model, and insertions given by names, specifying each time
if the field is incoming or outgoing, and particle (default) or anti-particle.
The result is stored in res, that contains expressions (<code>res.expressions</code>)
and diagrams (<code>res.diagrams</code>). Expressions can be displayed in the
terminal with <code><span class="mty">Display</span>(res)</code> and diagrams can be showed by 
<i>GRAFED</i> with <code><span class="mty">Show</span>(res)</code>:</p>
<pre>
 <code>
  <span class="mty">Display</span>(res);
  <span class="mty">Show</span>(res);
 </code>
</pre>
<h4>Squared amplitude</h4>
<p>Then, let's create with <i>MARTY</i> a library containing the squared amplitude 
of this process as a numerical C++ function. First, we need to calculate this
quantity:</p>
<pre>
 <code>
  <span class="csl">Expr</span> squared_ampl = toyModel.computeSquaredAmplitude(res);
 </code>
</pre>
<p>The squared amplitude is a scalar symbolic expression. It is averaged over incoming
spins. 

<h4>Library generation</h4>
<p>Now, let's place the library in a given location 
and compile it automatically with <i>MARTY</i>:</p>
<pre>
 <code>
  <span class="mty">mty</span>::<span class="mty">Library</span> myLib(<span class="string">"toy"</span>, <span class="string">"&lt;library-location-path&gt;"</span>);
  myLib.addFunction(<span class="string">"squared_ampl"</span>, squared_ampl);
  myLib.build();
 </code>
</pre>
<p>One has to precise here <code><span class="mty">mty</span>::</code> because
    it is an object that already exists in <i>CSL</i> (<code><span class="csl">csl</span>::<span class="csl">Library</span></code>), doing the same thing. 
    The specialized object in the namespace <code><span class="mty">mty</span></code>
simply adds some standard options for the generated library to compile properly. 
It is recommended to always use the library in the <code><span class="mty">mty</span></code>
namespace.</p>

<p>If <i>MARTY</i> and/or <i>CSL</i> are not installed in a standard path, one
    must add the following lines before building the library:</p>
<pre>
 <code>
  myLib.addIPath(<span class="string">"&lt;marty-installation-path&gt;/include"</span>);
  myLib.addIPath(<span class="string">"&lt;csl-installation-path&gt;/include"</span>);
  myLib.addLPath(<span class="string">"&lt;marty-installation-path&gt;/lib"</span>);
  myLib.addLPath(<span class="string">"&lt;csl-installation-path&gt;/lib"</span>);
 </code>
</pre>

<h3>Library usage</h3>
<p>Now that the library is built, let's go in its folder and try to evaluate our
squared amplitude. By modifying the file <code>script/example_toy.cpp</code>
and typing <code>make</code> in the root directory of the library, one may directly 
get a running program in <code>bin/example_toy.x</code>. For example:</p>
<pre>
 <code>
  <span class="preprocessor">#include "toy.h"</span>

  <span class="keyword">using namespace </span><span class="std">std</span>;
  <span class="keyword">using namespace </span><span class="mty">toy</span>;

  <span class="keyword">int</span> main() {

    <span class="comment">// Initial parameter definitions</span>
    <span class="keyword">double</span> M_W = <span class="number">80.379</span>;
    <span class="keyword">double</span> e   = <span class="std">sqrt</span>(<span class="number">4</span> * <span class="number">M_PI</span> * <span class="number">1.</span> / <span class="number">137</span>);
    <span class="keyword">double</span> m_u = <span class="number">0</span>;
    <span class="keyword">double</span> m_d = <span class="number">0</span>;
    <span class="keyword">double</span> thetaW = <span class="std">asin</span>(<span class="std">sqrt</span>(0.231));

    <span class="comment">// Kinematics left to the user</span>
    <span class="keyword">double</span> E_CM = <span class="number">1e2</span>; <span class="comment">// 100 GeV in center of mass</span>
    <span class="keyword">double</span> theta = <span class="number">M_PI</span> / <span class="number">3</span>; <span class="comment">// Let's take an angle of pi / 3</span>
    <span class="keyword">double</span> s = E_CM * E_CM;
    <span class="keyword">double</span> t = s / <span class="number">2</span> * (<span class="number">1</span> - <span class="std">cos</span>(theta));
    <span class="keyword">double</span> u = s / <span class="number">2</span> * (<span class="number">1</span> + <span class="std">cos</span>(theta));

    <span class="keyword">double</span> s_12, s_13, s_14, s_23, s_24, s_34;
    s_12 = s_34 = s / <span class="number">2</span>;
    s_13 = s_24 = -t / <span class="number">2</span>;
    s_14 = s_23 = -u / <span class="number">2</span>;

    <span class="keyword">param_t</span> params;
    params.M_W = M_W;
    params.reg_prop = 0; <span class="comment">// Regulator not needed here</span>
    params.e = e;
    params.m_u = m_u;
    params.m_d = m_d;
    params.thetaW = thetaW;
    params.s_12 = s_12;
    params.s_13 = s_13;
    params.s_14 = s_14;
    params.s_23 = s_23;
    params.s_24 = s_24;
    params.s_34 = s_34;

    <span class="comment">// Final result</span>
    <span class="std">cout</span> &lt;&lt; <span class="string">"Squared amplitude: "</span>;
    <span class="std">cout</span> &lt;&lt; squared_ampl(params);
    <span class="std">cout</span> &lt;&lt; <span class="std">endl</span>;

    <span class="keyword">return</span> <span class="number">0</span>;
  }
 </code>
</pre>
<p>Finally, here is the result:</p>
<pre>
 <code>
  Squared amplitude = (0.201037,0)
 </code>
</pre>
<p>One can see that the squared amplitude is real, and the final value will of course 
depend on the initial parameters. We built a model entirely 
from scratch, calculated an amplitude followed by its squared value implying even
more simplifications, obtained its analytical value and generated automatically 
a numerical C++ library evaluating this analytical expression for a given set of
initial parameters. All of this in less than a hundred lines of code.
</p>
</div>
</div>
</div>
</div>
</body>
</div>
<div id="footer-container" ,style="margin-top: 50px;">
    <div id="footer">
        MARTY is licensed under the terms and conditions of the <a href="https://www.gnu.org/licenses/gpl-3.0.html">GNU GPL license</a>.<br>
        Author: <a href="mailto:marty.uhlrich@gmail.com" title="Contact the author">Grégoire Uhlrich</a>
    </div>
</div>
</html>

